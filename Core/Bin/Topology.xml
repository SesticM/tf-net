<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Topology</name>
    </assembly>
    <members>
<member name="T:topology.linearref.LengthLocationMap">
<remarks>Computes the {@link LinearLocation} for a given length along a linear {@link Geometry}. Negative lengths are measured in reverse from end of the linear geometry. Out-of-range values are clamped.</remarks>
        </member>
<member name="M:topology.linearref.LengthLocationMap.getLocation(Geometry,System.Double)">
<summary>Computes the {@link LinearLocation} for a given length along a linear {@link Geometry}.</summary>
<param name="line">the linear geometry to use</param>
<param name="length">the length index of the location</param>
<returns>the {@link LinearLocation} for the length</returns>
        </member>
<member name="M:topology.linearref.LengthLocationMap.getLength(Geometry,LinearLocation)">
<summary>Computes the length for a given {@link LinearLocation} on a linear {@link Geometry}.</summary>
<param name="line">the linear geometry to use</param>
<param name="loc">the {@link LinearLocation} index of the location</param>
<returns>the length for the {@link LinearLocation}</returns>
        </member>
<member name="M:topology.linearref.LengthLocationMap.getLocation(System.Double)">
<summary>Compute the {@link LinearLocation} corresponding to a length.</summary>
<param name="length">the length index</param>
<returns>the corresponding LinearLocation</returns>
        </member>
<member name="T:topology.operation.overlay.OverlayNodeFactory">
<remarks>Creates nodes for use in the {@link PlanarGraph}s constructed during overlay operations.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.algorithm.NonRobustLineIntersector">
<remarks>A non-robust version of {@LineIntersector}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.algorithm.NonRobustLineIntersector.isSameSignAndNonZero(System.Double,System.Double)">
<returns>true if both numbers are positive or if both numbers are negative. Returns false if both numbers are zero.</returns>
        </member>
<member name="M:topology.algorithm.NonRobustLineIntersector.rParameter(Coordinate,Coordinate,Coordinate)">
<summary>RParameter computes the parameter for the point p in the parameterized equation of the line from p1 to p2.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.simplify.TopologyPreservingSimplifier -->
<member name="M:topology.simplify.TopologyPreservingSimplifier.setDistanceTolerance(System.Double)">
<summary>Sets the distance tolerance for the simplification.</summary>
<param name="distanceTolerance">the approximation tolerance to use</param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.util.GeometryEditor -->
<member name="F:topology.geom.util.GeometryEditor.factory">
<summary>The factory used to create the modified Geometry</summary>
        </member>
<member name="M:topology.geom.util.GeometryEditor.#ctor">
<summary>Creates a new GeometryEditor object which will create an edited {@link Geometry} with the same {@link GeometryFactory} as the input Geometry.</summary>
        </member>
<member name="M:topology.geom.util.GeometryEditor.#ctor(GeometryFactory)">
<summary>Creates a new GeometryEditor object which will create the edited Geometry with the given {@link GeometryFactory}</summary>
<param name="factory">the GeometryFactory to create the edited Geometry with</param>
        </member>
<member name="M:topology.geom.util.GeometryEditor.edit(Geometry,GeometryEditorOperation)">
<summary>Edit the input {@link Geometry} with the given edit operation.</summary>
<param name="geometry">the Geometry to edit</param>
<param name="operation">the edit operation to carry out</param>
<returns>a new {@link Geometry} which is the result of the editing</returns>
        </member>
<member name="T:topology.geom.util.GeometryEditor.GeometryEditorOperation">
<remarks>A interface which specifies an edit operation for Geometries.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.util.GeometryEditor.GeometryEditorOperation.edit(Geometry,GeometryFactory)">
<summary>Edits a Geometry by returning a new Geometry with a modification.</summary>
<param name="geometry">the Geometry to modify</param>
<param name="factory">the factory with which to construct the modified Geometry (may be different to the factory of the input geometry)</param>
<returns>a new Geometry which is a modification of the input Geometry</returns>
        </member>
<member name="T:topology.geom.util.GeometryEditor.CoordinateOperation">
<remarks>A {@link GeometryEditorOperation} which modifies the coordinate list of a {@link Geometry}. Operates on Geometry subclasses which contains a single coordinate list.</remarks>
        </member>
<member name="M:topology.geom.util.GeometryEditor.CoordinateOperation.edit(Coordinate[],Geometry)">
<summary>Edits the array of {@link Coordinate}s from a {@link Geometry}.</summary>
<param name="coordinates">the coordinate array to operate on</param>
<param name="geometry">the geometry containing the coordinate list</param>
<returns>an edited coordinate array (which may be the same as the input)</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.io.WKBWriter -->
<member name="M:topology.io.WKBWriter.#ctor">
<summary>Creates a writer that writes {@link Geometry}s with output dimension = 2 and BIG_ENDIAN byte order</summary>
        </member>
<member name="M:topology.io.WKBWriter.#ctor(System.Int32)">
<summary>Creates a writer that writes {@link Geometry}s with the given output dimension (2 or 3) and BIG_ENDIAN byte order</summary>
<param name="outputDimension">the dimension to output (2 or 3)</param>
        </member>
<member name="M:topology.io.WKBWriter.#ctor(System.Int32,System.Int32)">
<summary>Creates a writer that writes {@link Geometry}s with the given output dimension (2 or 3) and byte order</summary>
<param name="outputDimension">the dimension to output (2 or 3)</param>
<param name="byteOrder">the byte ordering to use</param>
        </member>
<member name="M:topology.io.WKBWriter.write(Geometry)">
<summary>Writes a {@link Geometry} into a byte array.</summary>
<param name="geom">the geometry to write</param>
<returns>the byte array containing the WKB</returns>
        </member>
<member name="M:topology.io.WKBWriter.write(Geometry,OutStream)">
<summary>Writes a {@link Geometry} to an {@link OutStream}.</summary>
<param name="geom">the geometry to write</param>
<param name="os">the out stream to write to</param>
        </member>
<member name="T:topology.geom.CoordinateArrays">
<remarks>Useful utility functions for handling Coordinate arrays</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.CoordinateArrays.ptNotInList(Coordinate[],Coordinate[])">
<summary>Finds a point in a list of points which is not contained in another list of points</summary>
<param name="testPts">the {@link Coordinate}s to test</param>
<param name="pts">an array of {@link Coordinate}s to test the input points against</param>
<returns>a {@link Coordinate} from <code>testPts</code> which is not in <code>pts</code>, ' or <code>null</code></returns>
        </member>
<member name="M:topology.geom.CoordinateArrays.compare(Coordinate[],Coordinate[])">
<summary>Compares two {@link Coordinate} arrays in the forward direction of their coordinates, using lexicographic ordering.</summary>
<param name="pts1"></param>
<param name="pts2"></param>
<returns></returns>
        </member>
<member name="T:topology.geom.CoordinateArrays.ForwardComparator">
<remarks>A {@link Comparator} for {@link Coordinate} arrays in the forward direction of their coordinates, using lexicographic ordering.</remarks>
        </member>
<member name="M:topology.geom.CoordinateArrays.increasingDirection(Coordinate[])">
<summary>Determines which orientation of the {@link Coordinate} array is (overall) increasing.</summary>
<param name="pts">the array of Coordinates to test</param>
<returns><code>1</code> if the array is smaller at the start or is a palindrome, <code>-1</code> if smaller at the end</returns>
        </member>
<member name="M:topology.geom.CoordinateArrays.isEqualReversed(Coordinate[],Coordinate[])">
<summary>Determines whether two {@link Coordinate} arrays of equal length are equal in opposite directions.</summary>
<param name="pts1"></param>
<param name="pts2"></param>
<returns><code>true</code> if the two arrays are equal in opposite directions.</returns>
        </member>
<member name="T:topology.geom.CoordinateArrays.BidirectionalComparator">
<remarks>A {@link Comparator} for {@link Coordinate} arrays modulo their directionality. E.g. if two coordinate arrays are identical but reversed they will compare as equal under this ordering. If the arrays are not equal, the ordering returned is the ordering in the forward direction.</remarks>
        </member>
<member name="M:topology.geom.CoordinateArrays.copyDeep(Coordinate[])">
<summary>Creates a deep copy of the argument {@link Coordinate) array.</summary>
<param name="coordinates">an array of Coordinates</param>
<returns>a deep copy of the input</returns>
        </member>
<member name="M:topology.geom.CoordinateArrays.toCoordinateArray(Collection)">
<summary>Converts the given Collection of Coordinates into a Coordinate array.</summary>
        </member>
<member name="M:topology.geom.CoordinateArrays.hasRepeatedPoints(Coordinate[])">
<summary>Returns whether #equals returns true for any two consecutive Coordinates in the given array.</summary>
        </member>
<member name="M:topology.geom.CoordinateArrays.atLeastNCoordinatesOrNothing(System.Int32,Coordinate[])">
<summary>Returns either the given coordinate array if its length is greater than the given amount, or an empty coordinate array.</summary>
        </member>
<member name="M:topology.geom.CoordinateArrays.removeRepeatedPoints(Coordinate[])">
	<summary>If the coordinate array argument has repeated points, constructs a new array containing no repeated points.</summary>
	<seealso cref="!:#hasRepeatedPoints(Coordinate[])"/>
</member>
<member name="M:topology.geom.CoordinateArrays.reverse(Coordinate[])">
<summary>Reverses the coordinates in an array in-place.</summary>
        </member>
<member name="M:topology.geom.CoordinateArrays.equals(Coordinate[],Coordinate[])">
	<summary>Returns true if the two arrays are identical, both null, or pointwise equal (as compared using Coordinate#equals)</summary>
	<seealso cref="!:Coordinate#equals(Object)"/>
</member>
<member name="M:topology.geom.CoordinateArrays.equals(Coordinate[],Coordinate[],Comparator)">
<summary>Returns true if the two arrays are identical, both null, or pointwise equal, using a user-defined {@link Comparator} for {@link Coordinate} s</summary>
<param name="coord1">an array of Coordinates</param>
<param name="coord2">an array of Coordinates</param>
<param name="coordinateComparator">a Comparator for Coordinates</param>
        </member>
<member name="M:topology.geom.CoordinateArrays.minCoordinate(Coordinate[])">
	<summary>Returns the minimum coordinate, using the usual lexicographic comparison.</summary>
	<param name="coordinates">the array to search</param>
	<returns>the minimum coordinate in the array, found using <code>compareTo</code></returns>
	<seealso cref="!:Coordinate#compareTo(Object)"/>
</member>
<member name="M:topology.geom.CoordinateArrays.scroll(Coordinate[],Coordinate)">
<summary>Shifts the positions of the coordinates until <code>firstCoordinate</code> is first.</summary>
<param name="coordinates">the array to rearrange</param>
<param name="firstCoordinate">the coordinate to make first</param>
        </member>
<member name="M:topology.geom.CoordinateArrays.indexOf(Coordinate,Coordinate[])">
<summary>Returns the index of <code>coordinate</code> in <code>coordinates</code>.</summary>
<param name="coordinate">the <code>Coordinate</code> to search for</param>
<param name="coordinates">the array to search</param>
<returns>the position of <code>coordinate</code>, or -1 if it is not found</returns>
        </member>
<member name="M:topology.geom.CoordinateArrays.extract(Coordinate[],System.Int32,System.Int32)">
<summary>Extracts a subsequence of the input {@link Coordinate} array from indices <code>start</code> to <code>end</code> (inclusive).</summary>
<param name="pts">the input array</param>
<param name="start">the index of the start of the subsequence to extract</param>
<param name="end">the index of the end of the subsequence to extract</param>
<returns>a subsequence of the input array</returns>
        </member>
<member name="T:topology.operation.buffer.SubgraphDepthLocater">
<remarks>Locates a subgraph inside a set of subgraphs, in order to determine the outside depth of the subgraph. The input subgraphs are assumed to have had depths already calculated for their edges.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.buffer.SubgraphDepthLocater.findStabbedSegments(Coordinate)">
<summary>Finds all non-horizontal segments intersecting the stabbing line.</summary>
<param name="stabbingRayLeftPt">the left-hand origin of the stabbing line</param>
<returns>a List of {@link DepthSegments} intersecting the stabbing line</returns>
        </member>
<member name="M:topology.operation.buffer.SubgraphDepthLocater.findStabbedSegments(Coordinate,List,List)">
<summary>Finds all non-horizontal segments intersecting the stabbing line in the list of dirEdges.</summary>
<param name="stabbingRayLeftPt">the left-hand origin of the stabbing line</param>
<param name="stabbedSegments">the current list of {@link DepthSegments} intersecting the stabbing line</param>
        </member>
<member name="M:topology.operation.buffer.SubgraphDepthLocater.findStabbedSegments(Coordinate,DirectedEdge,List)">
<summary>Finds all non-horizontal segments intersecting the stabbing line in the input dirEdge.</summary>
<param name="stabbingRayLeftPt">the left-hand origin of the stabbing line</param>
<param name="stabbedSegments">the current list of {@link DepthSegments} intersecting the stabbing line</param>
        </member>
<member name="T:topology.operation.buffer.SubgraphDepthLocater.DepthSegment">
<remarks>A segment from a directed edge which has been assigned a depth value for its sides.</remarks>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.operation.buffer.SubgraphDepthLocater.DepthSegment.compareTo(Object) -->
<member name="M:topology.operation.buffer.SubgraphDepthLocater.DepthSegment.compareX(LineSegment,LineSegment)">
<summary>Compare two collinear segments for left-most ordering.</summary>
<param name="seg0">a segment to compare</param>
<param name="seg1">a segment to compare</param>
<returns></returns>
        </member>
<member name="T:topology.util.UniqueCoordinateArrayFilter">
<remarks>A {@link CoordinateFilter} that builds a set of <code>Coordinate</code>s. The set of coordinates contains no duplicate points.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.util.UniqueCoordinateArrayFilter.getCoordinates">
<summary>Returns the gathered <code>Coordinate</code>s.</summary>
<returns>the <code>Coordinate</code>s collected by this <code>CoordinateArrayFilter</code></returns>
        </member>
<member name="T:topology.linearref.LocationIndexedLine">
<remarks>Supports linear referencing along a linear {@link Geometry} using {@link LinearLocation}s as the index.</remarks>
        </member>
<member name="M:topology.linearref.LocationIndexedLine.#ctor(Geometry)">
<summary>Constructs an object which allows linear referencing along a given linear {@link Geometry}.</summary>
<param name="linearGeom">the linear geometry to reference along</param>
        </member>
<member name="M:topology.linearref.LocationIndexedLine.extractPoint(LinearLocation)">
<summary>Computes the {@link Coordinate} for the point on the line at the given index.</summary>
<param name="length">the index of the desired point</param>
<returns>the Coordinate at the given index</returns>
        </member>
<member name="M:topology.linearref.LocationIndexedLine.extractLine(LinearLocation,LinearLocation)">
<summary>Computes the {@link LineString} for the interval on the line between the given indices.</summary>
<param name="startIndex">the index of the start of the interval</param>
<param name="endIndex">the index of the end of the interval</param>
<returns>the linear interval between the indices</returns>
        </member>
<member name="M:topology.linearref.LocationIndexedLine.indexOf(Coordinate)">
	<summary>Computes the index for a given point on the line.</summary>
	<param name="pt">a point on the line</param>
	<returns>the index of the point</returns>
	<seealso cref="M:topology.linearref.LocationIndexedLine.project(topology.geom.Coordinate pt)"/>
</member>
<member name="M:topology.linearref.LocationIndexedLine.indicesOf(Geometry)">
<summary>Computes the indices for a subline of the line.</summary>
<param name="subLine">a subLine of the line</param>
<returns>a pair of indices for the start and end of the subline.</returns>
        </member>
<member name="M:topology.linearref.LocationIndexedLine.project(Coordinate)">
<summary>Computes the index for the closest point on the line to the given point.</summary>
<param name="pt">a point on the line</param>
<returns>the index of the point</returns>
        </member>
<member name="M:topology.linearref.LocationIndexedLine.getStartIndex">
<summary>Returns the index of the start of the line</summary>
<returns></returns>
        </member>
<member name="M:topology.linearref.LocationIndexedLine.getEndIndex">
<summary>Returns the index of the end of the line</summary>
<returns></returns>
        </member>
<member name="M:topology.linearref.LocationIndexedLine.isValidIndex(LinearLocation)">
<summary>Tests whether an index is in the valid index range for the line.</summary>
<param name="length">the index to test</param>
<returns><code>true</code> if the index is in the valid range</returns>
        </member>
<member name="M:topology.linearref.LocationIndexedLine.clampIndex(LinearLocation)">
<summary>Computes a valid index for this line by clamping the given index to the valid range of index values</summary>
<returns>a valid index value</returns>
        </member>
<member name="T:topology.operation.predicate.SegmentIntersectionTester">
<remarks>Tests if any line segments in two sets of CoordinateSequences intersect. Optimized for small geometry size. Short-circuited to return as soon an intersection is found.</remarks>
<version>1.7</version>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geomgraph.TopologyLocation -->
<member name="M:topology.geomgraph.TopologyLocation.#ctor(System.Int32,System.Int32,System.Int32)">
	<summary>Constructs a TopologyLocation specifying how points on, to the left of, and to the right of some GraphComponent relate to some Geometry.</summary>
	<seealso cref="T:topology.geom.Location"/>
</member>
<member name="M:topology.geomgraph.TopologyLocation.isNull">
<returns>true if all locations are NULL</returns>
        </member>
<member name="M:topology.geomgraph.TopologyLocation.isAnyNull">
<returns>true if any locations are NULL</returns>
        </member>
<member name="M:topology.geomgraph.TopologyLocation.merge(TopologyLocation)">
<summary>merge updates only the NULL attributes of this object with the attributes of another.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.noding.SegmentStringDissolver -->
<member name="M:topology.noding.SegmentStringDissolver.SegmentStringMerger.merge(SegmentString,SegmentString,System.Boolean)">
<summary>Updates the context data of a SegmentString when an identical (up to orientation) one is found during dissolving.</summary>
<param name="mergeTarget">the segment string to update</param>
<param name="ssToMerge">the segment string being dissolved</param>
<param name="isSameOrientation"><code>true</code> if the strings are in the same direction, <code>false</code> if they are opposite</param>
        </member>
<member name="M:topology.noding.SegmentStringDissolver.#ctor(SegmentStringMerger)">
<summary>Creates a dissolver with a user-defined merge strategy.</summary>
<param name="merger">the merging strategy to use</param>
        </member>
<member name="M:topology.noding.SegmentStringDissolver.#ctor">
<summary>Creates a dissolver with the default merging strategy.</summary>
        </member>
<member name="M:topology.noding.SegmentStringDissolver.dissolve(Collection)">
<summary>Dissolve all {@link SegmentString}s in the input {@link Collection}</summary>
<param name="segStrings"></param>
        </member>
<member name="M:topology.noding.SegmentStringDissolver.dissolve(SegmentString)">
<summary>Dissolve the given {@link SegmentString}.</summary>
<param name="segString">the string to dissolve</param>
        </member>
<member name="M:topology.noding.SegmentStringDissolver.getDissolved">
<summary>Gets the collection of dissolved (i.e.</summary>
<returns>the unique {@link SegmentString}s</returns>
        </member>
<member name="T:topology.noding.FastNodingValidator">
<remarks>Validates that a collection of {@link SegmentString}s is correctly noded. Indexing is used to improve performance. This class assumes that at least one round of noding has already been performed (which may still leave intersections, due to rounding issues). Does NOT check a-b-a collapse situations. Also does not check for endpt-interior vertex intersections. This should not be a problem, since the noders should be able to compute intersections between vertices correctly. User may either test the valid condition, or request that a {@link TopologyException} be thrown.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.noding.FastNodingValidator.isValid">
<summary>Checks for an intersection and reports if one is found.</summary>
<returns>true if the arrangement contains an interior intersection</returns>
        </member>
<member name="M:topology.noding.FastNodingValidator.getErrorMessage">
<summary>Returns an error message indicating the segments containing the intersection.</summary>
<returns>an error message documenting the intersection location</returns>
        </member>
<member name="M:topology.noding.FastNodingValidator.checkValid">
<summary>Checks for an intersection and throws a TopologyException if one is found.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.noding.snapround.MCIndexSnapRounder -->
<member name="M:topology.noding.snapround.MCIndexSnapRounder.findInteriorIntersections(Collection,LineIntersector)">
<summary>Computes all interior intersections in the collection of {@link SegmentString}s, and returns their @link Coordinate}s.</summary>
<returns>a list of Coordinates for the intersections</returns>
        </member>
<member name="M:topology.noding.snapround.MCIndexSnapRounder.computeIntersectionSnaps(Collection)">
<summary>Computes nodes introduced as a result of snapping segments to snap points (hot pixels)</summary>
        </member>
<member name="M:topology.noding.snapround.MCIndexSnapRounder.computeVertexSnaps(Collection)">
<summary>Computes nodes introduced as a result of snapping segments to vertices of other segments</summary>
<param name="segStrings">the list of segment strings to snap together</param>
        </member>
<member name="M:topology.noding.snapround.MCIndexSnapRounder.computeVertexSnaps(SegmentString)">
<summary>Performs a brute-force comparison of every segment in each {@link SegmentString}.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.planargraph.GraphComponent -->
<member name="M:topology.planargraph.GraphComponent.setVisited(Iterator,System.Boolean)">
<summary>Sets the Visited state for all {@link GraphComponent}s in an {@link Iterator}</summary>
<param name="i">the Iterator to scan</param>
<param name="visited">the state to set the visited flag to</param>
        </member>
<member name="M:topology.planargraph.GraphComponent.setMarked(Iterator,System.Boolean)">
<summary>Sets the Marked state for all {@link GraphComponent}s in an {@link Iterator}</summary>
<param name="i">the Iterator to scan</param>
<param name="marked">the state to set the Marked flag to</param>
        </member>
<member name="M:topology.planargraph.GraphComponent.getComponentWithVisitedState(Iterator,System.Boolean)">
<summary>Finds the first {@link GraphComponent} in a {@link Iterator} set which has the specified visited state.</summary>
<param name="i">an Iterator of GraphComponents</param>
<param name="visitedState">the visited state to test</param>
<returns>the first component found, or <code>null</code> if none found</returns>
        </member>
<member name="M:topology.planargraph.GraphComponent.isVisited">
<summary>Tests if a component has been visited during the course of a graph algorithm</summary>
<returns><code>true</code> if the component has been visited</returns>
        </member>
<member name="M:topology.planargraph.GraphComponent.setVisited(System.Boolean)">
<summary>Sets the visited flag for this component.</summary>
<param name="isVisited">the desired value of the visited flag</param>
        </member>
<member name="M:topology.planargraph.GraphComponent.isMarked">
<summary>Tests if a component has been marked at some point during the processing involving this graph.</summary>
<returns><code>true</code> if the component has been marked</returns>
        </member>
<member name="M:topology.planargraph.GraphComponent.setMarked(System.Boolean)">
<summary>Sets the marked flag for this component.</summary>
<param name="isMarked">the desired value of the marked flag</param>
        </member>
<member name="M:topology.planargraph.GraphComponent.setContext(Object)">
<summary>Sets the user-defined data for this component.</summary>
<param name="data">an Object containing user-defined data</param>
        </member>
<member name="M:topology.planargraph.GraphComponent.getContext">
<summary>Gets the user-defined data for this component.</summary>
<returns>the user-defined data</returns>
        </member>
<member name="M:topology.planargraph.GraphComponent.setData(Object)">
<summary>Sets the user-defined data for this component.</summary>
<param name="data">an Object containing user-defined data</param>
        </member>
<member name="M:topology.planargraph.GraphComponent.getData">
<summary>Gets the user-defined data for this component.</summary>
<returns>the user-defined data</returns>
        </member>
<member name="M:topology.planargraph.GraphComponent.isRemoved">
<summary>Tests whether this component has been removed from its containing graph</summary>
<returns><code>true</code> if this component is removed</returns>
        </member>
<member name="T:topology.simplify.TaggedLineStringSimplifier">
<remarks>Simplifies a TaggedLineString, preserving topology (in the sense that no new intersections are introduced). Uses the recursive Douglas-Peucker algorithm.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="M:topology.simplify.TaggedLineStringSimplifier.setDistanceTolerance(System.Double)">
<summary>Sets the distance tolerance for the simplification.</summary>
<param name="distanceTolerance">the approximation tolerance to use</param>
        </member>
<member name="F:topology.simplify.TaggedLineStringSimplifier.validSectionIndex">
<summary>Index of section to be tested for flattening - reusable</summary>
        </member>
<member name="M:topology.simplify.TaggedLineStringSimplifier.isInLineSection(TaggedLineString,System.Int32[],TaggedLineSegment)">
<summary>Tests whether a segment is in a section of a TaggedLineString</summary>
<param name="line"></param>
<param name="sectionIndex"></param>
<param name="seg"></param>
<returns></returns>
        </member>
<member name="M:topology.simplify.TaggedLineStringSimplifier.remove(TaggedLineString,System.Int32,System.Int32)">
<summary>Remove the segs in the section of the line</summary>
<param name="line"></param>
<param name="pts"></param>
<param name="sectionStartIndex"></param>
<param name="sectionEndIndex"></param>
        </member>
<member name="T:topology.index.quadtree.Node">
<remarks>Represents a node of a {@link Quadtree}.  Nodes contain items which have a spatial extent corresponding to the node's position in the quadtree.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.quadtree.Node.getNode(Envelope)">
<summary>Returns the subquad containing the envelope.</summary>
        </member>
<member name="M:topology.index.quadtree.Node.find(Envelope)">
<summary>Returns the smallest <i>existing</i> node containing the envelope.</summary>
        </member>
<member name="M:topology.index.quadtree.Node.getSubnode(System.Int32)">
<summary>get the subquad for the index.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.index.SpatialIndex -->
<member name="M:topology.index.SpatialIndex.insert(Envelope,Object)">
<summary>Adds a spatial item with an extent specified by the given {@link Envelope} to the index</summary>
        </member>
<member name="M:topology.index.SpatialIndex.query(Envelope)">
<summary>Queries the index for all items whose extents intersect the given search {@link Envelope} Note that some kinds of indexes may also return objects which do not in fact intersect the query envelope.</summary>
<param name="searchEnv">the envelope to query for</param>
<returns>a list of the items found by the query</returns>
        </member>
<member name="M:topology.index.SpatialIndex.query(Envelope,ItemVisitor)">
<summary>Queries the index for all items whose extents intersect the given search {@link Envelope}, and applies an {@link ItemVisitor} to them.</summary>
<param name="searchEnv">the envelope to query for</param>
<param name="visitor">a visitor object to apply to the items found</param>
        </member>
<member name="M:topology.index.SpatialIndex.remove(Envelope,Object)">
<summary>Removes a single item from the tree.</summary>
<param name="itemEnv">the Envelope of the item to remove</param>
<param name="item">the item to remove</param>
<returns><code>true</code> if the item was found</returns>
        </member>
<member name="T:topology.noding.IntersectionAdder">
<remarks>Computes the intersections between two line segments in {@link SegmentString}s and adds them to each string. The {@link SegmentIntersector} is passed to a {@link Noder}. The {@link addIntersections} method is called whenever the {@link Noder} detects that two SegmentStrings <i>might</i> intersect. This class is an example of the <i>Strategy</i> pattern.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.noding.IntersectionAdder.hasIntersection">
<summary>These variables keep track of what types of intersections were found during ALL edges that have been intersected.</summary>
        </member>
<member name="M:topology.noding.IntersectionAdder.getProperIntersectionPoint">
<returns>the proper intersection point, or <code>null</code> if none was found</returns>
        </member>
<member name="M:topology.noding.IntersectionAdder.hasProperIntersection">
<summary>A proper intersection is an intersection which is interior to at least two line segments.</summary>
        </member>
<member name="M:topology.noding.IntersectionAdder.hasProperInteriorIntersection">
<summary>A proper interior intersection is a proper intersection which is <b>not</b> contained in the set of boundary nodes set for this SegmentIntersector.</summary>
        </member>
<member name="M:topology.noding.IntersectionAdder.hasInteriorIntersection">
<summary>An interior intersection is an intersection which is in the interior of some segment.</summary>
        </member>
<member name="M:topology.noding.IntersectionAdder.isTrivialIntersection(SegmentString,System.Int32,SegmentString,System.Int32)">
<summary>A trivial intersection is an apparent self-intersection which in fact is simply the point shared by adjacent line segments.</summary>
        </member>
<member name="M:topology.noding.IntersectionAdder.processIntersections(SegmentString,System.Int32,SegmentString,System.Int32)">
<summary>This method is called by clients of the {@link SegmentIntersector} class to process intersections for two segments of the {@link SegmentStrings} being intersected.</summary>
        </member>
<member name="M:topology.noding.IntersectionAdder.isDone">
<summary>Always process all intersections</summary>
<returns>false always</returns>
        </member>
<member name="T:topology.io.OutStream">
<remarks>A interface for classes providing an output stream of bytes. This interface is similar to the Java {@link OutputStream}, but with a narrower interface to make it easier to implement.</remarks>
        </member>
<member name="T:topology.geomgraph.EdgeEndStar">
<remarks>A EdgeEndStar is an ordered list of EdgeEnds around a node. They are maintained in CCW order (starting with the positive x-axis) around the node for efficient lookup and topology building.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.geomgraph.EdgeEndStar.edgeMap">
<summary>A map which maintains the edges in sorted order around the node</summary>
        </member>
<member name="F:topology.geomgraph.EdgeEndStar.edgeList">
<summary>A list of all outgoing edges in the result, in CCW order</summary>
        </member>
<member name="F:topology.geomgraph.EdgeEndStar.ptInAreaLocation">
<summary>The location of the point for this star in Geometry i Areas</summary>
        </member>
<member name="M:topology.geomgraph.EdgeEndStar.insert(EdgeEnd)">
<summary>Insert a EdgeEnd into this EdgeEndStar</summary>
        </member>
<member name="M:topology.geomgraph.EdgeEndStar.insertEdgeEnd(EdgeEnd,Object)">
<summary>Insert an EdgeEnd into the map, and clear the edgeList cache, since the list of edges has now changed</summary>
        </member>
<member name="M:topology.geomgraph.EdgeEndStar.getCoordinate">
<returns>the coordinate for the node this star is based at</returns>
        </member>
<member name="M:topology.geomgraph.EdgeEndStar.iterator">
<summary>Iterator access to the ordered list of edges is optimized by copying the map collection to a list.</summary>
        </member>
<member name="T:topology.index.chain.MonotoneChainSelectAction">
<remarks>The action for the internal iterator for performing envelope select queries on a MonotoneChain</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.chain.MonotoneChainSelectAction.select(MonotoneChain,System.Int32)">
<summary>This function can be overridden if the original chain is needed</summary>
        </member>
<member name="M:topology.index.chain.MonotoneChainSelectAction.select(LineSegment)">
<summary>This is a convenience function which can be overridden to obtain the actual line segment which is selected</summary>
<param name="seg"></param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geomgraph.index.MonotoneChainEdge -->
<member name="T:topology.io.ByteOrderDataInStream">
<remarks>Allows reading a stream of Java primitive datatypes from an underlying {@link InStream}, with the representation being in either common byte ordering.</remarks>
        </member>
<member name="M:topology.io.ByteOrderDataInStream.setInStream(InStream)">
<summary>Allows a single ByteOrderDataInStream to be reused on multiple InStreams.</summary>
<param name="stream"></param>
        </member>
<member name="M:topology.io.ByteOrderDataInStream.readByte">
<returns></returns>
        </member>
<member name="T:topology.geom.DefaultCoordinateSequence">
<remarks>The CoordinateSequence implementation that Geometries use by default. In this implementation, Coordinates returned by #toArray and #get are live -- parties that change them are actually changing the DefaultCoordinateSequence's underlying data.</remarks>
<version>1.7</version>
<obsolete>no longer used</obsolete>
        </member>
<member name="M:topology.geom.DefaultCoordinateSequence.#ctor(Coordinate[])">
<summary>Constructs a DefaultCoordinateSequence based on the given array (the array is not copied).</summary>
<param name="coordinates">the coordinate array that will be referenced.</param>
        </member>
<member name="M:topology.geom.DefaultCoordinateSequence.#ctor(CoordinateSequence)">
<summary>Constructs a DefaultCoordinateSequence based on the given array (the array is not copied).</summary>
<param name="coordinates">the coordinate array that will be referenced.</param>
        </member>
<member name="M:topology.geom.DefaultCoordinateSequence.#ctor(System.Int32)">
<summary>Constructs a sequence of a given size, populated with new {@link Coordinate}s.</summary>
<param name="size">the size of the sequence to create</param>
        </member>
<member name="M:topology.geom.DefaultCoordinateSequence.getDimension">
	<seealso cref="M:topology.geom.CoordinateSequence.getDimension"/>
</member>
<member name="M:topology.geom.DefaultCoordinateSequence.getCoordinate(System.Int32)">
<summary>Get the Coordinate with index i.</summary>
<param name="i">the index of the coordinate</param>
<returns>the requested Coordinate instance</returns>
        </member>
<member name="M:topology.geom.DefaultCoordinateSequence.getCoordinateCopy(System.Int32)">
<summary>Get a copy of the Coordinate with index i.</summary>
<param name="i">the index of the coordinate</param>
<returns>a copy of the requested Coordinate</returns>
        </member>
<member name="M:topology.geom.DefaultCoordinateSequence.getCoordinate(System.Int32,Coordinate)">
	<seealso cref="M:topology.geom.CoordinateSequence.getX(System.Int32 index)"/>
</member>
<member name="M:topology.geom.DefaultCoordinateSequence.getX(System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getX(System.Int32 index)"/>
</member>
<member name="M:topology.geom.DefaultCoordinateSequence.getY(System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getY(System.Int32 index)"/>
</member>
<member name="M:topology.geom.DefaultCoordinateSequence.getOrdinate(System.Int32,System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getOrdinate(System.Int32 index,System.Int32 ordinateIndex)"/>
</member>
<member name="M:topology.geom.DefaultCoordinateSequence.setOrdinate(System.Int32,System.Int32,System.Double)">
	<seealso cref="M:topology.geom.CoordinateSequence.setOrdinate(System.Int32 index,System.Int32 ordinateIndex,System.Double value)"/>
</member>
<member name="M:topology.geom.DefaultCoordinateSequence.clone">
<summary>Creates a deep copy of the Object</summary>
<returns>The deep copy</returns>
        </member>
<member name="M:topology.geom.DefaultCoordinateSequence.size">
<summary>Returns the size of the coordinate sequence</summary>
<returns>the number of coordinates</returns>
        </member>
<member name="M:topology.geom.DefaultCoordinateSequence.toCoordinateArray">
<summary>This method exposes the internal Array of Coordinate Objects</summary>
<returns>the Coordinate[] array.</returns>
        </member>
<member name="M:topology.geom.DefaultCoordinateSequence.toString">
<summary>Returns the string Representation of the coordinate array</summary>
<returns>The string</returns>
        </member>
<member name="T:topology.noding.SegmentNodeList">
<remarks>A list of the {@link SegmentNode}s present along a noded {@link SegmentString}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.noding.SegmentNodeList.add(Coordinate,System.Int32)">
<summary>Adds an intersection into the list, if it isn't already there.</summary>
<returns>the SegmentIntersection found or added</returns>
        </member>
<member name="M:topology.noding.SegmentNodeList.iterator">
<summary>returns an iterator of SegmentNodes</summary>
        </member>
<member name="M:topology.noding.SegmentNodeList.addEndpoints">
<summary>Adds nodes for the first and last points of the edge</summary>
        </member>
<member name="M:topology.noding.SegmentNodeList.addCollapsedNodes">
<summary>Adds nodes for any collapsed edge pairs.</summary>
        </member>
<member name="M:topology.noding.SegmentNodeList.findCollapsesFromExistingVertices(List)">
<summary>Adds nodes for any collapsed edge pairs which are pre-existing in the vertex list.</summary>
        </member>
<member name="M:topology.noding.SegmentNodeList.findCollapsesFromInsertedNodes(List)">
<summary>Adds nodes for any collapsed edge pairs caused by inserted nodes Collapsed edge pairs occur when the same coordinate is inserted as a node both before and after an existing edge vertex.</summary>
        </member>
<member name="M:topology.noding.SegmentNodeList.addSplitEdges(Collection)">
<summary>Creates new edges for all the edges that the intersections in this list split the parent edge into.</summary>
        </member>
<member name="M:topology.noding.SegmentNodeList.checkSplitEdgesCorrectness(List)">
<summary>Checks the correctness of the set of split edges corresponding to this edge</summary>
<param name="splitEdges">the split edges for this edge (in order)</param>
        </member>
<member name="M:topology.noding.SegmentNodeList.createSplitEdge(SegmentNode,SegmentNode)">
<summary>Create a new "split edge" with the section of points between (and including) the two intersections.</summary>
        </member>
<member name="M:topology.noding.NodeVertexIterator.remove">
<summary>Not implemented.</summary>
        </member>
<member name="T:topology.operation.valid.QuadtreeNestedRingTester">
<remarks>Tests whether any of a set of {@link LinearRing}s are nested inside another ring in the set, using a {@link Quadtree} index to speed up the comparisons.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.geomgraph.index.MonotoneChain">
<version>1.7</version>
        </member>
<member name="T:topology.algorithm.NotRepresentableException">
	<remarks>Indicates that a {@link HCoordinate} has been computed which is not representable on the Cartesian plane.</remarks>
	<version>1.7</version>
	<seealso cref="T:topology.algorithm.HCoordinate"/>
</member>
<member name="T:topology.noding.Noder">
<remarks>Computes all intersections between segments in a set of {@link SegmentString}s. Intersections found are represented as {@link SegmentNode}s and added to the {@link SegmentString}s in which they occur. As a final step in the noding a new set of segment strings split at the nodes may be returned.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.noding.Noder.computeNodes(Collection)">
<summary>Computes the noding for a collection of {@link SegmentString}s.</summary>
<param name="segStrings">a collection of {@link SegmentString}s to node</param>
        </member>
<member name="M:topology.noding.Noder.getNodedSubstrings">
<summary>Returns a {@link Collection} of fully noded {@link SegmentStrings}.</summary>
<returns>a Collection of SegmentStrings</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.polygonize.PolygonizeGraph -->
<member name="M:topology.operation.polygonize.PolygonizeGraph.deleteAllEdges(Node)">
<summary>Deletes all edges at a node</summary>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeGraph.#ctor(GeometryFactory)">
<summary>Create a new polygonization graph.</summary>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeGraph.addEdge(LineString)">
<summary>Add a {@link LineString} forming an edge of the polygon graph.</summary>
<param name="line">the line to add</param>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeGraph.convertMaximalToMinimalEdgeRings(List)">
<summary>Convert the maximal edge rings found by the initial graph traversal into the minimal edge rings required by JTS polygon topology rules.</summary>
<param name="ringEdges">the list of start edges for the edgeRings to convert.</param>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeGraph.findIntersectionNodes(PolygonizeDirectedEdge,System.Int64)">
<summary>Finds all nodes in a maximal edgering which are self-intersection nodes</summary>
<param name="startDE"></param>
<param name="label"></param>
<returns>the list of intersection nodes found, or <code>null</code> if no intersection nodes were found</returns>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeGraph.getEdgeRings">
<summary>Computes the EdgeRings formed by the edges in this graph.</summary>
<returns>a list of the {@link EdgeRing}s found by the polygonization process.</returns>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeGraph.findLabeledEdgeRings(Collection)">
<param name="dirEdges">a List of the DirectedEdges in the graph</param>
<returns>a List of DirectedEdges, one for each edge ring found</returns>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeGraph.deleteCutEdges">
<summary>Finds and removes all cut edges from the graph.</summary>
<returns>a list of the {@link LineString}s forming the removed cut edges</returns>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeGraph.computeNextCCWEdges(Node,System.Int64)">
<summary>Computes the next edge pointers going CCW around the given node, for the given edgering label.</summary>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeGraph.findDirEdgesInRing(PolygonizeDirectedEdge)">
<summary>Traverse a ring of DirectedEdges, accumulating them into a list.</summary>
<param name="startDE">the DirectedEdge to start traversing at</param>
<returns>a List of DirectedEdges that form a ring</returns>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeGraph.deleteDangles">
<summary>Marks all edges from the graph which are "dangles".</summary>
<returns>a List containing the {@link LineStrings} that formed dangles</returns>
        </member>
<member name="T:topology.io.ParseException">
<remarks>Thrown by a <code>WKTReader</code> when a parsing problem occurs.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.io.ParseException.#ctor(String)">
<summary>Creates a <code>ParseException</code> with the given detail message.</summary>
<param name="message">a description of this <code>ParseException</code></param>
        </member>
<member name="M:topology.io.ParseException.#ctor(Exception)">
<summary>Creates a <code>ParseException</code> with <code>e</code>s detail message.</summary>
<param name="e">an exception that occurred while a <code>WKTReader</code> was parsing a Well-known Text string</param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.algorithm.ConvexHull -->
<member name="M:topology.algorithm.ConvexHull.#ctor(Geometry)">
<summary>Create a new convex hull construction for the input {@link Geometry}.</summary>
        </member>
<member name="M:topology.algorithm.ConvexHull.#ctor(Coordinate[],GeometryFactory)">
<summary>Create a new convex hull construction for the input {@link Coordinate} array.</summary>
        </member>
<member name="M:topology.algorithm.ConvexHull.getConvexHull">
<summary>Returns a {@link Geometry} that represents the convex hull of the input geometry.</summary>
<returns>if the convex hull contains 3 or more points, a {@link Polygon}; 2 points, a {@link LineString}; 1 point, a {@link Point}; 0 points, an empty {@link GeometryCollection}.</returns>
        </member>
<member name="M:topology.algorithm.ConvexHull.toCoordinateArray(Stack)">
<summary>An alternative to Stack.toArray, which is not present in earlier versions of Java.</summary>
        </member>
<member name="M:topology.algorithm.ConvexHull.reduce(Coordinate[])">
<summary>Uses a heuristic to reduce the number of points scanned to compute the hull.</summary>
<param name="pts"></param>
<returns></returns>
        </member>
<member name="M:topology.algorithm.ConvexHull.isBetween(Coordinate,Coordinate,Coordinate)">
<returns>whether the three coordinates are collinear and c2 lies between c1 and c3 inclusive</returns>
        </member>
<member name="M:topology.algorithm.ConvexHull.lineOrPolygon(Coordinate[])">
<param name="vertices">the vertices of a linear ring, which may or may not be flattened (i.e. vertices collinear)</param>
<returns>a 2-vertex <code>LineString</code> if the vertices are collinear; otherwise, a <code>Polygon</code> with unnecessary (collinear) vertices removed</returns>
        </member>
<member name="M:topology.algorithm.ConvexHull.cleanRing(Coordinate[])">
<param name="vertices">the vertices of a linear ring, which may or may not be flattened (i.e. vertices collinear)</param>
<returns>the coordinates with unnecessary (collinear) vertices removed</returns>
        </member>
<member name="T:topology.algorithm.ConvexHull.RadialComparator">
<remarks>Compares {@link Coordinate}s for their angle and distance relative to an origin.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="M:topology.algorithm.ConvexHull.RadialComparator.polarCompare(Coordinate,Coordinate,Coordinate)">
<summary>Given two points p and q compare them with respect to their radial ordering about point o.</summary>
<param name="o">the origin</param>
<param name="p">a point</param>
<param name="q">another point</param>
<returns>-1, 0 or 1 depending on whether p is less than, equal to or greater than q</returns>
        </member>
<member name="T:topology.algorithm.CentroidLine">
<remarks>Computes the centroid of a linear geometry. <h2>Algorithm</h2> Compute the average of the midpoints of all line segments weighted by the segment length.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.algorithm.CentroidLine.add(Geometry)">
<summary>Adds the linestring(s) defined by a Geometry to the centroid total.</summary>
<param name="geom">the geometry to add</param>
        </member>
<member name="M:topology.algorithm.CentroidLine.add(Coordinate[])">
<summary>Adds the length defined by an array of coordinates.</summary>
<param name="pts">an array of {@link Coordinate}s</param>
        </member>
<member name="T:topology.geomgraph.EdgeRing">
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.EdgeRing.computeRing">
<summary>Compute a LinearRing from the point list previously collected.</summary>
        </member>
<member name="M:topology.geomgraph.EdgeRing.getEdges">
<summary>Returns the list of DirectedEdges that make up this EdgeRing</summary>
        </member>
<member name="M:topology.geomgraph.EdgeRing.computePoints(DirectedEdge)">
<summary>Collect all the points from the DirectedEdges of this ring into a contiguous list</summary>
        </member>
<member name="M:topology.geomgraph.EdgeRing.mergeLabel(Label,System.Int32)">
<summary>Merge the RHS label from a DirectedEdge into the label for this EdgeRing.</summary>
        </member>
<member name="M:topology.geomgraph.EdgeRing.containsPoint(Coordinate)">
<summary>This method will cause the ring to be computed.</summary>
        </member>
<member name="T:topology.index.quadtree.IntervalSize">
<remarks>Provides a test for whether an interval is so small it should be considered as zero for the purposes of inserting it into a binary tree. The reason this check is necessary is that round-off error can cause the algorithm used to subdivide an interval to fail, by computing a midpoint value which does not lie strictly between the endpoints.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.index.quadtree.IntervalSize.MIN_BINARY_EXPONENT">
<summary>This value is chosen to be a few powers of 2 less than the number of bits available in the double representation (i.e.</summary>
        </member>
<member name="M:topology.index.quadtree.IntervalSize.isZeroWidth(System.Double,System.Double)">
<summary>Computes whether the interval [min, max] is effectively zero width.</summary>
        </member>
<member name="T:topology.noding.SegmentIntersector">
<remarks>Computes the intersections between two line segments in {@link SegmentString}s and adds them to each string. The {@link SegmentIntersector} is passed to a {@link Noder}. The {@link addIntersections} method is called whenever the {@link Noder} detects that two SegmentStrings <i>might</i> intersect. This class is an example of the <i>Strategy</i> pattern.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.noding.SegmentIntersector.processIntersections(SegmentString,System.Int32,SegmentString,System.Int32)">
<summary>This method is called by clients of the {@link SegmentIntersector} interface to process intersections for two segments of the {@link SegmentStrings} being intersected.</summary>
        </member>
<member name="T:topology.index.sweepline.SweepLineOverlapAction">
<remarks>An action taken when a {@link SweepLineIndex} detects that two {@link SweepLineInterval}s overlap</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.operation.overlay.snap.SnapIfNeededOverlayOp">
<remarks>Performs an overlay operation using snapping and enhanced precision to improve the robustness of the result. This class only uses snapping if an error is detected when running the standard JTS overlay code. Errors detected include thrown exceptions (in particular, {@link TopologyException}) and invalid overlay computations.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="T:topology.index.sweepline.SweepLineInterval">
<version>1.7</version>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.IsSimpleOp -->
<member name="M:topology.operation.IsSimpleOp.#ctor">
<summary>Creates a simplicity checker using the default SFS Mod-2 Boundary Node Rule</summary>
<obsolete>use IsSimpleOp(Geometry)</obsolete>
        </member>
<member name="M:topology.operation.IsSimpleOp.#ctor(Geometry)">
<summary>Creates a simplicity checker using the default SFS Mod-2 Boundary Node Rule</summary>
<param name="geom">the geometry to test</param>
        </member>
<member name="M:topology.operation.IsSimpleOp.#ctor(Geometry,BoundaryNodeRule)">
<summary>Creates a simplicity checker using a given {@link BoundaryNodeRule}</summary>
<param name="geom">the geometry to test</param>
<param name="boundaryNodeRule">the rule to use.</param>
        </member>
<member name="M:topology.operation.IsSimpleOp.isSimple">
<summary>Tests whether the geometry is simple.</summary>
<returns>true if the geometry is simple</returns>
        </member>
<member name="M:topology.operation.IsSimpleOp.getNonSimpleLocation">
<summary>Gets a coordinate for the location where the geometry fails to be simple.</summary>
<returns>a coordinate for the location of the non-boundary self-intersection</returns>
<returns>null if the geometry is simple</returns>
        </member>
<member name="M:topology.operation.IsSimpleOp.isSimple(LineString)">
<summary>Reports whether a {@link LineString} is simple.</summary>
<param name="geom">the lineal geometry to test</param>
<returns>true if the geometry is simple</returns>
<obsolete>use isSimple()</obsolete>
        </member>
<member name="M:topology.operation.IsSimpleOp.isSimple(MultiLineString)">
<summary>Reports whether a {@link MultiLineString} geometry is simple.</summary>
<param name="geom">the lineal geometry to test</param>
<returns>true if the geometry is simple</returns>
<obsolete>use isSimple()</obsolete>
        </member>
<member name="M:topology.operation.IsSimpleOp.isSimple(MultiPoint)">
<summary>A MultiPoint is simple iff it has no repeated points</summary>
<obsolete>use isSimple()</obsolete>
        </member>
<member name="M:topology.operation.IsSimpleOp.hasNonEndpointIntersection(GeometryGraph)">
<summary>For all edges, check if there are any intersections which are NOT at an endpoint.</summary>
        </member>
<member name="M:topology.operation.IsSimpleOp.hasClosedEndpointIntersection(GeometryGraph)">
<summary>Tests that no edge intersection is the endpoint of a closed line.</summary>
        </member>
<member name="M:topology.operation.IsSimpleOp.addEndpoint(Map,Coordinate,System.Boolean)">
<summary>Add an endpoint to the map, creating an entry for it if none exists</summary>
        </member>
<member name="T:topology.simplify.LineSegmentIndex">
<remarks>An spatial index on a set of {@link LineSegment}s. Supports adding and removing items.</remarks>
<author>Martin Davis</author>
        </member>
<member name="T:topology.simplify.LineSegmentVisitor">
<remarks>ItemVisitor subclass to reduce volume of query results.</remarks>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.CoordinateSequenceComparator -->
<member name="M:topology.geom.CoordinateSequenceComparator.compare(System.Double,System.Double)">
<summary>Compare two <code>double</code>s, allowing for NaN values.</summary>
<param name="a">a <code>double</code></param>
<param name="b">a <code>double</code></param>
<returns>-1, 0, or 1 depending on whether a is less than, equal to or greater than b</returns>
        </member>
<member name="F:topology.geom.CoordinateSequenceComparator.dimensionLimit">
<summary>The number of dimensions to test</summary>
        </member>
<member name="M:topology.geom.CoordinateSequenceComparator.#ctor">
<summary>Creates a comparator which will test all dimensions.</summary>
        </member>
<member name="M:topology.geom.CoordinateSequenceComparator.#ctor(System.Int32)">
<summary>Creates a comparator which will test only the specified number of dimensions.</summary>
<param name="dimensionLimit">the number of dimensions to test</param>
        </member>
<member name="M:topology.geom.CoordinateSequenceComparator.compare(Object,Object)">
<summary>Compares two {@link CoordinateSequence}s for relative order.</summary>
<param name="o1">a {@link CoordinateSequence}</param>
<param name="o2">a {@link CoordinateSequence}</param>
<returns>-1, 0, or 1 depending on whether o1 is less than, equal to, or greater than o2</returns>
        </member>
<member name="M:topology.geom.CoordinateSequenceComparator.compareCoordinate(CoordinateSequence,CoordinateSequence,System.Int32,System.Int32)">
<summary>Compares the same coordinate of two {@link CoordinateSequence}s along the given number of dimensions.</summary>
<param name="s1">a {@link CoordinateSequence}</param>
<param name="s2">a {@link CoordinateSequence}</param>
<param name="i">the index of the coordinate to test</param>
<param name="dimension">the number of dimensiosn to test</param>
<returns>-1, 0, or 1 depending on whether s1[i] is less than, equal to, or greater than s2[i]</returns>
        </member>
<member name="T:topology.geom.GeometryCollectionIterator">
<remarks>Iterates over all {@link Geometry}s in a {@link GeometryCollection}. . Implements a pre-order depth-first traversal of the <code>GeometryCollection</code> (which may be nested). The original <code>GeometryCollection</code> is returned as well (as the first object), as are all sub-collections. It is simple to ignore the <code>GeometryCollection</code> objects if they are not needed.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.geom.GeometryCollectionIterator.parent">
<summary>The <code>GeometryCollection</code> being iterated over.</summary>
        </member>
<member name="F:topology.geom.GeometryCollectionIterator.atStart">
<summary>Indicates whether or not the first element (the <code>GeometryCollection</code> ) has been returned.</summary>
        </member>
<member name="F:topology.geom.GeometryCollectionIterator.max">
<summary>The number of <code>Geometry</code>s in the the <code>GeometryCollection</code> .</summary>
        </member>
<member name="F:topology.geom.GeometryCollectionIterator.index">
<summary>The index of the <code>Geometry</code> that will be returned when <code>next</code> is called.</summary>
        </member>
<member name="F:topology.geom.GeometryCollectionIterator.subcollectionIterator">
<summary>The iterator over a nested <code>GeometryCollection</code>, or <code>null</code> if this <code>GeometryCollectionIterator</code> is not currently iterating over a nested <code>GeometryCollection</code>.</summary>
        </member>
<member name="M:topology.geom.GeometryCollectionIterator.#ctor(Geometry)">
<summary>Constructs an iterator over the given <code>GeometryCollection</code>.</summary>
<param name="parent">the collection over which to iterate; also, the first element returned by the iterator.</param>
        </member>
<member name="M:topology.geom.GeometryCollectionIterator.remove">
<summary>Not implemented.</summary>
        </member>
<member name="T:topology.index.ArrayListVisitor">
<version>1.7</version>
        </member>
<member name="T:topology.geom.TopologyException">
<remarks>Indicates an invalid or inconsistent topological situation encountered during processing</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.operation.relate.RelateNode">
<remarks>Represents a node in the topological graph used to compute spatial relationships.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.relate.RelateNode.computeIM(IntersectionMatrix)">
<summary>Update the IM with the contribution for this component.</summary>
        </member>
<member name="M:topology.operation.relate.RelateNode.updateIMFromEdges(IntersectionMatrix)">
<summary>Update the IM with the contribution for the EdgeEnds incident on this node.</summary>
        </member>
<member name="T:topology.util.CoordinateArrayFilter">
<remarks>A {@link CoordinateFilter} that creates an array containing every coordinate in a {@link Geometry}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.util.CoordinateArrayFilter.#ctor(System.Int32)">
<summary>Constructs a <code>CoordinateArrayFilter</code>.</summary>
<param name="size">the number of points that the <code>CoordinateArrayFilter</code> will collect</param>
        </member>
<member name="M:topology.util.CoordinateArrayFilter.getCoordinates">
<summary>Returns the gathered <code>Coordinate</code>s.</summary>
<returns>the <code>Coordinate</code>s collected by this <code>CoordinateArrayFilter</code></returns>
        </member>
<member name="T:topology.operation.buffer.OffsetCurveBuilder">
<remarks>Computes the raw offset curve for a single {@link Geometry} component (ring, line or point). A raw offset curve line is not noded - it may contain self-intersections (and usually will). The final buffer polygon is computed by forming a topological graph of all the noded raw curves and tracing outside contours. The points in the raw curve are rounded to the required precision model.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.operation.buffer.OffsetCurveBuilder.DEFAULT_QUADRANT_SEGMENTS">
<summary>The default number of facets into which to divide a fillet of 90 degrees.</summary>
        </member>
<member name="F:topology.operation.buffer.OffsetCurveBuilder.filletAngleQuantum">
<summary>The angle quantum with which to approximate a fillet curve (based on the input # of quadrant segments)</summary>
        </member>
<member name="F:topology.operation.buffer.OffsetCurveBuilder.maxCurveSegmentError">
<summary>the max error of approximation between a quad segment and the true fillet curve</summary>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveBuilder.getLineCurve(Coordinate[],System.Double)">
<summary>This method handles single points as well as lines.</summary>
<returns>a List of Coordinate[]</returns>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveBuilder.getRingCurve(Coordinate[],System.Int32,System.Double)">
<summary>This method handles the degenerate cases of single points and lines, as well as rings.</summary>
<returns>a List of Coordinate[]</returns>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveBuilder.addLastSegment">
<summary>Add last offset point</summary>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveBuilder.computeOffsetSegment(LineSegment,System.Int32,System.Double,LineSegment)">
<summary>Compute an offset segment for an input segment on a given side and at a given distance.</summary>
<param name="seg">the segment to offset</param>
<param name="side">the side of the segment ({@link Position}) the offset lies on</param>
<param name="distance">the offset distance</param>
<param name="offset">the points computed for the offset segment</param>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveBuilder.addLineEndCap(Coordinate,Coordinate)">
<summary>Add an end cap around point p1, terminating a line segment coming from p0</summary>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveBuilder.addFillet(Coordinate,Coordinate,Coordinate,System.Int32,System.Double)">
<param name="p">base point of curve</param>
<param name="p0">start point of fillet curve</param>
<param name="p1">endpoint of fillet curve</param>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveBuilder.addFillet(Coordinate,System.Double,System.Double,System.Int32,System.Double)">
<summary>Adds points for a fillet.</summary>
<param name="direction">is -1 for a CW angle, 1 for a CCW angle</param>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveBuilder.addCircle(Coordinate,System.Double)">
<summary>Adds a CW circle around a point</summary>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveBuilder.addSquare(Coordinate,System.Double)">
<summary>Adds a CW square around a point</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.index.strtree.STRtree -->
<member name="M:topology.index.strtree.STRtree.createParentBoundables(List,System.Int32)">
<summary>Creates the parent level for the given child level.</summary>
        </member>
<member name="M:topology.index.strtree.STRtree.verticalSlices(List,System.Int32)">
<param name="childBoundables">Must be sorted by the x-value of the envelope midpoints</param>
        </member>
<member name="M:topology.index.strtree.STRtree.#ctor">
<summary>Constructs an STRtree with the default node capacity.</summary>
        </member>
<member name="M:topology.index.strtree.STRtree.#ctor(System.Int32)">
<summary>Constructs an STRtree with the given maximum number of child nodes that a node may have</summary>
        </member>
<member name="M:topology.index.strtree.STRtree.insert(Envelope,Object)">
<summary>Inserts an item having the given bounds into the tree.</summary>
        </member>
<member name="M:topology.index.strtree.STRtree.query(Envelope)">
<summary>Returns items whose bounds intersect the given envelope.</summary>
        </member>
<member name="M:topology.index.strtree.STRtree.query(Envelope,ItemVisitor)">
<summary>Returns items whose bounds intersect the given envelope.</summary>
        </member>
<member name="M:topology.index.strtree.STRtree.remove(Envelope,Object)">
<summary>Removes a single item from the tree.</summary>
<param name="itemEnv">the Envelope of the item to remove</param>
<param name="item">the item to remove</param>
<returns><code>true</code> if the item was found</returns>
        </member>
<member name="M:topology.index.strtree.STRtree.size">
<summary>Returns the number of items in the tree.</summary>
<returns>the number of items in the tree</returns>
        </member>
<member name="M:topology.index.strtree.STRtree.depth">
<summary>Returns the number of items in the tree.</summary>
<returns>the number of items in the tree</returns>
        </member>
<member name="T:topology.noding.SegmentPointComparator">
<remarks>Implements a robust method of comparing the relative position of two points along the same segment. The coordinates are assumed to lie "near" the segment. This means that this algorithm will only return correct results if the input coordinates have the same precision and correspond to rounded values of exact coordinates lying on the segment.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.noding.SegmentPointComparator.compare(System.Int32,Coordinate,Coordinate)">
<summary>Compares two {@link Coordinate}s for their relative position along a segment lying in the specified {@link Octant}.</summary>
<returns>-1 node0 occurs first</returns>
<returns>0 the two nodes are equal</returns>
<returns>1 node1 occurs first</returns>
        </member>
<member name="T:topology.index.quadtree.Key">
<remarks>A Key is a unique identifier for a node in a quadtree. It contains a lower-left point and a level number. The level number is the power of two for the size of the node envelope</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.quadtree.Key.computeKey(Envelope)">
<summary>return a square envelope containing the argument envelope, whose extent is a power of two and which is based at a power of 2</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.index.chain.MonotoneChain -->
<member name="M:topology.index.chain.MonotoneChain.getCoordinates">
<summary>Return the subsequence of coordinates forming this chain.</summary>
        </member>
<member name="M:topology.index.chain.MonotoneChain.select(Envelope,MonotoneChainSelectAction)">
<summary>Determine all the line segments in the chain whose envelopes overlap the searchEnvelope, and process them</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.linearref.LocationIndexOfLine -->
<member name="M:topology.linearref.LocationIndexOfLine.indicesOf(Geometry,Geometry)">
<summary>MD - this algorithm has been extracted into a class because it is intended to validate that the subline truly is a subline, and also to use the internal vertex information to unambiguously locate the subline.</summary>
        </member>
<member name="T:topology.algorithm.HCoordinate">
<remarks>Represents a homogeneous coordinate in a 2-D coordinate space. In JTS {@link HCoordinate}s are used as a clean way of computing intersections between line segments.</remarks>
<author>David Skea</author>
<version>1.7</version>
        </member>
<member name="M:topology.algorithm.HCoordinate.intersection(Coordinate,Coordinate,Coordinate,Coordinate)">
<summary>Computes the (approximate) intersection point between two line segments using homogeneous coordinates.</summary>
        </member>
<member name="T:topology.algorithm.CentralEndpointIntersector">
<remarks>Computes an approximate intersection of two line segments by taking the most central of the endpoints of the segments. This is effective in cases where the segments are nearly parallel and should intersect at an endpoint. It is also a reasonable strategy for cases where the endpoint of one segment lies on or almost on the interior of another one. Taking the most central endpoint ensures that the computed intersection point lies in the envelope of the segments. Also, by always returning one of the input points, this should result in reducing segment fragmentation. Intended to be used as a last resort for computing ill-conditioned intersection situations which cause other methods to fail.</remarks>
<author>Martin Davis</author>
<version>1.8</version>
        </member>
<member name="M:topology.algorithm.CentralEndpointIntersector.findNearestPoint(Coordinate,Coordinate[])">
<summary>Determines a point closest to the given point.</summary>
<param name="p">the point to compare against</param>
<param name="p1">a potential result point</param>
<param name="p2">a potential result point</param>
<param name="q1">a potential result point</param>
<param name="q2">a potential result point</param>
<returns>the point closest to the input point p</returns>
        </member>
<member name="T:topology.planargraph.NodeMap">
<remarks>A map of {@link Node}s, indexed by the coordinate of the node.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.planargraph.NodeMap.#ctor">
<summary>Constructs a NodeMap without any Nodes.</summary>
        </member>
<member name="M:topology.planargraph.NodeMap.add(Node)">
<summary>Adds a node to the map, replacing any that is already at that location.</summary>
<returns>the added node</returns>
        </member>
<member name="M:topology.planargraph.NodeMap.remove(Coordinate)">
<summary>Removes the Node at the given location, and returns it (or null if no Node was there).</summary>
        </member>
<member name="M:topology.planargraph.NodeMap.find(Coordinate)">
<summary>Returns the Node at the given location, or null if no Node was there.</summary>
        </member>
<member name="M:topology.planargraph.NodeMap.iterator">
<summary>Returns an Iterator over the Nodes in this NodeMap, sorted in ascending order by angle with the positive x-axis.</summary>
        </member>
<member name="M:topology.planargraph.NodeMap.values">
<summary>Returns the Nodes in this NodeMap, sorted in ascending order by angle with the positive x-axis.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.linemerge.LineMerger -->
<member name="M:topology.operation.linemerge.LineMerger.add(Collection)">
<summary>Adds a collection of Geometries to be processed.</summary>
        </member>
<member name="M:topology.operation.linemerge.LineMerger.add(Geometry)">
<summary>Adds a Geometry to be processed.</summary>
        </member>
<member name="M:topology.operation.linemerge.LineMerger.getMergedLineStrings">
<summary>Returns the LineStrings built by the merging process.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geomgraph.Label -->
<member name="M:topology.geomgraph.Label.#ctor(System.Int32)">
<summary>Construct a Label with a single location for both Geometries.</summary>
        </member>
<member name="M:topology.geomgraph.Label.#ctor(System.Int32,System.Int32)">
<summary>Construct a Label with a single location for both Geometries.</summary>
        </member>
<member name="M:topology.geomgraph.Label.#ctor(System.Int32,System.Int32,System.Int32)">
<summary>Construct a Label with On, Left and Right locations for both Geometries.</summary>
        </member>
<member name="M:topology.geomgraph.Label.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>Construct a Label with On, Left and Right locations for both Geometries.</summary>
        </member>
<member name="M:topology.geomgraph.Label.#ctor(Label)">
<summary>Construct a Label with the same values as the argument Label.</summary>
        </member>
<member name="M:topology.geomgraph.Label.merge(Label)">
<summary>Merge this label with another one.</summary>
        </member>
<member name="M:topology.geomgraph.Label.toLine(System.Int32)">
<summary>Converts one GeometryLocation to a Line location</summary>
        </member>
<member name="T:topology.geom.MultiPolygon">
<remarks>Basic implementation of <code>MultiPolygon</code>.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.MultiPolygon.#ctor(Polygon[],PrecisionModel,System.Int32)">
<summary>Constructs a <code>MultiPolygon</code>.</summary>
<param name="polygons">the <code>Polygon</code>s for this <code>MultiPolygon</code> , or <code>null</code> or an empty array to create the empty geometry. Elements may be empty <code>Polygon</code>s, but not <code>null</code> s. The polygons must conform to the assertions specified in the <A HREF="http://www.opengis.org/techno/specs.htm">OpenGIS Simple Features Specification for SQL</A> .</param>
<param name="precisionModel">the specification of the grid of allowable points for this <code>MultiPolygon</code></param>
<param name="SRID">the ID of the Spatial Reference System used by this <code>MultiPolygon</code></param>
<obsolete>Use GeometryFactory instead</obsolete>
        </member>
<member name="M:topology.geom.MultiPolygon.#ctor(Polygon[],GeometryFactory)">
<param name="polygons">the <code>Polygon</code>s for this <code>MultiPolygon</code>, or <code>null</code> or an empty array to create the empty geometry. Elements may be empty <code>Polygon</code>s, but not <code>null</code>s. The polygons must conform to the assertions specified in the <A HREF="http://www.opengis.org/techno/specs.htm">OpenGIS Simple Features Specification for SQL</A>.</param>
        </member>
<member name="M:topology.geom.MultiPolygon.getBoundary">
	<summary>Computes the boundary of this geometry</summary>
	<returns>a lineal geometry (which may be empty)</returns>
	<seealso cref="M:topology.geom.Geometry.getBoundary"/>
</member>
<member name="T:topology.noding.OrientedCoordinateArray">
<remarks>Allows comparing {@link Coordinate} arrays in an orientation-independent way.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="M:topology.noding.OrientedCoordinateArray.#ctor(Coordinate[])">
<summary>Creates a new {@link OrientedCoordinateArray} for the given {@link Coordinate} array.</summary>
<param name="pts">the coordinates to orient</param>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.noding.OrientedCoordinateArray.orientation(Coordinate[]) -->
<member name="M:topology.noding.OrientedCoordinateArray.compareTo(Object)">
<summary>Compares two {@link OrientedCoordinateArray}s for their relative order</summary>
<returns>-1 this one is smaller</returns>
<returns>0 the two objects are equal</returns>
<returns>1 this one is greater</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.LineSegment -->
<member name="M:topology.geom.LineSegment.getLength">
<summary>Computes the length of the line segment.</summary>
<returns>the length of the line segment</returns>
        </member>
<member name="M:topology.geom.LineSegment.isHorizontal">
<summary>Tests whether the segment is horizontal.</summary>
<returns><code>true</code> if the segment is horizontal</returns>
        </member>
<member name="M:topology.geom.LineSegment.isVertical">
<summary>Tests whether the segment is vertical.</summary>
<returns><code>true</code> if the segment is vertical</returns>
        </member>
<member name="M:topology.geom.LineSegment.orientationIndex(LineSegment)">
<summary>Determines the orientation of a LineSegment relative to this segment.</summary>
<param name="seg">the LineSegment to compare</param>
<returns>1 if <code>seg</code> is to the left of this segment</returns>
<returns>-1 if <code>seg</code> is to the right of this segment</returns>
<returns>0 if <code>seg</code> has indeterminate orientation relative to this segment</returns>
        </member>
<member name="M:topology.geom.LineSegment.reverse">
<summary>Reverses the direction of the line segment.</summary>
        </member>
<member name="M:topology.geom.LineSegment.normalize">
<summary>Puts the line segment into a normalized form.</summary>
        </member>
<member name="M:topology.geom.LineSegment.angle">
<summary>Computes the angle that the vector defined by this segment makes with the X-axis.</summary>
<returns>the angle this segment makes with the X-axis (in radians)</returns>
        </member>
<member name="M:topology.geom.LineSegment.midPoint">
<summary>Computes the midpoint of the segment</summary>
<returns>the midpoint of the segment</returns>
        </member>
<member name="M:topology.geom.LineSegment.distance(LineSegment)">
<summary>Computes the distance between this line segment and another segment.</summary>
<returns>the distance to the other segment</returns>
        </member>
<member name="M:topology.geom.LineSegment.distance(Coordinate)">
<summary>Computes the distance between this line segment and a given point.</summary>
<returns>the distance from this segment to the given point</returns>
        </member>
<member name="M:topology.geom.LineSegment.distancePerpendicular(Coordinate)">
<summary>Computes the perpendicular distance between the (infinite) line defined by this line segment and a point.</summary>
<returns>the perpendicular distance between the defined line and the given point</returns>
        </member>
<member name="M:topology.geom.LineSegment.pointAlong(System.Double)">
<summary>Computes the {@link Coordinate} that lies a given fraction along the line defined by this segment.</summary>
<param name="segmentLengthFraction">the fraction of the segment length along the line</param>
<returns>the point at that distance</returns>
        </member>
<member name="M:topology.geom.LineSegment.projectionFactor(Coordinate)">
<summary>Computes the Projection Factor for the projection of the point p onto this LineSegment.</summary>
        </member>
<member name="M:topology.geom.LineSegment.project(Coordinate)">
<summary>Compute the projection of a point onto the line determined by this line segment.</summary>
        </member>
<member name="M:topology.geom.LineSegment.project(LineSegment)">
<summary>Project a line segment onto this line segment and return the resulting line segment.</summary>
<param name="seg">the line segment to project</param>
<returns>the projected line segment, or <code>null</code> if there is no overlap</returns>
        </member>
<member name="M:topology.geom.LineSegment.closestPoint(Coordinate)">
<summary>Computes the closest point on this line segment to another point.</summary>
<param name="p">the point to find the closest point to</param>
<returns>a Coordinate which is the closest point on the line segment to the point p</returns>
        </member>
<member name="M:topology.geom.LineSegment.closestPoints(LineSegment)">
<summary>Computes the closest points on two line segments.</summary>
<param name="p">the point to find the closest point to</param>
<returns>a pair of Coordinates which are the closest points on the line segments</returns>
        </member>
<member name="M:topology.geom.LineSegment.intersection(LineSegment)">
<summary>Computes an intersection point between two segments, if there is one.</summary>
<param name="line"></param>
<returns>an intersection point, or <code>null</code> if there is none</returns>
        </member>
<member name="M:topology.geom.LineSegment.equals(Object)">
<summary>Returns <code>true</code> if <code>other</code> has the same values for its points.</summary>
<param name="other">a <code>LineSegment</code> with which to do the comparison.</param>
<returns><code>true</code> if <code>other</code> is a <code>LineSegment</code> with the same values for the x and y ordinates.</returns>
        </member>
<member name="M:topology.geom.LineSegment.compareTo(Object)">
<summary>Compares this object with the specified object for order.</summary>
<param name="o">the <code>LineSegment</code> with which this <code>LineSegment</code> is being compared</param>
<returns>a negative integer, zero, or a positive integer as this <code>LineSegment</code> is less than, equal to, or greater than the specified <code>LineSegment</code></returns>
        </member>
<member name="M:topology.geom.LineSegment.equalsTopo(LineSegment)">
<summary>Returns <code>true</code> if <code>other</code> is topologically equal to this LineSegment (e.g.</summary>
<param name="other">a <code>LineSegment</code> with which to do the comparison.</param>
<returns><code>true</code> if <code>other</code> is a <code>LineSegment</code> with the same values for the x and y ordinates.</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.overlay.validate.OverlayResultValidator -->
<member name="T:topology.algorithm.Angle">
<remarks>Utility functions for working with angles. Unless otherwise noted, methods in this class express angles in radians.</remarks>
        </member>
<member name="F:topology.algorithm.Angle.COUNTERCLOCKWISE">
<summary>Constant representing counterclockwise orientation</summary>
        </member>
<member name="F:topology.algorithm.Angle.CLOCKWISE">
<summary>Constant representing clockwise orientation</summary>
        </member>
<member name="F:topology.algorithm.Angle.NONE">
<summary>Constant representing no orientation</summary>
        </member>
<member name="M:topology.algorithm.Angle.toDegrees(System.Double)">
<summary>Converts from radians to degrees.</summary>
<param name="radians">an angle in radians</param>
<returns>the angle in degrees</returns>
        </member>
<member name="M:topology.algorithm.Angle.toRadians(System.Double)">
<summary>Converts from degrees to radians.</summary>
<param name="angleDegrees">an angle in degrees</param>
<returns>the angle in radians</returns>
        </member>
<member name="M:topology.algorithm.Angle.angle(Coordinate,Coordinate)">
<summary>Returns the angle of the vector from p0 to p1, relative to the positive X-axis.</summary>
<returns>the angle (in radians) that p0-p1 makes with the positive x-axis.</returns>
        </member>
<member name="M:topology.algorithm.Angle.angle(Coordinate)">
<summary>Returns the angle that the vector from (0,0) to p, relative to the positive X-axis.</summary>
<returns>the angle (in radians) that p makes with the positive x-axis.</returns>
        </member>
<member name="M:topology.algorithm.Angle.isAcute(Coordinate,Coordinate,Coordinate)">
<summary>Tests whether the angle between p0-p1-p2 is acute.</summary>
<param name="p0">an endpoint of the angle</param>
<param name="p1">the base of the angle</param>
<param name="p2">the other endpoint of the angle</param>
        </member>
<member name="M:topology.algorithm.Angle.isObtuse(Coordinate,Coordinate,Coordinate)">
<summary>Tests whether the angle between p0-p1-p2 is obtuse.</summary>
<param name="p0">an endpoint of the angle</param>
<param name="p1">the base of the angle</param>
<param name="p2">the other endpoint of the angle</param>
        </member>
<member name="M:topology.algorithm.Angle.angleBetween(Coordinate,Coordinate,Coordinate)">
<summary>Returns the smallest angle between two vectors.</summary>
<param name="tip1">the tip of one vector</param>
<param name="tail">the tail of each vector</param>
<param name="tip2">the tip of the other vector</param>
<returns>the angle between tail-tip1 and tail-tip2</returns>
        </member>
<member name="M:topology.algorithm.Angle.interiorAngle(Coordinate,Coordinate,Coordinate)">
<summary>Computes the interior angle between two segments of a ring.</summary>
<param name="p0">a point of the ring</param>
<param name="p1">the next point of the ring</param>
<param name="p2">the next point of the ring</param>
<returns>the interior angle based at <code>p1</code></returns>
        </member>
<member name="M:topology.algorithm.Angle.getTurn(System.Double,System.Double)">
<summary>Returns whether an angle must turn clockwise or counterclockwise to overlap another angle.</summary>
<param name="ang1">an angle (in radians)</param>
<param name="ang2">an angle (in radians)</param>
<returns>whether a1 must turn CLOCKWISE, COUNTERCLOCKWISE or NONE to overlap a2.</returns>
        </member>
<member name="M:topology.algorithm.Angle.normalize(System.Double)">
<summary>Computes the normalized value of an angle, which is the equivalent angle in the range [ -Pi, Pi ].</summary>
<param name="angle">the angle to normalize</param>
<returns>an equivalent angle in the range [-Pi, Pi]</returns>
        </member>
<member name="M:topology.algorithm.Angle.normalizePositive(System.Double)">
<summary>Computes the normalized positive value of an angle, which is the equivalent angle in the range [ 0, 2*Pi ].</summary>
<param name="angle">the angle to normalize, in radians</param>
<returns>an equivalent positive angle</returns>
        </member>
<member name="M:topology.algorithm.Angle.diff(System.Double,System.Double)">
<summary>Computes the unoriented (smallest) difference between two angles.</summary>
<param name="ang1">the angle of one vector (in [-Pi, Pi] )</param>
<param name="ang2">the angle of the other vector (in range [-Pi, Pi] )</param>
<returns>the angle (in radians) between the two vectors (in range [0, Pi] )</returns>
        </member>
<member name="T:topology.operation.valid.RepeatedPointTester">
<remarks>Implements the appropriate checks for repeated points (consecutive identical coordinates) as defined in the JTS spec.</remarks>
<version>1.7</version>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.planargraph.algorithm.ConnectedSubgraphFinder -->
<member name="M:topology.planargraph.algorithm.ConnectedSubgraphFinder.addReachable(Node,Subgraph)">
<summary>Adds all nodes and edges reachable from this node to the subgraph.</summary>
<param name="node">a node known to be in the subgraph</param>
        </member>
<member name="M:topology.planargraph.algorithm.ConnectedSubgraphFinder.addEdges(Node,Stack,Subgraph)">
<summary>Adds the argument node and all its out edges to the subgraph.</summary>
<param name="node">the node to add</param>
<param name="nodeStack">the current set of nodes being traversed</param>
        </member>
<member name="T:topology.index.bintree.Interval">
<remarks>Represents an (1-dimensional) closed interval on the Real number line.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.util.AssertionFailedException">
<remarks>Thrown when the application is in an inconsistent state. Indicates a problem with the code.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.util.AssertionFailedException.#ctor">
<summary>Creates an <code>AssertionFailedException</code>.</summary>
        </member>
<member name="M:topology.util.AssertionFailedException.#ctor(String)">
<summary>Creates a <code>AssertionFailedException</code> with the given detail message.</summary>
<param name="message">a description of the assertion</param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.planargraph.PlanarGraph -->
<member name="M:topology.planargraph.PlanarGraph.#ctor">
<summary>Constructs a empty graph.</summary>
        </member>
<member name="M:topology.planargraph.PlanarGraph.findNode(Coordinate)">
<summary>Returns the {@link Node} at the given location, or null if no {@link Node} was there.</summary>
<param name="pt">the location to query</param>
<returns>the node found</returns>
<returns><code>null</code> if this graph contains no node at the location</returns>
        </member>
<member name="M:topology.planargraph.PlanarGraph.add(Node)">
<summary>Adds a node to the map, replacing any that is already at that location.</summary>
<returns>the added node</returns>
        </member>
<member name="M:topology.planargraph.PlanarGraph.add(Edge)">
<summary>Adds the Edge and its DirectedEdges with this PlanarGraph.</summary>
        </member>
<member name="M:topology.planargraph.PlanarGraph.add(DirectedEdge)">
<summary>Adds the Edge to this PlanarGraph; only subclasses can add DirectedEdges, to ensure the edges added are of the right class.</summary>
        </member>
<member name="M:topology.planargraph.PlanarGraph.nodeIterator">
<summary>Returns an Iterator over the Nodes in this PlanarGraph.</summary>
        </member>
<member name="M:topology.planargraph.PlanarGraph.contains(Edge)">
<summary>Tests whether this graph contains the given {@link Edge}</summary>
<param name="e">the edge to query</param>
<returns><code>true</code> if the graph contains the edge</returns>
<summary>Tests whether this graph contains the given {@link Edge}Returns the Nodes in this PlanarGraph.</summary>
        </member>
<member name="M:topology.planargraph.PlanarGraph.contains(DirectedEdge)">
<summary>Tests whether this graph contains the given {@link DirectedEdge}</summary>
<param name="de">the directed edge to query</param>
<returns><code>true</code> if the graph contains the directed edge</returns>
        </member>
<member name="M:topology.planargraph.PlanarGraph.dirEdgeIterator">
	<summary>Returns an Iterator over the DirectedEdges in this PlanarGraph, in the order in which they were added.</summary>
	<seealso cref="!:#add(Edge)"/>
	<seealso cref="!:#add(DirectedEdge)"/>
</member>
<member name="M:topology.planargraph.PlanarGraph.edgeIterator">
	<summary>Returns an Iterator over the Edges in this PlanarGraph, in the order in which they were added.</summary>
	<seealso cref="!:#add(Edge)"/>
</member>
<member name="M:topology.planargraph.PlanarGraph.getEdges">
	<summary>Returns the Edges that have been added to this PlanarGraph</summary>
	<seealso cref="!:#add(Edge)"/>
</member>
<member name="M:topology.planargraph.PlanarGraph.remove(Edge)">
<summary>Removes an {@link Edge} and its associated {@link DirectedEdge}s from their from-Nodes and from the graph.</summary>
        </member>
<member name="M:topology.planargraph.PlanarGraph.remove(DirectedEdge)">
<summary>Removes DirectedEdge from its from-Node and from this PlanarGraph.</summary>
        </member>
<member name="M:topology.planargraph.PlanarGraph.remove(Node)">
<summary>Removes a node from the graph, along with any associated DirectedEdges and Edges.</summary>
        </member>
<member name="M:topology.planargraph.PlanarGraph.findNodesOfDegree(System.Int32)">
<summary>Returns all Nodes with the given number of Edges around it.</summary>
        </member>
<member name="T:topology.operation.overlay.ConsistentPolygonRingChecker">
<remarks>Tests whether the polygon rings in a {@link GeometryGraph} are consistent. Used for checking if Topology errors are present after noding.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="M:topology.operation.overlay.ConsistentPolygonRingChecker.check(System.Int32)">
<summary>Tests whether the result geometry is consistent</summary>
        </member>
<member name="T:topology.geomgraph.GraphComponent">
<remarks>A GraphComponent is the parent class for the objects' that form a graph.  Each GraphComponent can carry a Label.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.geomgraph.GraphComponent.isInResult">
<summary>isInResult indicates if this component has already been included in the result</summary>
        </member>
<member name="M:topology.geomgraph.GraphComponent.getCoordinate">
<returns>a coordinate in this component (or null, if there are none)</returns>
        </member>
<member name="M:topology.geomgraph.GraphComponent.computeIM(IntersectionMatrix)">
<summary>compute the contribution to an IM for this component</summary>
        </member>
<member name="M:topology.geomgraph.GraphComponent.isIsolated">
<summary>An isolated component is one that does not intersect or touch any other component.</summary>
<returns>true if this component is isolated</returns>
        </member>
<member name="M:topology.geomgraph.GraphComponent.updateIM(IntersectionMatrix)">
<summary>Update the IM with the contribution for this component.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.valid.ConnectedInteriorTester -->
<member name="M:topology.operation.valid.ConnectedInteriorTester.buildEdgeRings(Collection)">
<summary>Form DirectedEdges in graph into Minimal EdgeRings.</summary>
        </member>
<member name="M:topology.operation.valid.ConnectedInteriorTester.visitShellInteriors(Geometry,PlanarGraph)">
<summary>Mark all the edges for the edgeRings corresponding to the shells of the input polygons.</summary>
        </member>
<member name="M:topology.operation.valid.ConnectedInteriorTester.hasUnvisitedShellEdge(List)">
<summary>Check if any shell ring has an unvisited edge.</summary>
<returns>true if there is an unvisited edge in a non-hole ring</returns>
        </member>
<member name="T:topology.linearref.ExtractLineByLocation">
<remarks>Extracts the subline of a linear {@link Geometry} between two {@link LinearLocation}s on the line.</remarks>
        </member>
<member name="M:topology.linearref.ExtractLineByLocation.extract(Geometry,LinearLocation,LinearLocation)">
<summary>Computes the subline of a {@link LineString} between two {@link LineStringLocation}s on the line.</summary>
<param name="line">the line to use as the baseline</param>
<param name="start">the start location</param>
<param name="end">the end location</param>
<returns>the extracted subline</returns>
        </member>
<member name="M:topology.linearref.ExtractLineByLocation.extract(LinearLocation,LinearLocation)">
<summary>Extracts a subline of the input.</summary>
<param name="start">the start location</param>
<param name="end">the end location</param>
<returns>a linear geometry</returns>
        </member>
<member name="M:topology.linearref.ExtractLineByLocation.computeLine(LinearLocation,LinearLocation)">
<summary>Assumes input is valid (e.g.</summary>
<param name="start"></param>
<param name="end"></param>
<returns>a linear geometry</returns>
        </member>
<member name="M:topology.linearref.ExtractLineByLocation.computeLinear(LinearLocation,LinearLocation)">
<summary>Assumes input is valid (e.g.</summary>
<param name="start"></param>
<param name="end"></param>
<returns>a linear geometry</returns>
        </member>
<member name="T:topology.operation.overlay.EdgeSetNoder">
<remarks>Nodes a set of edges. Takes one or more sets of edges and constructs a new set of edges consisting of all the split edges created by noding the input edges together</remarks>
<version>1.7</version>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.JTSVersion -->
<member name="F:topology.JTSVersion.CURRENT_VERSION">
<summary>The current version number of the JTS API.</summary>
        </member>
<member name="F:topology.JTSVersion.MAJOR">
<summary>The major version number.</summary>
        </member>
<member name="F:topology.JTSVersion.MINOR">
<summary>The minor version number.</summary>
        </member>
<member name="F:topology.JTSVersion.PATCH">
<summary>The patch version number.</summary>
        </member>
<member name="F:topology.JTSVersion.releaseInfo">
<summary>An optional string providing further release info (such as "alpha 1");</summary>
        </member>
<member name="M:topology.JTSVersion.main(String[])">
<summary>Prints the current JTS version to stdout.</summary>
<param name="args">the command-line arguments (none are required).</param>
        </member>
<member name="M:topology.JTSVersion.getMajor">
<summary>Gets the major number of the release version.</summary>
<returns>the major number of the release version.</returns>
        </member>
<member name="M:topology.JTSVersion.getMinor">
<summary>Gets the minor number of the release version.</summary>
<returns>the minor number of the release version.</returns>
        </member>
<member name="M:topology.JTSVersion.getPatch">
<summary>Gets the patch number of the release version.</summary>
<returns>the patch number of the release version.</returns>
        </member>
<member name="M:topology.JTSVersion.toString">
<summary>Gets the full version number, suitable for display.</summary>
<returns>the full version number, suitable for display.</returns>
        </member>
<member name="T:topology.geomgraph.Edge">
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.Edge.updateIM(Label,IntersectionMatrix)">
<summary>Updates an IM from the label for an edge.</summary>
        </member>
<member name="M:topology.geomgraph.Edge.getDepthDelta">
<summary>The depthDelta is the change in depth as an edge is crossed from R to L</summary>
<returns>the change in depth as the edge is crossed from R to L</returns>
        </member>
<member name="M:topology.geomgraph.Edge.isCollapsed">
<summary>An Edge is collapsed if it is an Area edge and it consists of two segments which are equal and opposite (eg a zero-width V).</summary>
        </member>
<member name="M:topology.geomgraph.Edge.addIntersections(LineIntersector,System.Int32,System.Int32)">
<summary>Adds EdgeIntersections for one or both intersections found for a segment of an edge to the edge intersection list.</summary>
        </member>
<member name="M:topology.geomgraph.Edge.addIntersection(LineIntersector,System.Int32,System.Int32,System.Int32)">
<summary>Add an EdgeIntersection for intersection intIndex.</summary>
        </member>
<member name="M:topology.geomgraph.Edge.computeIM(IntersectionMatrix)">
<summary>Update the IM with the contribution for this component.</summary>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.geomgraph.Edge.equals(Object) -->
<member name="M:topology.geomgraph.Edge.isPointwiseEqual(Edge)">
<returns>true if the coordinate sequences of the Edges are identical</returns>
        </member>
<member name="T:topology.algorithm.CentroidArea">
<remarks>Computes the centroid of an area geometry. <h2>Algorithm</h2> Based on the usual algorithm for calculating the centroid as a weighted sum of the centroids of a decomposition of the area into (possibly overlapping) triangles. The algorithm has been extended to handle holes and multi-polygons. See <code>http://www.faqs.org/faqs/graphics/algorithms-faq/</code> for further details of the basic approach.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.algorithm.CentroidArea.add(Geometry)">
<summary>Adds the area defined by a Geometry to the centroid total.</summary>
<param name="geom">the geometry to add</param>
        </member>
<member name="M:topology.algorithm.CentroidArea.add(Coordinate[])">
<summary>Adds the area defined by an array of coordinates.</summary>
<param name="ring">an array of {@link Coordinate}s</param>
        </member>
<member name="M:topology.algorithm.CentroidArea.centroid3(Coordinate,Coordinate,Coordinate,Coordinate)">
<summary>Returns three times the centroid of the triangle p1-p2-p3.</summary>
        </member>
<member name="M:topology.algorithm.CentroidArea.area2(Coordinate,Coordinate,Coordinate)">
<summary>Returns twice the signed area of the triangle p1-p2-p3, positive if a,b,c are oriented ccw, and negative if cw.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.PrecisionModel -->
<member name="M:topology.geom.PrecisionModel.mostPrecise(PrecisionModel,PrecisionModel)">
<summary>Determines which of two {@link PrecisionModel}s is the most precise (allows the greatest number of significant digits).</summary>
<param name="pm1">a PrecisionModel</param>
<param name="pm2">a PrecisionModel</param>
<returns>the PrecisionModel which is most precise</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.PrecisionModel.Type -->
<member name="M:topology.geom.PrecisionModel.Type.readResolve">
	<seealso cref="!:http://www.javaworld.com/javaworld/javatips/jw-javatip122.html"/>
</member>
<member name="F:topology.geom.PrecisionModel.FIXED">
<summary>Fixed Precision indicates that coordinates have a fixed number of decimal places.</summary>
        </member>
<member name="F:topology.geom.PrecisionModel.FLOATING">
<summary>Floating precision corresponds to the standard Java double-precision floating-point representation, which is based on the IEEE-754 standard</summary>
        </member>
<member name="F:topology.geom.PrecisionModel.FLOATING_SINGLE">
<summary>Floating single precision corresponds to the standard Java single-precision floating-point representation, which is based on the IEEE-754 standard</summary>
        </member>
<member name="F:topology.geom.PrecisionModel.maximumPreciseValue">
<summary>The maximum precise value representable in a double.</summary>
        </member>
<member name="F:topology.geom.PrecisionModel.modelType">
<summary>The type of PrecisionModel this represents.</summary>
        </member>
<member name="F:topology.geom.PrecisionModel.scale">
<summary>The scale factor which determines the number of decimal places in fixed precision.</summary>
        </member>
<member name="M:topology.geom.PrecisionModel.#ctor">
<summary>Creates a <code>PrecisionModel</code> with a default precision of FLOATING.</summary>
        </member>
<member name="M:topology.geom.PrecisionModel.#ctor(Type)">
<summary>Creates a <code>PrecisionModel</code> that specifies an explicit precision model type.</summary>
<param name="modelType">the type of the precision model</param>
        </member>
<member name="M:topology.geom.PrecisionModel.#ctor(System.Double,System.Double,System.Double)">
<summary>Creates a <code>PrecisionModel</code> that specifies Fixed precision.</summary>
<param name="scale">amount by which to multiply a coordinate after subtracting the offset, to obtain a precise coordinate</param>
<param name="offsetX">not used.</param>
<param name="offsetY">not used.</param>
<obsolete>offsets are no longer supported, since internal representation is rounded floating point</obsolete>
        </member>
<member name="M:topology.geom.PrecisionModel.#ctor(System.Double)">
<summary>Creates a <code>PrecisionModel</code> that specifies Fixed precision.</summary>
<param name="scale">amount by which to multiply a coordinate after subtracting the offset, to obtain a precise coordinate</param>
        </member>
<member name="M:topology.geom.PrecisionModel.#ctor(PrecisionModel)">
<summary>Copy constructor to create a new <code>PrecisionModel</code> from an existing one.</summary>
        </member>
<member name="M:topology.geom.PrecisionModel.isFloating">
<summary>Tests whether the precision model supports floating point</summary>
<returns><code>true</code> if the precision model supports floating point</returns>
        </member>
<member name="M:topology.geom.PrecisionModel.getMaximumSignificantDigits">
<summary>Returns the maximum number of significant digits provided by this precision model.</summary>
<returns>the maximum number of decimal places provided by this precision model</returns>
        </member>
<member name="M:topology.geom.PrecisionModel.getScale">
<summary>Returns the multiplying factor used to obtain a precise coordinate.</summary>
<returns>the amount by which to multiply a coordinate after subtracting the offset</returns>
        </member>
<member name="M:topology.geom.PrecisionModel.getType">
<summary>Gets the type of this PrecisionModel</summary>
<returns>the type of this PrecisionModel</returns>
        </member>
<member name="M:topology.geom.PrecisionModel.setScale(System.Double)">
<summary>Sets the multiplying factor used to obtain a precise coordinate.</summary>
        </member>
<member name="M:topology.geom.PrecisionModel.getOffsetX">
<summary>Returns the x-offset used to obtain a precise coordinate.</summary>
<returns>the amount by which to subtract the x-coordinate before multiplying by the scale</returns>
<obsolete>Offsets are no longer used</obsolete>
        </member>
<member name="M:topology.geom.PrecisionModel.getOffsetY">
<summary>Returns the y-offset used to obtain a precise coordinate.</summary>
<returns>the amount by which to subtract the y-coordinate before multiplying by the scale</returns>
<obsolete>Offsets are no longer used</obsolete>
        </member>
<member name="M:topology.geom.PrecisionModel.toInternal(Coordinate,Coordinate)">
<summary>Sets <code>internal</code> to the precise representation of <code>external</code>.</summary>
<param name="external">the original coordinate</param>
<param name="internal">the coordinate whose values will be changed to the precise representation of <code>external</code></param>
<obsolete>use makePrecise instead</obsolete>
        </member>
<member name="M:topology.geom.PrecisionModel.toInternal(Coordinate)">
<summary>Returns the precise representation of <code>external</code>.</summary>
<param name="external">the original coordinate</param>
<returns>the coordinate whose values will be changed to the precise representation of <code>external</code></returns>
<obsolete>use makePrecise instead</obsolete>
        </member>
<member name="M:topology.geom.PrecisionModel.toExternal(Coordinate)">
<summary>Returns the external representation of <code>internal</code>.</summary>
<param name="internal">the original coordinate</param>
<returns>the coordinate whose values will be changed to the external representation of <code>internal</code></returns>
<obsolete>no longer needed, since internal representation is same as external representation</obsolete>
        </member>
<member name="M:topology.geom.PrecisionModel.toExternal(Coordinate,Coordinate)">
<summary>Sets <code>external</code> to the external representation of <code>internal</code> .</summary>
<param name="internal">the original coordinate</param>
<param name="external">the coordinate whose values will be changed to the external representation of <code>internal</code></param>
<obsolete>no longer needed, since internal representation is same as external representation</obsolete>
        </member>
<member name="M:topology.geom.PrecisionModel.makePrecise(System.Double)">
<summary>Rounds a numeric value to the PrecisionModel grid.</summary>
        </member>
<member name="M:topology.geom.PrecisionModel.makePrecise(Coordinate)">
<summary>Rounds a Coordinate to the PrecisionModel grid.</summary>
        </member>
<member name="M:topology.geom.PrecisionModel.compareTo(Object)">
<summary>Compares this {@link PrecisionModel} object with the specified object for order.</summary>
<param name="o">the <code>PrecisionModel</code> with which this <code>PrecisionModel</code> is being compared</param>
<returns>a negative integer, zero, or a positive integer as this <code>PrecisionModel</code> is less than, equal to, or greater than the specified <code>PrecisionModel</code></returns>
        </member>
<member name="T:topology.noding.InteriorIntersectionFinder">
<remarks>Finds an interior intersection in a set of {@link SegmentString}s, if one exists.  Only the first intersection found is reported.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.noding.InteriorIntersectionFinder.#ctor(LineIntersector)">
<summary>Creates an intersection finder which finds an interior intersection if one exists</summary>
<param name="li">the LineIntersector to use</param>
        </member>
<member name="M:topology.noding.InteriorIntersectionFinder.setCheckEndSegmentsOnly(System.Boolean)">
<summary>Sets whether only end segments should be tested for interior intersection.</summary>
<param name="isCheckEndSegmentsOnly">whether to test only end segments</param>
        </member>
<member name="M:topology.noding.InteriorIntersectionFinder.hasIntersection">
<summary>Tests whether an intersection was found.</summary>
<returns>true if an intersection was found</returns>
        </member>
<member name="M:topology.noding.InteriorIntersectionFinder.getInteriorIntersection">
<summary>Gets the computed location of the intersection.</summary>
<returns>the coordinate for the intersection location</returns>
        </member>
<member name="M:topology.noding.InteriorIntersectionFinder.getIntersectionSegments">
<summary>Gets the endpoints of the intersecting segments.</summary>
<returns>an array of the segment endpoints (p00, p01, p10, p11)</returns>
        </member>
<member name="M:topology.noding.InteriorIntersectionFinder.processIntersections(SegmentString,System.Int32,SegmentString,System.Int32)">
<summary>This method is called by clients of the {@link SegmentIntersector} class to process intersections for two segments of the {@link SegmentStrings} being intersected.</summary>
        </member>
<member name="M:topology.noding.InteriorIntersectionFinder.isEndSegment(SegmentString,System.Int32)">
<summary>Tests whether a segment in a {@link SegmentString} is an end segment.</summary>
<param name="segStr">a segment string</param>
<param name="index">the index of a segment in the segment string</param>
<returns>true if the segment is an end segment</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.linemerge.LineSequencer -->
<member name="M:topology.operation.linemerge.LineSequencer.isSequenced(Geometry)">
<summary>Tests whether a {@link Geometry} is sequenced correctly.</summary>
<param name="geom">the geometry to test</param>
<returns><code>true</code> if the geometry is sequenced or is not lineal</returns>
        </member>
<member name="M:topology.operation.linemerge.LineSequencer.add(Collection)">
<summary>Adds a {@link Collection} of {@link Geometry}s to be sequenced.</summary>
<param name="geometries">a Collection of geometries to add</param>
        </member>
<member name="M:topology.operation.linemerge.LineSequencer.add(Geometry)">
<summary>Adds a {@link Geometry} to be sequenced.</summary>
<param name="geometry">the geometry to add</param>
        </member>
<member name="M:topology.operation.linemerge.LineSequencer.isSequenceable">
<summary>Tests whether the arrangement of linestrings has a valid sequence.</summary>
<returns><code>true</code> if a valid sequence exists.</returns>
        </member>
<member name="M:topology.operation.linemerge.LineSequencer.getSequencedLineStrings">
<summary>Returns the {@link LineString} or {@link MultiLineString} built by the sequencing process, if one exists.</summary>
<returns>the sequenced linestrings, or <code>null</code> if a valid sequence does not exist</returns>
        </member>
<member name="M:topology.operation.linemerge.LineSequencer.hasSequence(Subgraph)">
<summary>Tests whether a complete unique path exists in a graph using Euler's Theorem.</summary>
<param name="graph">the subgraph containing the edges</param>
<returns><code>true</code> if a sequence exists</returns>
        </member>
<member name="M:topology.operation.linemerge.LineSequencer.findUnvisitedBestOrientedDE(Node)">
<summary>Finds an {@link DirectedEdge} for an unvisited edge (if any), choosing the dirEdge which preserves orientation, if possible.</summary>
<param name="node">the node to examine</param>
<returns>the dirEdge found, or <code>null</code> if none were unvisited</returns>
        </member>
<member name="M:topology.operation.linemerge.LineSequencer.orient(List)">
<summary>Computes a version of the sequence which is optimally oriented relative to the underlying geometry.</summary>
<param name="seq">a List of DirectedEdges</param>
<returns>a List of DirectedEdges oriented appropriately</returns>
        </member>
<member name="M:topology.operation.linemerge.LineSequencer.reverse(List)">
<summary>Reverse the sequence.</summary>
<param name="seq">a List of DirectedEdges, in sequential order</param>
<returns>the reversed sequence</returns>
        </member>
<member name="M:topology.operation.linemerge.LineSequencer.buildSequencedGeometry(List)">
<summary>Builds a geometry ({@link LineString} or {@link MultiLineString} ) representing the sequence.</summary>
<param name="sequences">a List of Lists of DirectedEdges with LineMergeEdges as their parent edges.</param>
<returns>the sequenced geometry, or <code>null</code> if no sequence exists</returns>
        </member>
<member name="T:topology.geom.CoordinateSequences">
<remarks>Utility functions for manipulating {@link CoordinateSequence}s</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.CoordinateSequences.reverse(CoordinateSequence)">
<summary>Reverses the coordinates in a sequence in-place.</summary>
        </member>
<member name="M:topology.geom.CoordinateSequences.swap(CoordinateSequence,System.Int32,System.Int32)">
<summary>Swaps two coordinates in a sequence.</summary>
<param name="seq"></param>
<param name="i"></param>
<param name="j"></param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.index.bintree.Bintree -->
<member name="M:topology.index.bintree.Bintree.ensureExtent(Interval,System.Double)">
<summary>Ensure that the Interval for the inserted item has non-zero extents.</summary>
        </member>
<member name="F:topology.index.bintree.Bintree.minExtent">
<summary>Statistics minExtent is the minimum extent of all items inserted into the tree so far.</summary>
        </member>
<member name="M:topology.index.bintree.Bintree.nodeSize">
<summary>Compute the total number of nodes in the tree</summary>
<returns>the number of nodes in the tree</returns>
        </member>
<member name="M:topology.index.bintree.Bintree.query(Interval)">
<summary>min and max may be the same value</summary>
        </member>
<member name="T:topology.algorithm.CGAlgorithms">
<remarks>Specifies and implements various fundamental Computational Geometric algorithms. The algorithms supplied in this class are robust for double-precision floating point.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.algorithm.CGAlgorithms.CLOCKWISE">
<summary>A value that indicates an orientation of clockwise, or a right turn.</summary>
        </member>
<member name="F:topology.algorithm.CGAlgorithms.COUNTERCLOCKWISE">
<summary>A value that indicates an orientation of counterclockwise, or a left turn.</summary>
        </member>
<member name="F:topology.algorithm.CGAlgorithms.COLLINEAR">
<summary>A value that indicates an orientation of collinear, or no turn (straight).</summary>
        </member>
<member name="M:topology.algorithm.CGAlgorithms.orientationIndex(Coordinate,Coordinate,Coordinate)">
<summary>Returns the index of the direction of the point <code>q</code> relative to a vector specified by <code>p1-p2</code>.</summary>
<param name="p1">the origin point of the vector</param>
<param name="p2">the final point of the vector</param>
<param name="q">the point to compute the direction to</param>
<returns>1 if q is counter-clockwise (left) from p1-p2</returns>
<returns>-1 if q is clockwise (right) from p1-p2</returns>
<returns>0 if q is collinear with p1-p2</returns>
        </member>
<member name="M:topology.algorithm.CGAlgorithms.isPointInRing(Coordinate,Coordinate[])">
<summary>Test whether a point lies inside a ring.</summary>
<param name="p">point to check for ring inclusion</param>
<param name="ring">assumed to have first point identical to last point</param>
<returns><code>true</code> if p is inside ring</returns>
        </member>
<member name="M:topology.algorithm.CGAlgorithms.isOnLine(Coordinate,Coordinate[])">
<summary>Test whether a point lies on the line segments defined by a list of coordinates.</summary>
<returns>true true if the point is a vertex of the line or lies in the interior of a line segment in the linestring</returns>
        </member>
<member name="M:topology.algorithm.CGAlgorithms.isCCW(Coordinate[])">
<summary>Computes whether a ring defined by an array of {@link Coordinate} is oriented counter-clockwise.</summary>
<param name="ring">an array of coordinates forming a ring</param>
<returns><code>true</code> if the ring is oriented counter-clockwise.</returns>
        </member>
<member name="M:topology.algorithm.CGAlgorithms.computeOrientation(Coordinate,Coordinate,Coordinate)">
<summary>Computes the orientation of a point q to the directed line segment p1-p2.</summary>
<returns>1 if q is counter-clockwise from p1-p2</returns>
<returns>-1 if q is clockwise from p1-p2</returns>
<returns>0 if q is collinear with p1-p2</returns>
        </member>
<member name="M:topology.algorithm.CGAlgorithms.distancePointLine(Coordinate,Coordinate,Coordinate)">
<summary>Computes the distance from a point p to a line segment AB Note: NON-ROBUST!</summary>
<param name="p">the point to compute the distance for</param>
<param name="A">one point of the line</param>
<param name="B">another point of the line (must be different to A)</param>
<returns>the distance from p to line segment AB</returns>
        </member>
<member name="M:topology.algorithm.CGAlgorithms.distancePointLinePerpendicular(Coordinate,Coordinate,Coordinate)">
<summary>Computes the perpendicular distance from a point p to the (infinite) line containing the points AB</summary>
<param name="p">the point to compute the distance for</param>
<param name="A">one point of the line</param>
<param name="B">another point of the line (must be different to A)</param>
<returns>the distance from p to line AB</returns>
        </member>
<member name="M:topology.algorithm.CGAlgorithms.distanceLineLine(Coordinate,Coordinate,Coordinate,Coordinate)">
<summary>Computes the distance from a line segment AB to a line segment CD Note: NON-ROBUST!</summary>
<param name="A">a point of one line</param>
<param name="B">the second point of  (must be different to A)</param>
<param name="C">one point of the line</param>
<param name="D">another point of the line (must be different to A)</param>
        </member>
<member name="M:topology.algorithm.CGAlgorithms.signedArea(Coordinate[])">
<summary>Returns the signed area for a ring.</summary>
        </member>
<member name="M:topology.algorithm.CGAlgorithms.length(CoordinateSequence)">
<summary>Computes the length of a linestring specified by a sequence of points.</summary>
<param name="pts">the points specifying the linestring</param>
<returns>the length of the linestring</returns>
        </member>
<member name="T:topology.index.bintree.Key">
<remarks>A Key is a unique identifier for a node in a tree. It contains a lower-left point and a level number. The level number is the power of two for the size of the node envelope</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.bintree.Key.computeKey(Interval)">
<summary>return a square envelope containing the argument envelope, whose extent is a power of two and which is based at a power of 2</summary>
        </member>
<member name="T:topology.linearref.LinearLocation">
<remarks>Represents a location along a {@link LineString} or {@link MultiLineString}. The referenced geometry is not maintained within this location, but must be provided for operations which require it. Various methods are provided to manipulate the location value and query the geometry it references.</remarks>
        </member>
<member name="M:topology.linearref.LinearLocation.getEndLocation(Geometry)">
<summary>Gets a location which refers to the end of a linear {@link Geometry}.</summary>
<param name="linear">the linear geometry</param>
<returns>a new <tt>LinearLocation</tt></returns>
        </member>
<member name="M:topology.linearref.LinearLocation.pointAlongSegmentByFraction(Coordinate,Coordinate,System.Double)">
<summary>Computes the {@link Coordinate} of a point a given fraction along the line segment <tt>(p0, p1)</tt>.</summary>
<param name="p0">the first point of the line segment</param>
<param name="p1">the last point of the line segment</param>
<param name="frac">the length to the desired point</param>
<returns>the <tt>Coordinate</tt> of the desired point</returns>
        </member>
<member name="M:topology.linearref.LinearLocation.#ctor">
<summary>Creates a location referring to the start of a linear geometry</summary>
        </member>
<member name="M:topology.linearref.LinearLocation.normalize">
	<summary>Ensures the individual values are locally valid.</summary>
	<seealso cref="M:topology.linearref.LinearLocation.clamp(topology.geom.Geometry linear)"/>
</member>
<member name="M:topology.linearref.LinearLocation.clamp(Geometry)">
<summary>Ensures the indexes are valid for a given linear {@link Geometry}.</summary>
<param name="linear">a linear geometry</param>
        </member>
<member name="M:topology.linearref.LinearLocation.snapToVertex(Geometry,System.Double)">
<summary>Snaps the value of this location to the nearest vertex on the given linear {@link Geometry}, if the vertex is closer than <tt>maxDistance</tt>.</summary>
<param name="linearGeom">a linear geometry</param>
<param name="minDistance">the minimum allowable distance to a vertex</param>
        </member>
<member name="M:topology.linearref.LinearLocation.getSegmentLength(Geometry)">
<summary>Gets the length of the segment in the given Geometry containing this location.</summary>
<param name="linearGeom">a linear geometry</param>
<returns>the length of the segment</returns>
        </member>
<member name="M:topology.linearref.LinearLocation.setToEnd(Geometry)">
<summary>Sets the value of this location to refer the end of a linear geometry</summary>
<param name="linear">the linear geometry to set</param>
        </member>
<member name="M:topology.linearref.LinearLocation.getComponentIndex">
<summary>Gets the component index for this location.</summary>
<returns>the component index</returns>
        </member>
<member name="M:topology.linearref.LinearLocation.getSegmentIndex">
<summary>Gets the segment index for this location</summary>
<returns>the segment index</returns>
        </member>
<member name="M:topology.linearref.LinearLocation.getSegmentFraction">
<summary>Gets the segment fraction for this location</summary>
<returns>the segment fraction</returns>
        </member>
<member name="M:topology.linearref.LinearLocation.isVertex">
<summary>Tests whether this location refers to a vertex</summary>
<returns>true if the location is a vertex</returns>
        </member>
<member name="M:topology.linearref.LinearLocation.getCoordinate(Geometry)">
<summary>Gets the {@link Coordinate} along the given linear {@link Geometry} which is referenced by this location.</summary>
<param name="linearGeom">a linear geometry</param>
<returns>the <tt>Coordinate</tt> at the location</returns>
        </member>
<member name="M:topology.linearref.LinearLocation.isValid(Geometry)">
<summary>Tests whether this location refers to a valid location on the given linear {@link Geometry}.</summary>
<param name="linearGeom">a linear geometry</param>
<returns>true if this location is valid</returns>
        </member>
<member name="M:topology.linearref.LinearLocation.compareTo(Object)">
<summary>Compares this object with the specified object for order.</summary>
<param name="o">the <code>LineStringLocation</code> with which this <code>Coordinate</code> is being compared</param>
<returns>a negative integer, zero, or a positive integer as this <code>LineStringLocation</code> is less than, equal to, or greater than the specified <code>LineStringLocation</code></returns>
        </member>
<member name="M:topology.linearref.LinearLocation.compareLocationValues(System.Int32,System.Int32,System.Double)">
<summary>Compares this object with the specified index values for order.</summary>
<param name="componentIndex1">a component index</param>
<param name="segmentIndex1">a segment index</param>
<param name="segmentFraction1">a segment fraction</param>
<returns>a negative integer, zero, or a positive integer as this <code>LineStringLocation</code> is less than, equal to, or greater than the specified locationValues</returns>
        </member>
<member name="M:topology.linearref.LinearLocation.compareLocationValues(System.Int32,System.Int32,System.Double,System.Int32,System.Int32,System.Double)">
<summary>Compares two sets of location values for order.</summary>
<param name="componentIndex0">a component index</param>
<param name="segmentIndex0">a segment index</param>
<param name="segmentFraction0">a segment fraction</param>
<param name="componentIndex1">another component index</param>
<param name="segmentIndex1">another segment index</param>
<param name="segmentFraction1">another segment fraction</param>
<returns>a negative integer, zero, or a positive integer as the first set of location values is less than, equal to, or greater than the second set of locationValues</returns>
        </member>
<member name="M:topology.linearref.LinearLocation.clone">
<summary>Copies this location</summary>
<returns>a copy of this location</returns>
        </member>
<member name="T:topology.geomgraph.EdgeList">
<remarks>A EdgeList is a list of Edges.  It supports locating edges that are pointwise equals to a target edge.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.geomgraph.EdgeList.index">
<summary>An index of the edges, for fast lookup.</summary>
        </member>
<member name="M:topology.geomgraph.EdgeList.add(Edge)">
<summary>Insert an edge unless it is already in the list</summary>
        </member>
<member name="M:topology.geomgraph.EdgeList.findEqualEdge(Edge)">
<summary>If there is an edge equal to e already in the list, return it.</summary>
<returns>equal edge, if there is one already in the list null otherwise</returns>
        </member>
<member name="M:topology.geomgraph.EdgeList.findEdgeIndex(Edge)">
<summary>If the edge e is already in the list, return its index.</summary>
<returns>index, if e is already in the list -1 otherwise</returns>
        </member>
<member name="T:topology.operation.distance.ConnectedElementLocationFilter">
<remarks>A ConnectedElementPointFilter extracts a single point from each connected element in a Geometry (e.g. a polygon, linestring or point) and returns them in a list. The elements of the list are {@link topology.operation.distance.GeometryLocation}s.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.distance.ConnectedElementLocationFilter.getLocations(Geometry)">
<summary>Returns a list containing a point from each Polygon, LineString, and Point found inside the specified geometry.</summary>
        </member>
<member name="T:topology.index.chain.MonotoneChainBuilder">
<remarks>A MonotoneChainBuilder implements functions to determine the monotone chains in a sequence of points.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.chain.MonotoneChainBuilder.getChains(Coordinate[],Object)">
<summary>Return a list of the {@link MonotoneChain}s for the given list of coordinates.</summary>
        </member>
<member name="M:topology.index.chain.MonotoneChainBuilder.getChainStartIndices(Coordinate[])">
<summary>Return an array containing lists of start/end indexes of the monotone chains for the given list of coordinates.</summary>
        </member>
<member name="M:topology.index.chain.MonotoneChainBuilder.findChainEnd(Coordinate[],System.Int32)">
<returns>the index of the last point in the monotone chain starting at <code>start</code>.</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geomgraph.index.MonotoneChainIndexer -->
<member name="M:topology.geomgraph.index.MonotoneChainIndexer.findChainEnd(Coordinate[],System.Int32)">
<returns>the index of the last point in the monotone chain</returns>
        </member>
<member name="T:topology.precision.CommonBitsRemover">
<remarks>Allow computing and removing common mantissa bits from one or more Geometries.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.precision.CommonBitsRemover.add(Geometry)">
<summary>Add a geometry to the set of geometries whose common bits are being computed.</summary>
<param name="geom">a Geometry to test for common bits</param>
        </member>
<member name="M:topology.precision.CommonBitsRemover.getCommonCoordinate">
<summary>The common bits of the Coordinates in the supplied Geometries.</summary>
        </member>
<member name="M:topology.precision.CommonBitsRemover.removeCommonBits(Geometry)">
<summary>Removes the common coordinate bits from a Geometry.</summary>
<param name="geom">the Geometry from which to remove the common coordinate bits</param>
<returns>the shifted Geometry</returns>
        </member>
<member name="M:topology.precision.CommonBitsRemover.addCommonBits(Geometry)">
<summary>Adds the common coordinate bits back into a Geometry.</summary>
<param name="geom">the Geometry to which to add the common coordinate bits</param>
<returns>the shifted Geometry</returns>
        </member>
<member name="T:topology.operation.overlay.validate.OffsetPointGenerator">
<remarks>Generates points offset by a given distance from both sides of the midpoint of all segments in a {@link Geometry}. Can be used to generate probe points for determining whether a polygonal overlay result is incorrect.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.operation.overlay.validate.OffsetPointGenerator.getPoints -->
<member name="M:topology.operation.overlay.validate.OffsetPointGenerator.computeOffsetPoints(Coordinate,Coordinate)">
<summary>Generates the two points which are offset from the midpoint of the segment <tt>(p0, p1)</tt> by the <tt>offsetDistance</tt>.</summary>
<param name="p0">the first point of the segment to offset from</param>
<param name="p1">the second point of the segment to offset from</param>
        </member>
<member name="T:topology.geom.impl.PackedCoordinateSequenceFactory">
<remarks>Builds packed array coordinate sequences. The array data type can be either double or float, and defaults to float.</remarks>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequenceFactory.#ctor">
<summary>Creates a new PackedCoordinateSequenceFactory of type DOUBLE.</summary>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequenceFactory.#ctor(System.Int32)">
<summary>Creates a new PackedCoordinateSequenceFactory of the given type.</summary>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequenceFactory.#ctor(System.Int32,System.Int32)">
<summary>Creates a new PackedCoordinateSequenceFactory of the given type.</summary>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequenceFactory.getType">
<summary>Returns the type of packed coordinate sequences this factory builds, either {@linkplain PackedCoordinateSequenceFactory#Float} or {@linkplain PackedCoordinateSequenceFactory#Double}</summary>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequenceFactory.setType(System.Int32)">
<summary>Sets the type of packed coordinate sequences this factory builds, acceptable values are {@linkplain PackedCoordinateSequenceFactory#Float}or {@linkplain PackedCoordinateSequenceFactory#Double}</summary>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequenceFactory.create(Coordinate[])">
	<seealso cref="M:topology.geom.CoordinateSequenceFactory.create(topology.geom.Coordinate[] coordinates)"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequenceFactory.create(CoordinateSequence)">
	<seealso cref="M:topology.geom.CoordinateSequenceFactory.create(topology.geom.CoordinateSequence coordSeq)"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequenceFactory.create(System.Double[],System.Int32)">
	<seealso cref="!:topology.geom.CoordinateSequenceFactory#create(double[],"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequenceFactory.create(System.Single[],System.Int32)">
	<seealso cref="!:topology.geom.CoordinateSequenceFactory#create(float[],"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequenceFactory.create(System.Int32,System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequenceFactory.create(System.Int32 size,System.Int32 dimension)"/>
</member>
<!-- Badly formed XML comment ignored for member T:topology.noding.IteratedNoder -->
<member name="M:topology.noding.IteratedNoder.setMaximumIterations(System.Int32)">
<summary>Sets the maximum number of noding iterations performed before the noding is aborted.</summary>
<param name="maxIter">the maximum number of iterations to perform</param>
        </member>
<member name="M:topology.noding.IteratedNoder.computeNodes(Collection)">
<summary>Fully nodes a list of {@link SegmentStrings}, i.e.</summary>
<param name="segStrings">a collection of SegmentStrings to be noded</param>
<returns>a collection of the noded SegmentStrings</returns>
        </member>
<member name="M:topology.noding.IteratedNoder.node(Collection,System.Int32[])">
<summary>Node the input segment strings once and create the split edges between the nodes</summary>
        </member>
<member name="T:topology.index.quadtree.Root">
<remarks>QuadRoot is the root of a single Quadtree.  It is centred at the origin, and does not have a defined extent.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.quadtree.Root.insert(Envelope,Object)">
<summary>Insert an item into the quadtree this is the root of.</summary>
        </member>
<member name="M:topology.index.quadtree.Root.insertContained(Node,Envelope,Object)">
<summary>insert an item which is known to be contained in the tree rooted at the given QuadNode root.</summary>
        </member>
<member name="T:topology.geom.MultiPoint">
<remarks>Models a collection of <code>Point</code>s.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.MultiPoint.#ctor(Point[],PrecisionModel,System.Int32)">
<summary>Constructs a <code>MultiPoint</code>.</summary>
<param name="points">the <code>Point</code>s for this <code>MultiPoint</code> , or <code>null</code> or an empty array to create the empty geometry. Elements may be empty <code>Point</code>s, but not <code>null</code>s.</param>
<param name="precisionModel">the specification of the grid of allowable points for this <code>MultiPoint</code></param>
<param name="SRID">the ID of the Spatial Reference System used by this <code>MultiPoint</code></param>
<obsolete>Use GeometryFactory instead</obsolete>
        </member>
<member name="M:topology.geom.MultiPoint.#ctor(Point[],GeometryFactory)">
<param name="points">the <code>Point</code>s for this <code>MultiPoint</code> , or <code>null</code> or an empty array to create the empty geometry. Elements may be empty <code>Point</code>s, but not <code>null</code>s.</param>
        </member>
<member name="M:topology.geom.MultiPoint.getBoundary">
	<summary>Gets the boundary of this geometry.</summary>
	<returns>an empty GeometryCollection</returns>
	<seealso cref="M:topology.geom.Geometry.getBoundary"/>
</member>
<member name="M:topology.geom.MultiPoint.getCoordinate(System.Int32)">
<summary>Returns the <code>Coordinate</code> at the given position.</summary>
<param name="n">the index of the <code>Coordinate</code> to retrieve, beginning at 0</param>
<returns>the <code>n</code>th <code>Coordinate</code></returns>
        </member>
<member name="T:topology.geomgraph.index.SweepLineSegment">
<version>1.7</version>
        </member>
<member name="T:topology.operation.overlay.snap.GeometrySnapper">
<remarks>Snaps the vertices and segments of a {@link Geometry} to another Geometry's vertices. Improves robustness for overlay operations, by eliminating nearly parallel edges (which cause problems during noding and intersection calculation).</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="M:topology.operation.overlay.snap.GeometrySnapper.computeOverlaySnapTolerance(Geometry)">
<summary>Estimates the snap tolerance for a Geometry, taking into account its precision model.</summary>
<param name="g">a Geometry</param>
<returns>the estimated snap tolerance</returns>
        </member>
<member name="M:topology.operation.overlay.snap.GeometrySnapper.snap(Geometry,Geometry,System.Double)">
<summary>Snaps two geometries together with a given tolerance.</summary>
<param name="g0">a geometry to snap</param>
<param name="g1">a geometry to snap</param>
<param name="snapTolerance">the tolerance to use</param>
<returns>the snapped geometries</returns>
        </member>
<member name="M:topology.operation.overlay.snap.GeometrySnapper.computeSnapTolerance(Coordinate[])">
<summary>Computes the snap tolerance based on the input geometries.</summary>
<param name="ringPts"></param>
<returns></returns>
        </member>
<member name="M:topology.operation.overlay.snap.GeometrySnapper.snapTo(Geometry,System.Double)">
<summary>Snaps the vertices in the component {@link LineString}s of the source geometry to the vertices of the given geometry.</summary>
<param name="g"></param>
<returns>a new snapped Geometry</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.index.quadtree.Quadtree -->
<member name="M:topology.index.quadtree.Quadtree.ensureExtent(Envelope,System.Double)">
<summary>Ensure that the envelope for the inserted item has non-zero extents.</summary>
        </member>
<member name="F:topology.index.quadtree.Quadtree.minExtent">
<summary>minExtent is the minimum envelope extent of all items inserted into the tree so far.</summary>
        </member>
<member name="M:topology.index.quadtree.Quadtree.#ctor">
<summary>Constructs a Quadtree with zero items.</summary>
        </member>
<member name="M:topology.index.quadtree.Quadtree.depth">
<summary>Returns the number of levels in the tree.</summary>
        </member>
<member name="M:topology.index.quadtree.Quadtree.size">
<summary>Returns the number of items in the tree.</summary>
<returns>the number of items in the tree</returns>
        </member>
<member name="M:topology.index.quadtree.Quadtree.remove(Envelope,Object)">
<summary>Removes a single item from the tree.</summary>
<param name="itemEnv">the Envelope of the item to remove</param>
<param name="item">the item to remove</param>
<returns><code>true</code> if the item was found</returns>
        </member>
<member name="M:topology.index.quadtree.Quadtree.queryAll">
<summary>Return a list of all items in the Quadtree</summary>
        </member>
<member name="T:topology.planargraph.DirectedEdgeStar">
<remarks>A sorted collection of {@link DirectedEdge}s which leave a {@link Node} in a {@link PlanarGraph}.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.planargraph.DirectedEdgeStar.outEdges">
<summary>The underlying list of outgoing DirectedEdges</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdgeStar.#ctor">
<summary>Constructs a DirectedEdgeStar with no edges.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdgeStar.add(DirectedEdge)">
<summary>Adds a new member to this DirectedEdgeStar.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdgeStar.remove(DirectedEdge)">
<summary>Drops a member of this DirectedEdgeStar.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdgeStar.iterator">
<summary>Returns an Iterator over the DirectedEdges, in ascending order by angle with the positive x-axis.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdgeStar.getDegree">
<summary>Returns the number of edges around the Node associated with this DirectedEdgeStar.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdgeStar.getCoordinate">
<summary>Returns the coordinate for the node at wich this star is based</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdgeStar.getEdges">
<summary>Returns the DirectedEdges, in ascending order by angle with the positive x-axis.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdgeStar.getIndex(Edge)">
<summary>Returns the zero-based index of the given Edge, after sorting in ascending order by angle with the positive x-axis.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdgeStar.getIndex(DirectedEdge)">
<summary>Returns the zero-based index of the given DirectedEdge, after sorting in ascending order by angle with the positive x-axis.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdgeStar.getIndex(System.Int32)">
<summary>Returns the remainder when i is divided by the number of edges in this DirectedEdgeStar.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdgeStar.getNextEdge(DirectedEdge)">
<summary>Returns the DirectedEdge on the left-hand side of the given DirectedEdge (which must be a member of this DirectedEdgeStar).</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.Geometry -->
<member name="F:topology.geom.Geometry.envelope">
<summary>The bounding box of this <code>Geometry</code>.</summary>
        </member>
<member name="F:topology.geom.Geometry.factory">
<summary>The {@link GeometryFactory} used to create this Geometry</summary>
        </member>
<member name="F:topology.geom.Geometry.SRID">
<summary>The ID of the Spatial Reference System used by this <code>Geometry</code></summary>
        </member>
<member name="M:topology.geom.Geometry.#ctor(GeometryFactory)">
<summary>Creates a new <tt>Geometry</tt> via the specified GeometryFactory.</summary>
<param name="factory"></param>
        </member>
<member name="M:topology.geom.Geometry.getGeometryType">
<summary>Returns the name of this object's <code>com.vivid.jts.geom</code> interface.</summary>
<returns>the name of this <code>Geometry</code>s most specific <code>topology.geom</code> interface</returns>
        </member>
<member name="M:topology.geom.Geometry.hasNonEmptyElements(Geometry[])">
<summary>Returns true if the array contains any non-empty <code>Geometry</code>s.</summary>
<param name="geometries">an array of <code>Geometry</code>s; no elements may be <code>null</code></param>
<returns><code>true</code> if any of the <code>Geometry</code>s <code>isEmpty</code> methods return <code>false</code></returns>
        </member>
<member name="M:topology.geom.Geometry.hasNullElements(Object[])">
<summary>Returns true if the array contains any <code>null</code> elements.</summary>
<param name="array">an array to validate</param>
<returns><code>true</code> if any of <code>array</code>s elements are <code>null</code></returns>
        </member>
<member name="M:topology.geom.Geometry.getSRID">
<summary>Returns the ID of the Spatial Reference System used by the <code>Geometry</code>.</summary>
<returns>the ID of the coordinate space in which the <code>Geometry</code> is defined.</returns>
        </member>
<member name="M:topology.geom.Geometry.setSRID(System.Int32)">
<summary>Sets the ID of the Spatial Reference System used by the <code>Geometry</code>.</summary>
        </member>
<member name="M:topology.geom.Geometry.getFactory">
<summary>Gets the factory which contains the context in which this geometry was created.</summary>
<returns>the factory for this geometry</returns>
        </member>
<member name="M:topology.geom.Geometry.getUserData">
<summary>Gets the user data object for this geometry, if any.</summary>
<returns>the user data object, or <code>null</code> if none set</returns>
        </member>
<member name="M:topology.geom.Geometry.getNumGeometries">
<summary>Returns the number of {@link Geometry}s in a {@link GeometryCollection} (or 1, if the geometry is not a collection).</summary>
<returns>the number of geometries contained in this geometry</returns>
        </member>
<member name="M:topology.geom.Geometry.getGeometryN(System.Int32)">
<summary>Returns an element {@link Geometry} from a {@link GeometryCollection} (or <code>this</code>, if the geometry is not a collection).</summary>
<param name="n">the index of the geometry element</param>
<returns>the n'th geometry contained in this geometry</returns>
        </member>
<member name="M:topology.geom.Geometry.setUserData(Object)">
<summary>A simple scheme for applications to add their own custom data to a Geometry.</summary>
<param name="userData">an object, the semantics for which are defined by the application using this Geometry</param>
        </member>
<member name="M:topology.geom.Geometry.getPrecisionModel">
<summary>Returns the <code>PrecisionModel</code> used by the <code>Geometry</code>.</summary>
<returns>the specification of the grid of allowable points, for this <code>Geometry</code> and all other <code>Geometry</code>s</returns>
        </member>
<member name="M:topology.geom.Geometry.getCoordinate">
<summary>Returns a vertex of this <code>Geometry</code>.</summary>
<returns>a {@link Coordinate} which is a vertex of this <code>Geometry</code>. Returns <code>null</code> if this Geometry is empty</returns>
        </member>
<member name="M:topology.geom.Geometry.getCoordinates">
<summary>Returns this <code>Geometry</code> s vertices.</summary>
<returns>the vertices of this <code>Geometry</code></returns>
        </member>
<member name="M:topology.geom.Geometry.getNumPoints">
<summary>Returns the count of this <code>Geometry</code>s vertices.</summary>
<returns>the number of vertices in this <code>Geometry</code></returns>
        </member>
<member name="M:topology.geom.Geometry.isSimple">
	<summary>Tests whether this {@link Geometry} is simple.</summary>
	<returns><code>true</code> if this <code>Geometry</code> has any points of self-tangency, self-intersection or other anomalous points</returns>
	<seealso cref="M:topology.geom.Geometry.isValid"/>
</member>
<member name="M:topology.geom.Geometry.isValid">
	<summary>Tests the validity of this <code>Geometry</code>.</summary>
	<returns><code>true</code> if this <code>Geometry</code> is valid</returns>
	<seealso cref="T:topology.operation.valid.IsValidOp"/>
</member>
<member name="M:topology.geom.Geometry.isEmpty">
<summary>Returns whether or not the set of points in this <code>Geometry</code> is empty.</summary>
<returns><code>true</code> if this <code>Geometry</code> equals the empty geometry</returns>
        </member>
<member name="M:topology.geom.Geometry.distance(Geometry)">
<summary>Returns the minimum distance between this <code>Geometry</code> and the <code>Geometry</code> g</summary>
<param name="g">the <code>Geometry</code> from which to compute the distance</param>
        </member>
<member name="M:topology.geom.Geometry.isWithinDistance(Geometry,System.Double)">
<summary>Tests whether the distance from this <code>Geometry</code> to another is less than or equal to a specified value.</summary>
<param name="geom">the Geometry to check the distance to</param>
<param name="distance">the distance value to compare</param>
<returns><code>true</code> if the geometries are less than <code>distance</code> apart.</returns>
        </member>
<member name="M:topology.geom.Geometry.getArea">
<summary>Returns the area of this <code>Geometry</code>.</summary>
<returns>the area of the Geometry</returns>
        </member>
<member name="M:topology.geom.Geometry.getLength">
<summary>Returns the length of this <code>Geometry</code>.</summary>
<returns>the length of the Geometry</returns>
        </member>
<member name="M:topology.geom.Geometry.getCentroid">
<summary>Computes the centroid of this <code>Geometry</code>.</summary>
<returns>a {@link Point} which is the centroid of this Geometry</returns>
        </member>
<member name="M:topology.geom.Geometry.getInteriorPoint">
<summary>Computes an interior point of this <code>Geometry</code>.</summary>
<returns>a {@link Point} which is in the interior of this Geometry</returns>
        </member>
<member name="M:topology.geom.Geometry.getDimension">
<summary>Returns the dimension of this <code>Geometry</code>.</summary>
<returns>the dimension of the class implementing this interface, whether or not this object is the empty geometry</returns>
        </member>
<member name="M:topology.geom.Geometry.getBoundary">
<summary>Returns the boundary, or an empty geometry of appropriate dimension if this <code>Geometry</code>  is empty.</summary>
<returns>the closure of the combinatorial boundary of this <code>Geometry</code></returns>
        </member>
<member name="M:topology.geom.Geometry.getBoundaryDimension">
<summary>Returns the dimension of this <code>Geometry</code>s inherent boundary.</summary>
<returns>the dimension of the boundary of the class implementing this interface, whether or not this object is the empty geometry. Returns <code>Dimension.FALSE</code> if the boundary is the empty geometry.</returns>
        </member>
<member name="M:topology.geom.Geometry.getEnvelope">
<summary>Returns this <code>Geometry</code>s bounding box.</summary>
<returns>an empty <code>Point</code> (for empty <code>Geometry</code>s), a <code>Point</code> (for <code>Point</code>s) or a <code>Polygon</code> (in all other cases)</returns>
        </member>
<member name="M:topology.geom.Geometry.getEnvelopeInternal">
<summary>Returns the minimum and maximum x and y values in this <code>Geometry</code> , or a null <code>Envelope</code> if this <code>Geometry</code> is empty.</summary>
<returns>this <code>Geometry</code>s bounding box; if the <code>Geometry</code> is empty, <code>Envelope#isNull</code> will return <code>true</code></returns>
        </member>
<member name="M:topology.geom.Geometry.geometryChanged">
<summary>Notifies this Geometry that its Coordinates have been changed by an external party (using a CoordinateFilter, for example).</summary>
        </member>
<member name="M:topology.geom.Geometry.geometryChangedAction">
	<summary>Notifies this Geometry that its Coordinates have been changed by an external party.</summary>
	<seealso cref="!:#apply(GeometryComponentFilter)"/>
</member>
<member name="M:topology.geom.Geometry.disjoint(Geometry)">
	<summary>Returns <code>true</code> if this geometry is disjoint to the specified geometry.</summary>
	<param name="g">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
	<returns><code>true</code> if the two <code>Geometry</code>s are disjoint</returns>
	<seealso cref="M:topology.geom.Geometry.intersects(topology.geom.Geometry g)"/>
</member>
<member name="M:topology.geom.Geometry.touches(Geometry)">
<summary>Returns <code>true</code> if this geometry touches the specified geometry.</summary>
<param name="g">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
<returns><code>true</code> if the two <code>Geometry</code>s touch; Returns <code>false</code> if both <code>Geometry</code>s are points</returns>
        </member>
<member name="M:topology.geom.Geometry.intersects(Geometry)">
	<summary>Returns <code>true</code> if this geometry intersects the specified geometry.</summary>
	<param name="g">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
	<returns><code>true</code> if the two <code>Geometry</code>s intersect</returns>
	<seealso cref="M:topology.geom.Geometry.disjoint(topology.geom.Geometry g)"/>
</member>
<member name="M:topology.geom.Geometry.crosses(Geometry)">
<summary>Returns <code>true</code> if this geometry crosses the specified geometry.</summary>
<param name="g">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
<returns><code>true</code> if the two <code>Geometry</code>s cross.</returns>
        </member>
<member name="M:topology.geom.Geometry.within(Geometry)">
	<summary>Returns <code>true</code> if this geometry is within the specified geometry.</summary>
	<param name="g">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
	<returns><code>true</code> if this <code>Geometry</code> is within <code>other</code></returns>
	<seealso cref="M:topology.geom.Geometry.contains(topology.geom.Geometry g)"/>
</member>
<member name="M:topology.geom.Geometry.contains(Geometry)">
	<summary>Returns <code>true</code> if this geometry contains the specified geometry.</summary>
	<param name="g">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
	<returns><code>true</code> if this <code>Geometry</code> contains <code>g</code></returns>
	<seealso cref="M:topology.geom.Geometry.within(topology.geom.Geometry g)"/>
</member>
<member name="M:topology.geom.Geometry.overlaps(Geometry)">
<summary>Returns <code>true</code> if this geometry overlaps the specified geometry.</summary>
<param name="g">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
<returns><code>true</code> if the two <code>Geometry</code>s overlap.</returns>
        </member>
<member name="M:topology.geom.Geometry.covers(Geometry)">
	<summary>Returns <code>true</code> if this geometry covers the specified geometry.</summary>
	<param name="g">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
	<returns><code>true</code> if this <code>Geometry</code> covers <code>g</code></returns>
	<seealso cref="M:topology.geom.Geometry.contains(topology.geom.Geometry g)"/>
	<seealso cref="M:topology.geom.Geometry.coveredBy(topology.geom.Geometry g)"/>
</member>
<member name="M:topology.geom.Geometry.coveredBy(Geometry)">
	<summary>Returns <code>true</code> if this geometry is covered by the specified geometry.</summary>
	<param name="g">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
	<returns><code>true</code> if this <code>Geometry</code> is covered by <code>g</code></returns>
	<seealso cref="M:topology.geom.Geometry.within(topology.geom.Geometry g)"/>
	<seealso cref="M:topology.geom.Geometry.covers(topology.geom.Geometry g)"/>
</member>
<member name="M:topology.geom.Geometry.relate(Geometry,String)">
	<summary>Returns <code>true</code> if the elements in the DE-9IM {@link IntersectionMatrix} for the two <code>Geometry</code>s match the elements in <code>intersectionPattern</code>.</summary>
	<param name="other">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
	<param name="intersectionPattern">the pattern against which to check the intersection matrix for the two <code>Geometry</code>s</param>
	<returns><code>true</code> if the DE-9IM intersection matrix for the two <code>Geometry</code>s match <code>intersectionPattern</code></returns>
	<seealso cref="T:topology.geom.IntersectionMatrix"/>
</member>
<member name="M:topology.geom.Geometry.relate(Geometry)">
<summary>Returns the DE-9IM {@link IntersectionMatrix} for the two <code>Geometry</code>s.</summary>
<param name="other">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
<returns>an {@link IntersectionMatrix} describing the intersections of the interiors, boundaries and exteriors of the two <code>Geometry</code>s</returns>
        </member>
<member name="M:topology.geom.Geometry.equals(Geometry)">
<summary>Returns <code>true</code> if this geometry is equal to the specified geometry.</summary>
<param name="other">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
<returns><code>true</code> if the two <code>Geometry</code>s are equal</returns>
        </member>
<member name="M:topology.geom.Geometry.toText">
<summary>Returns the Well-known Text representation of this <code>Geometry</code>.</summary>
<returns>the Well-known Text representation of this <code>Geometry</code></returns>
        </member>
<member name="M:topology.geom.Geometry.buffer(System.Double)">
	<summary>Computes a buffer area around this geometry having the given width.</summary>
	<param name="distance">the width of the buffer (may be positive, negative or 0)</param>
	<returns>an area geometry representing the buffer region</returns>
	<seealso cref="M:topology.geom.Geometry.buffer(System.Double distance,System.Int32 quadrantSegments)"/>
	<seealso cref="M:topology.geom.Geometry.buffer(System.Double distance,System.Int32 quadrantSegments,System.Int32 endCapStyle)"/>
</member>
<member name="M:topology.geom.Geometry.buffer(System.Double,System.Int32)">
	<summary>Computes a buffer area around this geometry having the given width and with a specified accuracy of approximation for circular arcs.</summary>
	<param name="distance">the width of the buffer (may be positive, negative or 0)</param>
	<param name="quadrantSegments">the number of line segments used to represent a quadrant of a circle</param>
	<returns>an area geometry representing the buffer region</returns>
	<seealso cref="M:topology.geom.Geometry.buffer(System.Double distance)"/>
	<seealso cref="M:topology.geom.Geometry.buffer(System.Double distance,System.Int32 quadrantSegments,System.Int32 endCapStyle)"/>
</member>
<member name="M:topology.geom.Geometry.buffer(System.Double,System.Int32,System.Int32)">
	<summary>Computes a buffer area around this geometry having the given width and with a specified accuracy of approximation for circular arcs, and using a specified end cap style.</summary>
	<param name="distance">the width of the buffer (may be positive, negative or 0)</param>
	<param name="quadrantSegments">the number of line segments used to represent a quadrant of a circle</param>
	<param name="endCapStyle">the end cap style to use</param>
	<returns>an area geometry representing the buffer region</returns>
	<seealso cref="M:topology.geom.Geometry.buffer(System.Double distance)"/>
	<seealso cref="M:topology.geom.Geometry.buffer(System.Double distance,System.Int32 quadrantSegments)"/>
	<seealso cref="T:topology.operation.buffer.BufferOp"/>
</member>
<member name="M:topology.geom.Geometry.convexHull">
<summary>Computes the smallest convex <code>Polygon</code> that contains all the points in the <code>Geometry</code>.</summary>
<returns>the minimum-area convex polygon containing this <code>Geometry</code>' s points</returns>
        </member>
<member name="M:topology.geom.Geometry.intersection(Geometry)">
<summary>Computes a <code>Geometry</code> representing the points shared by this <code>Geometry</code> and <code>other</code>.</summary>
<param name="other">the <code>Geometry</code> with which to compute the intersection</param>
<returns>the points common to the two <code>Geometry</code>s</returns>
        </member>
<member name="M:topology.geom.Geometry.union(Geometry)">
<summary>Computes a <code>Geometry</code> representing all the points in this <code>Geometry</code> and <code>other</code>.</summary>
<param name="other">the <code>Geometry</code> with which to compute the union</param>
<returns>a set combining the points of this <code>Geometry</code> and the points of <code>other</code></returns>
        </member>
<member name="M:topology.geom.Geometry.difference(Geometry)">
<summary>Computes a <code>Geometry</code> representing the points making up this <code>Geometry</code> that do not make up <code>other</code>.</summary>
<param name="other">the <code>Geometry</code> with which to compute the difference</param>
<returns>the point set difference of this <code>Geometry</code> with <code>other</code></returns>
        </member>
<member name="M:topology.geom.Geometry.symDifference(Geometry)">
<summary>Returns a set combining the points in this <code>Geometry</code> not in <code>other</code>, and the points in <code>other</code> not in this <code>Geometry</code>.</summary>
<param name="other">the <code>Geometry</code> with which to compute the symmetric difference</param>
<returns>the point set symmetric difference of this <code>Geometry</code> with <code>other</code></returns>
        </member>
<member name="M:topology.geom.Geometry.equalsExact(Geometry,System.Double)">
<summary>Returns true if the two <code>Geometry</code>s are exactly equal, up to a specified distance tolerance.</summary>
<param name="other">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
<returns><code>true</code> if this and the other <code>Geometry</code> are of the same class and have equal internal data.</returns>
        </member>
<member name="M:topology.geom.Geometry.equalsExact(Geometry)">
<summary>Returns true if the two <code>Geometry</code>s are exactly equal.</summary>
<param name="other">the <code>Geometry</code> with which to compare this <code>Geometry</code></param>
<returns><code>true</code> if this and the other <code>Geometry</code> are of the same class and have equal internal data.</returns>
        </member>
<member name="M:topology.geom.Geometry.apply(CoordinateFilter)">
<summary>Performs an operation with or on this <code>Geometry</code>'s coordinates.</summary>
<param name="filter">the filter to apply to this <code>Geometry</code>'s coordinates</param>
        </member>
<member name="M:topology.geom.Geometry.apply(CoordinateSequenceFilter)">
<summary>Performs an operation on the coordinates in this <code>Geometry</code>'s {@link CoordinateSequence}s.</summary>
<param name="filter">the filter to apply</param>
        </member>
<member name="M:topology.geom.Geometry.apply(GeometryFilter)">
<summary>Performs an operation with or on this <code>Geometry</code> and its subelement <code>Geometry</code>s (if any).</summary>
<param name="filter">the filter to apply to this <code>Geometry</code> (and its children, if it is a <code>GeometryCollection</code>).</param>
        </member>
<member name="M:topology.geom.Geometry.apply(GeometryComponentFilter)">
<summary>Performs an operation with or on this Geometry and its component Geometry's.</summary>
<param name="filter">the filter to apply to this <code>Geometry</code>.</param>
        </member>
<member name="M:topology.geom.Geometry.clone">
<summary>Creates and returns a full copy of this {@link Geometry} object (including all coordinates contained by it).</summary>
<returns>a clone of this instance</returns>
        </member>
<member name="M:topology.geom.Geometry.normalize">
<summary>Converts this <code>Geometry</code> to <b>normal form</b> (or <b> canonical form</b> ).</summary>
        </member>
<member name="M:topology.geom.Geometry.compareTo(Object)">
<summary>Returns whether this <code>Geometry</code> is greater than, equal to, or less than another <code>Geometry</code>.</summary>
<param name="o">a <code>Geometry</code> with which to compare this <code>Geometry</code></param>
<returns>a positive number, 0, or a negative number, depending on whether this object is greater than, equal to, or less than <code>o</code>, as defined in "Normal Form For Geometry" in the JTS Technical Specifications</returns>
        </member>
<member name="M:topology.geom.Geometry.compareTo(Object,CoordinateSequenceComparator)">
<summary>Returns whether this <code>Geometry</code> is greater than, equal to, or less than another <code>Geometry</code>, using the given {@link CoordinateSequenceComparator}.</summary>
<param name="o">a <code>Geometry</code> with which to compare this <code>Geometry</code></param>
<param name="comp">a <code>CoordinateSequenceComparator</code></param>
<returns>a positive number, 0, or a negative number, depending on whether this object is greater than, equal to, or less than <code>o</code>, as defined in "Normal Form For Geometry" in the JTS Technical Specifications</returns>
        </member>
<member name="M:topology.geom.Geometry.isEquivalentClass(Geometry)">
<summary>Returns whether the two <code>Geometry</code>s are equal, from the point of view of the <code>equalsExact</code> method.</summary>
<param name="other">the <code>Geometry</code> with which to compare this <code>Geometry</code> for equality</param>
<returns><code>true</code> if the classes of the two <code>Geometry</code> s are considered to be equal by the <code>equalsExact</code> method.</returns>
        </member>
<member name="M:topology.geom.Geometry.checkNotGeometryCollection(Geometry)">
<summary>Throws an exception if <code>g</code>'s class is <code>GeometryCollection</code> .</summary>
<param name="g">the <code>Geometry</code> to check</param>
        </member>
<member name="M:topology.geom.Geometry.computeEnvelopeInternal">
<summary>Returns the minimum and maximum x and y values in this <code>Geometry</code> , or a null <code>Envelope</code> if this <code>Geometry</code> is empty.</summary>
<returns>this <code>Geometry</code>s bounding box; if the <code>Geometry</code> is empty, <code>Envelope#isNull</code> will return <code>true</code></returns>
        </member>
<member name="M:topology.geom.Geometry.compareToSameClass(Object)">
<summary>Returns whether this <code>Geometry</code> is greater than, equal to, or less than another <code>Geometry</code> having the same class.</summary>
<param name="o">a <code>Geometry</code> having the same class as this <code>Geometry</code></param>
<returns>a positive number, 0, or a negative number, depending on whether this object is greater than, equal to, or less than <code>o</code>, as defined in "Normal Form For Geometry" in the JTS Technical Specifications</returns>
        </member>
<member name="M:topology.geom.Geometry.compareToSameClass(Object,CoordinateSequenceComparator)">
<summary>Returns whether this <code>Geometry</code> is greater than, equal to, or less than another <code>Geometry</code> of the same class.</summary>
<param name="o">a <code>Geometry</code> having the same class as this <code>Geometry</code></param>
<param name="comp">a <code>CoordinateSequenceComparator</code></param>
<returns>a positive number, 0, or a negative number, depending on whether this object is greater than, equal to, or less than <code>o</code>, as defined in "Normal Form For Geometry" in the JTS Technical Specifications</returns>
        </member>
<member name="M:topology.geom.Geometry.compare(Collection,Collection)">
<summary>Returns the first non-zero result of <code>compareTo</code> encountered as the two <code>Collection</code>s are iterated over.</summary>
<param name="a">a <code>Collection</code> of <code>Comparable</code>s</param>
<param name="b">a <code>Collection</code> of <code>Comparable</code>s</param>
<returns>the first non-zero <code>compareTo</code> result, if any; otherwise, zero</returns>
        </member>
<member name="T:topology.index.bintree.Node">
<remarks>A node of a {@link Bintree}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.bintree.Node.getNode(Interval)">
<summary>Returns the subnode containing the envelope.</summary>
        </member>
<member name="M:topology.index.bintree.Node.find(Interval)">
<summary>Returns the smallest <i>existing</i> node containing the envelope.</summary>
        </member>
<member name="M:topology.index.bintree.Node.getSubnode(System.Int32)">
<summary>get the subnode for the index.</summary>
        </member>
<member name="T:topology.geomgraph.index.SimpleMCSweepLineIntersector">
<remarks>Finds all intersections in one or two sets of edges, using an x-axis sweepline algorithm in conjunction with Monotone Chains. While still O(n^2) in the worst case, this algorithm drastically improves the average-case time. The use of MonotoneChains as the items in the index seems to offer an improvement in performance over a sweep-line alone.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.index.SimpleMCSweepLineIntersector.#ctor">
<summary>A SimpleMCSweepLineIntersector creates monotone chains from the edges and compares them using a simple sweep-line along the x-axis.</summary>
        </member>
<member name="M:topology.geomgraph.index.SimpleMCSweepLineIntersector.prepareEvents">
<summary>Because Delete Events have a link to their corresponding Insert event, it is possible to compute exactly the range of events which must be compared to a given Insert event object.</summary>
        </member>
<member name="T:topology.algorithm.InteriorPointPoint">
<remarks>Computes a point in the interior of an point geometry. <h2>Algorithm</h2> Find a point which is closest to the centroid of the geometry.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.algorithm.InteriorPointPoint.add(Geometry)">
<summary>Tests the point(s) defined by a Geometry for the best inside point.</summary>
<param name="geom">the geometry to add</param>
        </member>
<member name="T:topology.operation.valid.SimpleNestedRingTester">
<remarks>Tests whether any of a set of {@link LinearRing}s are nested inside another ring in the set, using a simple O(n^2) comparison.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.index.bintree.NodeBase">
<remarks>The base class for nodes in a {@link Bintree}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.bintree.NodeBase.getSubnodeIndex(Interval,System.Double)">
<summary>Returns the index of the subnode that wholely contains the given interval.</summary>
        </member>
<member name="F:topology.index.bintree.NodeBase.subnode">
<summary>subnodes are numbered as follows: 0 | 1</summary>
        </member>
<member name="T:topology.algorithm.LineIntersector">
<remarks>A LineIntersector is an algorithm that can both test whether two line segments intersect and compute the intersection point if they do. The intersection point may be computed in a precise or non-precise manner. Computing it precisely involves rounding it to an integer.  (This assumes that the input coordinates have been made precise by scaling them to an integer grid.)</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.algorithm.LineIntersector.computeEdgeDistance(Coordinate,Coordinate,Coordinate)">
<summary>Computes the "edge distance" of an intersection point p along a segment.</summary>
        </member>
<member name="M:topology.algorithm.LineIntersector.nonRobustComputeEdgeDistance(Coordinate,Coordinate,Coordinate)">
<summary>This function is non-robust, since it may compute the square of large numbers.</summary>
        </member>
<member name="F:topology.algorithm.LineIntersector.intLineIndex">
<summary>The indexes of the endpoints of the intersection lines, in order along the corresponding line</summary>
        </member>
<member name="F:topology.algorithm.LineIntersector.precisionModel">
<summary>If makePrecise is true, computed intersection coordinates will be made precise using Coordinate#makePrecise</summary>
        </member>
<member name="M:topology.algorithm.LineIntersector.setMakePrecise(PrecisionModel)">
<summary>Force computed intersection to be rounded to a given precision model</summary>
<param name="precisionModel"></param>
<obsolete>use <code>setPrecisionModel</code> instead</obsolete>
        </member>
<member name="M:topology.algorithm.LineIntersector.setPrecisionModel(PrecisionModel)">
<summary>Force computed intersection to be rounded to a given precision model.</summary>
<param name="precisionModel"></param>
        </member>
<member name="M:topology.algorithm.LineIntersector.computeIntersection(Coordinate,Coordinate,Coordinate)">
<summary>Compute the intersection of a point p and the line p1-p2.</summary>
        </member>
<member name="M:topology.algorithm.LineIntersector.computeIntersection(Coordinate,Coordinate,Coordinate,Coordinate)">
<summary>Computes the intersection of the lines p1-p2 and p3-p4.</summary>
        </member>
<member name="M:topology.algorithm.LineIntersector.hasIntersection">
<summary>Tests whether the input geometries intersect.</summary>
<returns>true if the input geometries intersect</returns>
        </member>
<member name="M:topology.algorithm.LineIntersector.getIntersectionNum">
<summary>Returns the number of intersection points found.</summary>
        </member>
<member name="M:topology.algorithm.LineIntersector.getIntersection(System.Int32)">
<summary>Returns the intIndex'th intersection point</summary>
<param name="intIndex">is 0 or 1</param>
<returns>the intIndex'th intersection point</returns>
        </member>
<member name="M:topology.algorithm.LineIntersector.isIntersection(Coordinate)">
<summary>Test whether a point is a intersection point of two line segments.</summary>
<returns>true if the input point is one of the intersection points.</returns>
        </member>
<member name="M:topology.algorithm.LineIntersector.isInteriorIntersection">
<summary>Tests whether either intersection point is an interior point of one of the input segments.</summary>
<returns><code>true</code> if either intersection point is in the interior of one of the input segments</returns>
        </member>
<member name="M:topology.algorithm.LineIntersector.isInteriorIntersection(System.Int32)">
<summary>Tests whether either intersection point is an interior point of the specified input segment.</summary>
<returns><code>true</code> if either intersection point is in the interior of the input segment</returns>
        </member>
<member name="M:topology.algorithm.LineIntersector.isProper">
<summary>Tests whether an intersection is proper.</summary>
<returns>true if the intersection is proper</returns>
        </member>
<member name="M:topology.algorithm.LineIntersector.getIntersectionAlongSegment(System.Int32,System.Int32)">
<summary>Computes the intIndex'th intersection point in the direction of a specified input line segment</summary>
<param name="segmentIndex">is 0 or 1</param>
<param name="intIndex">is 0 or 1</param>
<returns>the intIndex'th intersection point in the direction of the specified input line segment</returns>
        </member>
<member name="M:topology.algorithm.LineIntersector.getIndexAlongSegment(System.Int32,System.Int32)">
<summary>Computes the index of the intIndex'th intersection point in the direction of a specified input line segment</summary>
<param name="segmentIndex">is 0 or 1</param>
<param name="intIndex">is 0 or 1</param>
<returns>the index of the intersection point along the segment (0 or 1)</returns>
        </member>
<member name="M:topology.algorithm.LineIntersector.getEdgeDistance(System.Int32,System.Int32)">
<summary>Computes the "edge distance" of an intersection point along the specified input line segment.</summary>
<param name="segmentIndex">is 0 or 1</param>
<param name="intIndex">is 0 or 1</param>
<returns>the edge distance of the intersection point</returns>
        </member>
<member name="T:topology.index.strtree.Interval">
	<remarks>A contiguous portion of 1D-space. Used internally by SIRtree.</remarks>
	<seealso cref="T:topology.index.strtree.SIRtree"/>
	<version>1.7</version>
</member>
<member name="M:topology.index.strtree.Interval.expandToInclude(Interval)">
<returns>this</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.valid.ConsistentAreaTester -->
<member name="M:topology.operation.valid.ConsistentAreaTester.#ctor(GeometryGraph)">
<summary>Creates a new tester for consistent areas.</summary>
<param name="geomGraph">the topology graph of the area geometry</param>
        </member>
<member name="M:topology.operation.valid.ConsistentAreaTester.getInvalidPoint">
<returns>the intersection point, or <code>null</code> if none was found</returns>
        </member>
<member name="M:topology.operation.valid.ConsistentAreaTester.isNodeConsistentArea">
<summary>Check all nodes to see if their labels are consistent with area topology.</summary>
<returns><code>true</code> if this area has a consistent node labelling</returns>
        </member>
<member name="M:topology.operation.valid.ConsistentAreaTester.isNodeEdgeAreaLabelsConsistent">
<summary>Check all nodes to see if their labels are consistent.</summary>
<returns><code>true</code> if the edge area labels are consistent at this node</returns>
        </member>
<member name="M:topology.operation.valid.ConsistentAreaTester.hasDuplicateRings">
<summary>Checks for two duplicate rings in an area.</summary>
<returns>true if this area Geometry is topologically consistent but has two duplicate rings</returns>
        </member>
<member name="T:topology.geom.util.PolygonExtracter">
<remarks>Extracts all the 2-dimensional ({@link Polygon}) components from a {@link Geometry}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.util.PolygonExtracter.getPolygons(Geometry)">
<summary>Returns the Polygon components from a single geometry.</summary>
        </member>
<member name="M:topology.geom.util.PolygonExtracter.#ctor(List)">
<summary>Constructs a PolygonExtracterFilter with a list in which to store Polygons found.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.buffer.BufferOp -->
<member name="F:topology.operation.buffer.BufferOp.CAP_ROUND">
<summary>Specifies a round line buffer end cap style.</summary>
        </member>
<member name="F:topology.operation.buffer.BufferOp.CAP_BUTT">
<summary>Specifies a butt (or flat) line buffer end cap style.</summary>
        </member>
<member name="F:topology.operation.buffer.BufferOp.CAP_SQUARE">
<summary>Specifies a square line buffer end cap style.</summary>
        </member>
<member name="M:topology.operation.buffer.BufferOp.precisionScaleFactor(Geometry,System.Double,System.Int32)">
<summary>Compute a scale factor to limit the precision of a given combination of Geometry and buffer distance.</summary>
<param name="g">the Geometry being buffered</param>
<param name="distance">the buffer distance</param>
<param name="maxPrecisionDigits">the max # of digits that should be allowed by the precision determined by the computed scale factor</param>
<returns>a scale factor for the buffer computation</returns>
        </member>
<member name="M:topology.operation.buffer.BufferOp.bufferOp(Geometry,System.Double)">
<summary>Computes the buffer of a geometry for a given buffer distance.</summary>
<param name="g">the geometry to buffer</param>
<param name="distance">the buffer distance</param>
<returns>the buffer of the input geometry</returns>
        </member>
<member name="M:topology.operation.buffer.BufferOp.bufferOp(Geometry,System.Double,System.Int32)">
<summary>Comutes the buffer for a geometry for a given buffer distance and accuracy of approximation.</summary>
<param name="g">the geometry to buffer</param>
<param name="distance">the buffer distance</param>
<param name="quadrantSegments">the number of segments used to approximate a quarter circle</param>
<returns>the buffer of the input geometry</returns>
        </member>
<member name="M:topology.operation.buffer.BufferOp.bufferOp(Geometry,System.Double,System.Int32,System.Int32)">
<summary>Comutes the buffer for a geometry for a given buffer distance and accuracy of approximation.</summary>
<param name="g">the geometry to buffer</param>
<param name="distance">the buffer distance</param>
<param name="quadrantSegments">the number of segments used to approximate a quarter circle</param>
<param name="endCapStyle">the end cap style to use</param>
<returns>the buffer of the input geometry</returns>
        </member>
<member name="M:topology.operation.buffer.BufferOp.#ctor(Geometry)">
<summary>Initializes a buffer computation for the given geometry</summary>
<param name="g">the geometry to buffer</param>
        </member>
<member name="M:topology.operation.buffer.BufferOp.setEndCapStyle(System.Int32)">
<summary>Specifies the end cap style of the generated buffer.</summary>
<param name="endCapStyle">the end cap style to specify</param>
        </member>
<member name="M:topology.operation.buffer.BufferOp.setQuadrantSegments(System.Int32)">
<summary>Sets the number of segments used to approximate a angle fillet</summary>
<param name="quadrantSegments">the number of segments in a fillet for a quadrant</param>
        </member>
<member name="M:topology.operation.buffer.BufferOp.getResultGeometry(System.Double)">
<summary>Returns the buffer computed for a geometry for a given buffer distance.</summary>
<param name="distance">the buffer distance</param>
<returns>the buffer of the input geometry</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.buffer.BufferBuilder -->
<member name="M:topology.operation.buffer.BufferBuilder.depthDelta(Label)">
<summary>Compute the change in depth as an edge is crossed from R to L</summary>
        </member>
<member name="M:topology.operation.buffer.BufferBuilder.#ctor">
<summary>Creates a new BufferBuilder</summary>
        </member>
<member name="M:topology.operation.buffer.BufferBuilder.setQuadrantSegments(System.Int32)">
<summary>Sets the number of segments used to approximate a angle fillet</summary>
<param name="quadrantSegments">the number of segments in a fillet for a quadrant</param>
        </member>
<member name="M:topology.operation.buffer.BufferBuilder.setWorkingPrecisionModel(PrecisionModel)">
<summary>Sets the precision model to use during the curve computation and noding, if it is different to the precision model of the Geometry.</summary>
<param name="pm">the precision model to use</param>
        </member>
<member name="M:topology.operation.buffer.BufferBuilder.setNoder(Noder)">
<summary>Sets the {@link Noder} to use during noding.</summary>
<param name="noder">the noder to use</param>
        </member>
<member name="M:topology.operation.buffer.BufferBuilder.insertEdge(Edge)">
<summary>Inserted edges are checked to see if an identical edge already exists.</summary>
        </member>
<member name="M:topology.operation.buffer.BufferBuilder.buildSubgraphs(List,PolygonBuilder)">
<summary>Completes the building of the input subgraphs by depth-labelling them, and adds them to the PolygonBuilder.</summary>
<param name="subgraphList">the subgraphs to build</param>
<param name="polyBuilder">the PolygonBuilder which will build the final polygons</param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.util.AffineTransformation -->
<member name="M:topology.geom.util.AffineTransformation.reflectionInstance(System.Double,System.Double,System.Double,System.Double)">
<summary>Creates a transformation for a reflection about the line (x0,y0) - (x1,y1).</summary>
<param name="x0">the x-ordinate of a point on the reflection line</param>
<param name="y0">the y-ordinate of a point on the reflection line</param>
<param name="x1">the x-ordinate of a another point on the reflection line</param>
<param name="y1">the y-ordinate of a another point on the reflection line</param>
<returns>a transformation for the reflection</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.reflectionInstance(System.Double,System.Double)">
<summary>Creates a transformation for a reflection about the line (0,0) - (x,y).</summary>
<param name="x">the x-ordinate of a point on the reflection line</param>
<param name="y">the y-ordinate of a point on the reflection line</param>
<returns>a transformation for the reflection</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.rotationInstance(System.Double)">
<summary>Creates a transformation for a rotation about the origin by an angle <i>theta</i>.</summary>
<param name="theta">the rotation angle, in radians</param>
<returns>a transformation for the rotation</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.rotationInstance(System.Double,System.Double)">
<summary>Creates a transformation for a rotation by an angle <i>theta</i>, specified by the sine and cosine of the angle.</summary>
<param name="sinTheta">the sine of the rotation angle</param>
<param name="cosTheta">the cosine of the rotation angle</param>
<returns>a transformation for the rotation</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.#ctor">
<summary>Constructs a new identity transformation</summary>
        </member>
<member name="M:topology.geom.util.AffineTransformation.#ctor(System.Double[])">
<summary>Constructs a new transformation whose matrix has the specified values.</summary>
<param name="matrix">an array containing the 6 values { m00, m01, m02, m10, m11, m12 }</param>
        </member>
<member name="M:topology.geom.util.AffineTransformation.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
<summary>Constructs a new transformation whose matrix has the specified values.</summary>
<param name="m00">the entry for the [0, 0] element in the transformation matrix</param>
<param name="m01">the entry for the [0, 1] element in the transformation matrix</param>
<param name="m02">the entry for the [0, 2] element in the transformation matrix</param>
<param name="m10">the entry for the [1, 0] element in the transformation matrix</param>
<param name="m11">the entry for the [1, 1] element in the transformation matrix</param>
<param name="m12">the entry for the [1, 2] element in the transformation matrix</param>
        </member>
<member name="M:topology.geom.util.AffineTransformation.#ctor(AffineTransformation)">
<summary>Constructs a transformation which is a copy of the given one.</summary>
<param name="trans">the transformation to copy</param>
        </member>
<member name="M:topology.geom.util.AffineTransformation.#ctor(Coordinate,Coordinate,Coordinate,Coordinate,Coordinate,Coordinate)">
<summary>Constructs a transformation which maps the given source points into the given destination points.</summary>
<param name="src0">source point 0</param>
<param name="src1">source point 1</param>
<param name="src2">source point 2</param>
<param name="dest0">the mapped point for source point 0</param>
<param name="dest1">the mapped point for source point 1</param>
<param name="dest2">the mapped point for source point 2</param>
        </member>
<member name="M:topology.geom.util.AffineTransformation.setToIdentity">
<summary>Sets this transformation to be the identity transformation.</summary>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.setTransformation(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
<summary>Sets this transformation's matrix to have the given values.</summary>
<param name="m00">the entry for the [0, 0] element in the transformation matrix</param>
<param name="m01">the entry for the [0, 1] element in the transformation matrix</param>
<param name="m02">the entry for the [0, 2] element in the transformation matrix</param>
<param name="m10">the entry for the [1, 0] element in the transformation matrix</param>
<param name="m11">the entry for the [1, 1] element in the transformation matrix</param>
<param name="m12">the entry for the [1, 2] element in the transformation matrix</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.setTransformation(AffineTransformation)">
<summary>Sets this transformation to be a copy of the given one</summary>
<param name="trans">a transformation to copy</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.getMatrixEntries">
<summary>Gets an array containing the entries of the transformation matrix.</summary>
<returns>an array of length 6</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.getDeterminant">
	<summary>Computes the determinant of the transformation matrix.</summary>
	<returns>the determinant of the transformation</returns>
	<seealso cref="M:topology.geom.util.AffineTransformation.getInverse"/>
</member>
<member name="M:topology.geom.util.AffineTransformation.getInverse">
	<summary>Computes the inverse of this transformation, if one exists.</summary>
	<returns>a new inverse transformation</returns>
	<seealso cref="M:topology.geom.util.AffineTransformation.getDeterminant"/>
</member>
<member name="M:topology.geom.util.AffineTransformation.setToReflectionBasic(System.Double,System.Double,System.Double,System.Double)">
<summary>Explicitly computes the math for a reflection.</summary>
<param name="x0"></param>
<param name="y0"></param>
<param name="x1"></param>
<param name="y1"></param>
<returns></returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.setToReflection(System.Double,System.Double)">
<summary>Sets this transformation to be a reflection about the line defined by vector (x,y).</summary>
<param name="x">the x-component of the reflection line vector</param>
<param name="y">the y-component of the reflection line vector</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.setToRotation(System.Double)">
<summary>Sets this transformation to be a rotation.</summary>
<param name="theta">the rotation angle, in radians</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.setToRotation(System.Double,System.Double)">
<summary>Sets this transformation to be a rotation by specifying the sin and cos of the rotation angle directly.</summary>
<param name="sinTheta">the sine of the rotation angle</param>
<param name="cosTheta">the cosine of the rotation angle</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.setToScale(System.Double,System.Double)">
<summary>Sets this transformation to be a scaling.</summary>
<param name="xScale">the amount to scale x-ordinates by</param>
<param name="yScale">the amount to scale y-ordinates by</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.setToShear(System.Double,System.Double)">
<summary>Sets this transformation to be a shear.</summary>
<param name="xShear">the x component to shear by</param>
<param name="yShear">the y component to shear by</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.setToTranslation(System.Double,System.Double)">
<summary>Sets this transformation to be a translation.</summary>
<param name="dx">the x component to translate by</param>
<param name="dy">the y component to translate by</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.reflect(System.Double,System.Double,System.Double,System.Double)">
<summary>Updates the value of this transformation to that of a reflection transformation composed with the current value.</summary>
<param name="x0">the x-ordinate of a point on the line to reflect around</param>
<param name="y0">the y-ordinate of a point on the line to reflect around</param>
<param name="x1">the x-ordinate of a point on the line to reflect around</param>
<param name="y1">the y-ordinate of a point on the line to reflect around</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.reflect(System.Double,System.Double)">
<summary>Updates the value of this transformation to that of a reflection transformation composed with the current value.</summary>
<param name="x">the x-ordinate of the line to reflect around</param>
<param name="y">the y-ordinate of the line to reflect around</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.rotate(System.Double)">
<summary>Updates the value of this transformation to that of a rotation transformation composed with the current value.</summary>
<param name="theta">the angle to rotate by</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.rotate(System.Double,System.Double)">
<summary>Updates the value of this transformation to that of a rotation transformation composed with the current value.</summary>
<param name="sinTheta">the sine of the angle to rotate by</param>
<param name="cosTheta">the cosine of the angle to rotate by</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.scale(System.Double,System.Double)">
<summary>Updates the value of this transformation to that of a scale transformation composed with the current value.</summary>
<param name="xScale">the value to scale by in the x direction</param>
<param name="yScale">the value to scale by in the y direction</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.shear(System.Double,System.Double)">
<summary>Updates the value of this transformation to that of a shear transformation composed with the current value.</summary>
<param name="xShear">the value to shear by in the x direction</param>
<param name="yShear">the value to shear by in the y direction</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.translate(System.Double,System.Double)">
<summary>Updates the value of this transformation to that of a translation transformation composed with the current value.</summary>
<param name="x">the value to translate by in the x direction</param>
<param name="y">the value to translate by in the y direction</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.compose(AffineTransformation)">
<summary>Composes the given {@link AffineTransformation} with this transformation.</summary>
<param name="trans">an affine transformation</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.composeBefore(AffineTransformation)">
<summary>Composes this transformation with the given {@link AffineTransformation}.</summary>
<param name="trans">an affine transformation</param>
<returns>this transformation, with an updated matrix</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.transform(Coordinate,Coordinate)">
<summary>Applies this transformation to the <tt>src</tt> coordinate and places the results in the <tt>dest</tt> coordinate (which may be the same as the source).</summary>
<param name="src">the coordinate to transform</param>
<param name="dest">the coordinate to accept the results</param>
<returns>the <tt>dest</tt> coordinate</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.transform(CoordinateSequence,System.Int32)">
<summary>Applies this transformation to the i'th coordinate in the given CoordinateSequence.</summary>
<param name="seq">a <code>CoordinateSequence</code></param>
<param name="i">the index of the coordinate to transform</param>
        </member>
<member name="M:topology.geom.util.AffineTransformation.filter(CoordinateSequence,System.Int32)">
<summary>Transforms the i'th coordinate in the input sequence</summary>
<param name="seq">a <code>CoordinateSequence</code></param>
<param name="i">the index of the coordinate to transform</param>
        </member>
<member name="M:topology.geom.util.AffineTransformation.isDone">
<summary>Reports that this filter should continue to be executed until all coordinates have been transformed.</summary>
<returns>false</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.isIdentity">
<summary>Tests if this transformation is the identity transformation.</summary>
<returns>true if this is the identity transformation</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.equals(Object)">
<summary>Tests if an object is an <tt>AffineTransformation</tt> and has the same matrix as this transformation.</summary>
<param name="obj">an object to test</param>
<returns>true if the given object is equal to this object</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.toString">
<summary>Gets a text representation of this transformation.</summary>
<returns>a string representing this transformation</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformation.clone">
<summary>Clones this transformation</summary>
<returns>a copy of this transformation</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.util.GeometryTransformer -->
<member name="F:topology.geom.util.GeometryTransformer.inputGeom">
<summary>Possible extensions: getParent() method to return immediate parent e.g.</summary>
        </member>
<member name="F:topology.geom.util.GeometryTransformer.pruneEmptyGeometry">
<summary><code>true</code> if empty geometries should not be included in the result</summary>
        </member>
<member name="F:topology.geom.util.GeometryTransformer.preserveGeometryCollectionType">
<summary><code>true</code> if a homogenous collection result from a {@link GeometryCollection} should still be a general GeometryCollection</summary>
        </member>
<member name="F:topology.geom.util.GeometryTransformer.preserveCollections">
<summary><code>true</code> if the output from a collection argument should still be a collection</summary>
        </member>
<member name="F:topology.geom.util.GeometryTransformer.preserveType">
<summary><code>true</code> if the type of the input should be preserved</summary>
        </member>
<member name="M:topology.geom.util.GeometryTransformer.getInputGeometry">
<summary>Utility function to make input geometry available</summary>
<returns>the input geometry</returns>
        </member>
<member name="M:topology.geom.util.GeometryTransformer.createCoordinateSequence(Coordinate[])">
<summary>Convenience method which provides standard way of creating a {@link CoordinateSequence}</summary>
<param name="coords">the coordinate array to copy</param>
<returns>a coordinate sequence for the array</returns>
        </member>
<member name="M:topology.geom.util.GeometryTransformer.copy(CoordinateSequence)">
<summary>Convenience method which provides statndard way of copying {@link CoordinateSequence}s</summary>
<param name="seq">the sequence to copy</param>
<returns>a deep copy of the sequence</returns>
        </member>
<member name="M:topology.geom.util.GeometryTransformer.transformCoordinates(CoordinateSequence,Geometry)">
<summary>Transforms a {@link CoordinateSequence}.</summary>
<param name="coords">the coordinates to transform</param>
<param name="parent">the parent geometry</param>
<returns>the transformed coordinates</returns>
        </member>
<member name="M:topology.geom.util.GeometryTransformer.transformLineString(LineString,Geometry)">
<summary>Transforms a {@link LineString} geometry.</summary>
<param name="geom"></param>
<param name="parent"></param>
<returns></returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.GeometryComponentFilter -->
<member name="M:topology.geom.GeometryComponentFilter.filter(Geometry)">
<summary>Performs an operation with or on <code>geom</code>.</summary>
<param name="geom">a <code>Geometry</code> to which the filter is applied.</param>
        </member>
<member name="T:topology.operation.valid.TopologyValidationError">
<remarks>Contains information about the nature and location of a {@link Geometry} validation error</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.operation.valid.TopologyValidationError.ERROR">
<summary>Not used</summary>
<obsolete></obsolete>
        </member>
<member name="F:topology.operation.valid.TopologyValidationError.REPEATED_POINT">
<summary>No longer used - repeated points are considered valid as per the SFS</summary>
<obsolete></obsolete>
        </member>
<member name="F:topology.operation.valid.TopologyValidationError.HOLE_OUTSIDE_SHELL">
<summary>Indicates that a hole of a polygon lies partially or completely in the exterior of the shell</summary>
        </member>
<member name="F:topology.operation.valid.TopologyValidationError.NESTED_HOLES">
<summary>Indicates that a hole lies in the interior of another hole in the same polygon</summary>
        </member>
<member name="F:topology.operation.valid.TopologyValidationError.DISCONNECTED_INTERIOR">
<summary>Indicates that the interior of a polygon is disjoint (often caused by set of contiguous holes splitting the polygon into two parts)</summary>
        </member>
<member name="F:topology.operation.valid.TopologyValidationError.SELF_INTERSECTION">
<summary>Indicates that two rings of a polygonal geometry intersect</summary>
        </member>
<member name="F:topology.operation.valid.TopologyValidationError.RING_SELF_INTERSECTION">
<summary>Indicates that a ring self-intersects</summary>
        </member>
<member name="F:topology.operation.valid.TopologyValidationError.NESTED_SHELLS">
<summary>Indicates that a polygon component of a MultiPolygon lies inside another polygonal component</summary>
        </member>
<member name="F:topology.operation.valid.TopologyValidationError.DUPLICATE_RINGS">
<summary>Indicates that a polygonal geometry contains two rings which are identical</summary>
        </member>
<!-- Badly formed XML comment ignored for member F:topology.operation.valid.TopologyValidationError.TOO_FEW_POINTS -->
<member name="F:topology.operation.valid.TopologyValidationError.INVALID_COORDINATE">
<summary>Indicates that the <code>X</code> or <code>Y</code> ordinate of a Coordinate is not a valid numeric value (e.g.</summary>
        </member>
<member name="F:topology.operation.valid.TopologyValidationError.RING_NOT_CLOSED">
<summary>Indicates that a ring is not correctly closed (the first and the last coordinate are different)</summary>
        </member>
<member name="M:topology.operation.valid.TopologyValidationError.#ctor(System.Int32,Coordinate)">
<summary>Creates a validation error with the given type and location</summary>
<param name="errorType">the type of the error</param>
<param name="pt">the location of the error</param>
        </member>
<member name="M:topology.operation.valid.TopologyValidationError.#ctor(System.Int32)">
<summary>Creates a validation error of the given type with a null location</summary>
<param name="errorType">the type of the error</param>
        </member>
<member name="M:topology.operation.valid.TopologyValidationError.getCoordinate">
<summary>Returns the location of this error (on the {@link Geometry} containing the error).</summary>
<returns>a {@link Coordinate} on the input geometry</returns>
        </member>
<member name="M:topology.operation.valid.TopologyValidationError.getErrorType">
<summary>Gets the type of this error.</summary>
<returns>the error type</returns>
        </member>
<member name="M:topology.operation.valid.TopologyValidationError.getMessage">
<summary>Gets an error message describing this error.</summary>
<returns></returns>
        </member>
<member name="M:topology.operation.valid.TopologyValidationError.toString">
<summary>Gets a message describing the type and location of this error.</summary>
<returns></returns>
        </member>
<member name="T:topology.operation.relate.EdgeEndBundle">
<remarks>A collection of {@link EdgeEnd}s which obey the following invariant: They originate at the same node and have the same direction.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.relate.EdgeEndBundle.computeLabel(BoundaryNodeRule)">
<summary>This computes the overall edge label for the set of edges in this EdgeStubBundle.</summary>
        </member>
<member name="M:topology.operation.relate.EdgeEndBundle.computeLabelOn(System.Int32,BoundaryNodeRule)">
<summary>Compute the overall ON location for the list of EdgeStubs.</summary>
        </member>
<member name="M:topology.operation.relate.EdgeEndBundle.computeLabelSides(System.Int32)">
<summary>Compute the labelling for each side</summary>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.operation.relate.EdgeEndBundle.computeLabelSide(System.Int32,System.Int32) -->
<member name="M:topology.operation.relate.EdgeEndBundle.updateIM(IntersectionMatrix)">
<summary>Update the IM with the contribution for the computed label for the EdgeStubs.</summary>
        </member>
<member name="T:topology.operation.linemerge.LineMergeDirectedEdge">
<remarks>A {@link topology.planargraph.DirectedEdge} of a {@link LineMergeGraph}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.linemerge.LineMergeDirectedEdge.#ctor(Node,Node,Coordinate,System.Boolean)">
<summary>Constructs a LineMergeDirectedEdge connecting the <code>from</code> node to the <code>to</code> node.</summary>
<param name="directionPt">specifies this DirectedEdge's direction (given by an imaginary line from the <code>from</code> node to <code>directionPt</code>)</param>
<param name="edgeDirection">whether this DirectedEdge's direction is the same as or opposite to that of the parent Edge (if any)</param>
        </member>
<member name="M:topology.operation.linemerge.LineMergeDirectedEdge.getNext">
<summary>Returns the directed edge that starts at this directed edge's end point, or null if there are zero or multiple directed edges starting there.</summary>
<returns></returns>
        </member>
<member name="T:topology.geom.CoordinateList">
<remarks>A list of {@link Coordinate}s, which may be set to prevent repeated coordinates from occuring in the list.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.CoordinateList.#ctor">
<summary>Constructs a new list without any coordinates</summary>
        </member>
<member name="M:topology.geom.CoordinateList.#ctor(Coordinate[])">
<summary>The basic constructor for a CoordinateArray allows repeated points (i.e produces a CoordinateList with exactly the same set of points)</summary>
<param name="coord">the initial coordinates</param>
        </member>
<member name="M:topology.geom.CoordinateList.#ctor(Coordinate[],System.Boolean)">
<summary>Constructs a new list from an array of Coordinates, allowing caller to specify if repeated points are to be removed.</summary>
<param name="coord">the array of coordinates to load into the list</param>
<param name="allowRepeated">if <code>false</code>, repeated points are removed</param>
        </member>
<member name="M:topology.geom.CoordinateList.add(Coordinate[],System.Boolean,System.Boolean)">
<summary>Add an array of coordinates</summary>
<param name="coord">The coordinates</param>
<param name="allowRepeated">if set to false, repeated coordinates are collapsed</param>
<param name="direction">if false, the array is added in reverse order</param>
<returns>true (as by general collection contract)</returns>
        </member>
<member name="M:topology.geom.CoordinateList.add(Coordinate[],System.Boolean)">
<summary>Add an array of coordinates</summary>
<param name="coord">The coordinates</param>
<param name="allowRepeated">if set to false, repeated coordinates are collapsed</param>
<returns>true (as by general collection contract)</returns>
        </member>
<member name="M:topology.geom.CoordinateList.add(Object,System.Boolean)">
<summary>Add a coordinate</summary>
<param name="obj">The coordinate to add</param>
<param name="allowRepeated">if set to false, repeated coordinates are collapsed</param>
<returns>true (as by general collection contract)</returns>
        </member>
<member name="M:topology.geom.CoordinateList.add(Coordinate,System.Boolean)">
<summary>Add a coordinate</summary>
<param name="coord">The coordinates</param>
<param name="allowRepeated">if set to false, repeated coordinates are collapsed</param>
        </member>
<member name="M:topology.geom.CoordinateList.addAll(Collection,System.Boolean)">
<summary>Add an array of coordinates</summary>
<param name="coll">The coordinates</param>
<param name="allowRepeated">if set to false, repeated coordinates are collapsed</param>
<returns>true (as by general collection contract)</returns>
        </member>
<member name="M:topology.geom.CoordinateList.closeRing">
<summary>Ensure this coordList is a ring, by adding the start point if necessary</summary>
        </member>
<member name="M:topology.geom.CoordinateList.toCoordinateArray">
<summary>Returns the Coordinates in this collection.</summary>
<returns>the coordinates</returns>
        </member>
<member name="M:topology.geom.CoordinateList.clone">
<summary>Returns a deep copy of this <tt>CoordinateList</tt> instance.</summary>
<returns>a clone of this <tt>CoordinateList</tt> instance</returns>
        </member>
<member name="T:topology.operation.buffer.RightmostEdgeFinder">
<remarks>A RightmostEdgeFinder find the DirectedEdge in a list which has the highest coordinate, and which is oriented L to R at that point. (I.e. the right side is on the RHS of the edge.)</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.buffer.RightmostEdgeFinder.#ctor(CGAlgorithms)">
<summary>A RightmostEdgeFinder finds the DirectedEdge with the rightmost coordinate.</summary>
        </member>
<member name="T:topology.geomgraph.DirectedEdgeStar">
<remarks>A DirectedEdgeStar is an ordered list of <b>outgoing</b> DirectedEdges around a node. It supports labelling the edges as well as linking the edges to form both MaximalEdgeRings and MinimalEdgeRings.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.geomgraph.DirectedEdgeStar.resultAreaEdgeList">
<summary>A list of all outgoing edges in the result, in CCW order</summary>
        </member>
<member name="M:topology.geomgraph.DirectedEdgeStar.insert(EdgeEnd)">
<summary>Insert a directed edge in the list</summary>
        </member>
<member name="M:topology.geomgraph.DirectedEdgeStar.computeLabelling(GeometryGraph[])">
<summary>Compute the labelling for all dirEdges in this star, as well as the overall labelling</summary>
        </member>
<member name="M:topology.geomgraph.DirectedEdgeStar.mergeSymLabels">
<summary>For each dirEdge in the star, merge the label from the sym dirEdge into the label</summary>
        </member>
<member name="M:topology.geomgraph.DirectedEdgeStar.updateLabelling(Label)">
<summary>Update incomplete dirEdge labels from the labelling for the node</summary>
        </member>
<member name="M:topology.geomgraph.DirectedEdgeStar.linkResultDirectedEdges">
<summary>Traverse the star of DirectedEdges, linking the included edges together.</summary>
        </member>
<member name="M:topology.geomgraph.DirectedEdgeStar.findCoveredLineEdges">
<summary>Traverse the star of edges, maintaing the current location in the result area at this node (if any).</summary>
        </member>
<member name="M:topology.geomgraph.DirectedEdgeStar.computeDepths(System.Int32,System.Int32,System.Int32)">
<summary>Compute the DirectedEdge depths for a subsequence of the edge array.</summary>
<returns>the last depth assigned (from the R side of the last edge visited)</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.algorithm.PointLocator -->
<member name="M:topology.algorithm.PointLocator.intersects(Coordinate,Geometry)">
<summary>Convenience method to test a point for intersection with a Geometry</summary>
<param name="p">the coordinate to test</param>
<param name="geom">the Geometry to test</param>
<returns><code>true</code> if the point is in the interior or boundary of the Geometry</returns>
        </member>
<member name="M:topology.algorithm.PointLocator.locate(Coordinate,Geometry)">
<summary>Computes the topological relationship ({@link Location}) of a single point to a Geometry.</summary>
<returns>the {@link Location} of the point relative to the input Geometry</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.algorithm.MinimumDiameter -->
<member name="M:topology.algorithm.MinimumDiameter.#ctor(Geometry)">
<summary>Compute a minimum diameter for a giver {@link Geometry}.</summary>
<param name="geom">a Geometry</param>
        </member>
<member name="M:topology.algorithm.MinimumDiameter.#ctor(Geometry,System.Boolean)">
<summary>Compute a minimum diameter for a giver {@link Geometry}, with a hint if the Geometry is convex (e.g.</summary>
<param name="geom">a Geometry which is convex</param>
<param name="isConvex"><code>true</code> if the input geometry is convex</param>
        </member>
<member name="M:topology.algorithm.MinimumDiameter.getLength">
<summary>Gets the length of the minimum diameter of the input Geometry</summary>
<returns>the length of the minimum diameter</returns>
        </member>
<member name="M:topology.algorithm.MinimumDiameter.getWidthCoordinate">
<summary>Gets the {@link Coordinate} forming one end of the minimum diameter</summary>
<returns>a coordinate forming one end of the minimum diameter</returns>
        </member>
<member name="M:topology.algorithm.MinimumDiameter.getSupportingSegment">
<summary>Gets the segment forming the base of the minimum diameter</summary>
<returns>the segment forming the base of the minimum diameter</returns>
        </member>
<member name="M:topology.algorithm.MinimumDiameter.getDiameter">
<summary>Gets a {@link LineString} which is a minimum diameter</summary>
<returns>a {@link LineString} which is a minimum diameter</returns>
        </member>
<member name="M:topology.algorithm.MinimumDiameter.computeConvexRingMinDiameter(Coordinate[])">
<summary>Compute the width information for a ring of {@link Coordinate}s.</summary>
<param name="pts"></param>
<returns></returns>
        </member>
<member name="T:topology.index.strtree.Boundable">
<remarks>A spatial object in an AbstractSTRtree.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.strtree.Boundable.getBounds">
	<summary>Returns a representation of space that encloses this Boundable, preferably not much bigger than this Boundable's boundary yet fast to test for intersection with the bounds of other Boundables.</summary>
	<returns>an Envelope (for STRtrees), an Interval (for SIRtrees), or other object (for other subclasses of AbstractSTRtree)</returns>
	<seealso cref="T:topology.index.strtree.AbstractSTRtree.IntersectsOp"/>
</member>
<!-- Badly formed XML comment ignored for member T:topology.geomgraph.PlanarGraph -->
<member name="M:topology.geomgraph.PlanarGraph.linkResultDirectedEdges(Collection)">
<summary>For nodes in the Collection, link the DirectedEdges at the node that are in the result.</summary>
        </member>
<member name="M:topology.geomgraph.PlanarGraph.find(Coordinate)">
<returns>the node if found; null otherwise</returns>
        </member>
<member name="M:topology.geomgraph.PlanarGraph.addEdges(List)">
<summary>Add a set of edges to the graph.</summary>
        </member>
<member name="M:topology.geomgraph.PlanarGraph.linkResultDirectedEdges">
<summary>Link the DirectedEdges at the nodes of the graph.</summary>
        </member>
<member name="M:topology.geomgraph.PlanarGraph.linkAllDirectedEdges">
<summary>Link the DirectedEdges at the nodes of the graph.</summary>
        </member>
<member name="M:topology.geomgraph.PlanarGraph.findEdgeEnd(Edge)">
<summary>Returns the EdgeEnd which has edge e as its base edge (MD 18 Feb 2002 - this should return a pair of edges)</summary>
<returns>the edge, if found <code>null</code> if the edge was not found</returns>
        </member>
<member name="M:topology.geomgraph.PlanarGraph.findEdge(Coordinate,Coordinate)">
<summary>Returns the edge whose first two coordinates are p0 and p1</summary>
<returns>the edge, if found <code>null</code> if the edge was not found</returns>
        </member>
<member name="M:topology.geomgraph.PlanarGraph.findEdgeInSameDirection(Coordinate,Coordinate)">
<summary>Returns the edge which starts at p0 and whose first segment is parallel to p1</summary>
<returns>the edge, if found <code>null</code> if the edge was not found</returns>
        </member>
<member name="M:topology.geomgraph.PlanarGraph.matchInSameDirection(Coordinate,Coordinate,Coordinate,Coordinate)">
<summary>The coordinate pairs match if they define line segments lying in the same direction.</summary>
        </member>
<member name="T:topology.geom.util.ShortCircuitedGeometryVisitor">
<remarks>A visitor to {@link Geometry} elements which can be short-circuited by a given condition</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.simplify.DouglasPeuckerLineSimplifier">
<remarks>Simplifies a linestring (sequence of points) using the standard Douglas-Peucker algorithm.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.simplify.DouglasPeuckerLineSimplifier.setDistanceTolerance(System.Double)">
<summary>Sets the distance tolerance for the simplification.</summary>
<param name="distanceTolerance">the approximation tolerance to use</param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.impl.PackedCoordinateSequence -->
<member name="F:topology.geom.impl.PackedCoordinateSequence.dimension">
<summary>The dimensions of the coordinates hold in the packed array</summary>
        </member>
<member name="F:topology.geom.impl.PackedCoordinateSequence.coordRef">
<summary>A soft reference to the Coordinate[] representation of this sequence.</summary>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.getDimension">
	<seealso cref="M:topology.geom.CoordinateSequence.getDimension"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.getCoordinate(System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getCoordinate(System.Int32 i)"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.getCoordinateCopy(System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getCoordinate(System.Int32 i)"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.getCoordinate(System.Int32,Coordinate)">
	<seealso cref="M:topology.geom.CoordinateSequence.getCoordinate(System.Int32 i)"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.toCoordinateArray">
	<seealso cref="M:topology.geom.CoordinateSequence.toCoordinateArray"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.getCachedCoords">
<returns></returns>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.getX(System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getX(System.Int32 index)"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.getY(System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getY(System.Int32 index)"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.getOrdinate(System.Int32,System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getOrdinate(System.Int32 index,System.Int32 ordinateIndex)"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.setX(System.Int32,System.Double)">
<summary>Sets the first ordinate of a coordinate in this sequence.</summary>
<param name="index">the coordinate index</param>
<param name="value">the new ordinate value</param>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.setY(System.Int32,System.Double)">
<summary>Sets the second ordinate of a coordinate in this sequence.</summary>
<param name="index">the coordinate index</param>
<param name="value">the new ordinate value</param>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.getCoordinateInternal(System.Int32)">
<summary>Returns a Coordinate representation of the specified coordinate, by always building a new Coordinate object</summary>
<param name="index"></param>
<returns></returns>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.clone">
	<seealso cref="M:Object.clone"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.setOrdinate(System.Int32,System.Int32,System.Double)">
<summary>Sets the ordinate of a coordinate in this sequence.</summary>
<param name="index">the coordinate index</param>
<param name="ordinate">the ordinate index in the coordinate, 0 based, smaller than the number of dimensions</param>
<param name="value">the new ordinate value</param>
        </member>
<member name="T:topology.geom.impl.PackedCoordinateSequence.Double">
<remarks>Packed coordinate sequence implementation based on doubles</remarks>
        </member>
<member name="F:topology.geom.impl.PackedCoordinateSequence.Double.coords">
<summary>The packed coordinate array</summary>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Double.#ctor(System.Double[],System.Int32)">
<summary>Builds a new packed coordinate sequence</summary>
<param name="coords"></param>
<param name="dimensions"></param>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Double.#ctor(System.Single[],System.Int32)">
<summary>Builds a new packed coordinate sequence out of a float coordinate array</summary>
<param name="coordinates"></param>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Double.#ctor(Coordinate[],System.Int32)">
<summary>Builds a new packed coordinate sequence out of a coordinate array</summary>
<param name="coordinates"></param>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Double.#ctor(Coordinate[])">
<summary>Builds a new packed coordinate sequence out of a coordinate array</summary>
<param name="coordinates"></param>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Double.#ctor(System.Int32,System.Int32)">
<summary>Builds a new empty packed coordinate sequence of a given size and dimension</summary>
<param name="coordinates"></param>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Double.getCoordinateInternal(System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getCoordinate(System.Int32 i)"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Double.size">
	<seealso cref="M:topology.geom.CoordinateSequence.size"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Double.clone">
	<seealso cref="M:Object.clone"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Double.getOrdinate(System.Int32,System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getOrdinate(System.Int32 index,System.Int32 ordinateIndex)"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Double.setOrdinate(System.Int32,System.Int32,System.Double)">
	<seealso cref="!:topology.geom.PackedCoordinateSequence#setOrdinate(int,"/>
</member>
<member name="T:topology.geom.impl.PackedCoordinateSequence.Float">
<remarks>Packed coordinate sequence implementation based on floats</remarks>
        </member>
<member name="F:topology.geom.impl.PackedCoordinateSequence.Float.coords">
<summary>The packed coordinate array</summary>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.geom.impl.PackedCoordinateSequence.Float.#ctor(System.Single[],System.Int32) -->
<!-- Badly formed XML comment ignored for member M:topology.geom.impl.PackedCoordinateSequence.Float.#ctor(System.Double[],System.Int32) -->
<member name="M:topology.geom.impl.PackedCoordinateSequence.Float.#ctor(Coordinate[],System.Int32)">
<summary>Constructs a packed coordinate sequence out of a coordinate array</summary>
<param name="coordinates"></param>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Float.#ctor(System.Int32,System.Int32)">
<summary>Constructs an empty packed coordinate sequence of a given size and dimension</summary>
<param name="coordinates"></param>
        </member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Float.getCoordinateInternal(System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getCoordinate(System.Int32 i)"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Float.size">
	<seealso cref="M:topology.geom.CoordinateSequence.size"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Float.clone">
	<seealso cref="M:Object.clone"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Float.getOrdinate(System.Int32,System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getOrdinate(System.Int32 index,System.Int32 ordinateIndex)"/>
</member>
<member name="M:topology.geom.impl.PackedCoordinateSequence.Float.setOrdinate(System.Int32,System.Int32,System.Double)">
	<seealso cref="!:topology.geom.PackedCoordinateSequence#setOrdinate(int,"/>
</member>
<!-- Badly formed XML comment ignored for member T:topology.simplify.DouglasPeuckerSimplifier -->
<member name="M:topology.simplify.DouglasPeuckerSimplifier.setDistanceTolerance(System.Double)">
<summary>Sets the distance tolerance for the simplification.</summary>
<param name="distanceTolerance">the approximation tolerance to use</param>
        </member>
<member name="M:topology.simplify.DouglasPeuckerSimplifier.DPTransformer.createValidArea(Geometry)">
<summary>Creates a valid area geometry from one that possibly has bad topology (i.e.</summary>
<param name="roughAreaGeom">an area geometry possibly containing self-intersections</param>
<returns>a valid area geometry</returns>
        </member>
<member name="T:topology.operation.distance.ConnectedElementPointFilter">
<remarks>Extracts a single point from each connected element in a Geometry (e.g. a polygon, linestring or point) and returns them in a list</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.distance.ConnectedElementPointFilter.getCoordinates(Geometry)">
<summary>Returns a list containing a Coordinate from each Polygon, LineString, and Point found inside the specified geometry.</summary>
        </member>
<member name="T:topology.geomgraph.NodeFactory">
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.NodeFactory.createNode(Coordinate)">
<summary>The basic node constructor does not allow for incident edges</summary>
        </member>
<member name="T:topology.io.InStream">
<remarks>A interface for classes providing an input stream of bytes. This interface is similar to the Java {@link InputStream}, but with a narrower interface to make it easier to implement.</remarks>
        </member>
<member name="M:topology.io.InStream.read(System.SByte[])">
<summary>Reads <code>buf.length</code> bytes from the input stream and stores them in the supplied buffer.</summary>
<param name="buf">the buffer to receive the bytes</param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.relate.RelateNodeGraph -->
<member name="M:topology.operation.relate.RelateNodeGraph.computeIntersectionNodes(GeometryGraph,System.Int32)">
<summary>Insert nodes for all intersections on the edges of a Geometry.</summary>
        </member>
<member name="M:topology.operation.relate.RelateNodeGraph.copyNodesAndLabels(GeometryGraph,System.Int32)">
<summary>Copy all nodes from an arg geometry into this graph.</summary>
        </member>
<member name="T:topology.algorithm.BoundaryNodeRule">
	<remarks>An interface for rules which determine whether node points which are in boundaries of lineal geometry components are in the boundary of the parent geometry collection. The SFS specifies a single kind of boundary node rule, the {@link Mod2BoundaryNodeRule} rule. However, other kinds of Boundary Node Rules are appropriate in specific situations (for instance, linear network topology usually follows the {@link EndPointBoundaryNodeRule}.) Some JTS operations allow the BoundaryNodeRule to be specified, and respect this rule when computing the results of the operation.</remarks>
	<author>Martin Davis</author>
	<version>1.7</version>
	<seealso cref="!:RelateOp"/>
	<seealso cref="!:IsSimpleOp"/>
</member>
<member name="F:topology.algorithm.BoundaryNodeRule.MOD2_BOUNDARY_RULE">
<summary>The Mod-2 Boundary Node Rule (as used in the OGC SFS).</summary>
        </member>
<member name="F:topology.algorithm.BoundaryNodeRule.ENDPOINT_BOUNDARY_RULE">
<summary>The Endpoint Boundary Node Rule.</summary>
        </member>
<member name="F:topology.algorithm.BoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE">
<summary>The MultiValent Endpoint Boundary Node Rule.</summary>
        </member>
<member name="F:topology.algorithm.BoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE">
<summary>The Monovalent Endpoint Boundary Node Rule.</summary>
        </member>
<member name="F:topology.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE">
<summary>The Boundary Node Rule specified by the OGC Simple Features Specification, equal to the Mod-2 rule.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.algorithm.BoundaryNodeRule.Mod2BoundaryNodeRule -->
<!-- Badly formed XML comment ignored for member T:topology.algorithm.BoundaryNodeRule.EndPointBoundaryNodeRule -->
<member name="T:topology.algorithm.BoundaryNodeRule.MultiValentEndPointBoundaryNodeRule">
<remarks>A {@link BoundaryNodeRule} which determines that only endpoints with valency greater than 1 are on the boundary. This corresponds to the boundary of a {@link MultiLineString} being all the "attached" endpoints, but not the "unattached" ones.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="T:topology.algorithm.BoundaryNodeRule.MonoValentEndPointBoundaryNodeRule">
<remarks>A {@link BoundaryNodeRule} which determines that only endpoints with valency of exactly 1 are on the boundary. This corresponds to the boundary of a {@link MultiLineString} being all the "unattached" endpoints.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geomgraph.Quadrant -->
<member name="M:topology.geomgraph.Quadrant.quadrant(System.Double,System.Double)">
<summary>Returns the quadrant of a directed line segment (specified as x and y displacements, which cannot both be 0).</summary>
        </member>
<member name="M:topology.geomgraph.Quadrant.quadrant(Coordinate,Coordinate)">
<summary>Returns the quadrant of a directed line segment from p0 to p1.</summary>
        </member>
<member name="M:topology.geomgraph.Quadrant.isOpposite(System.Int32,System.Int32)">
<summary>Returns true if the quadrants are 1 and 3, or 2 and 4</summary>
        </member>
<member name="M:topology.geomgraph.Quadrant.commonHalfPlane(System.Int32,System.Int32)">
<summary>Returns the right-hand quadrant of the halfplane defined by the two quadrants, or -1 if the quadrants are opposite, or the quadrant if they are identical.</summary>
        </member>
<member name="M:topology.geomgraph.Quadrant.isInHalfPlane(System.Int32,System.Int32)">
<summary>Returns whether the given quadrant lies within the given halfplane (specified by its right-hand quadrant).</summary>
        </member>
<member name="M:topology.geomgraph.Quadrant.isNorthern(System.Int32)">
<summary>Returns true if the given quadrant is 0 or 1.</summary>
        </member>
<member name="T:topology.noding.SegmentString">
<remarks>Represents a list of contiguous line segments, and supports noding the segments. The line segments are represented by an array of {@link Coordinate}s. Intended to optimize the noding of contiguous segments by reducing the number of allocated objects. SegmentStrings can carry a context object, which is useful for preserving topological or parentage information. All noded substrings are initialized with the same context object.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.noding.SegmentString.#ctor(Coordinate[],Object)">
<summary>Creates a new segment string from a list of vertices.</summary>
<param name="pts">the vertices of the segment string</param>
<param name="data">the user-defined data of this segment string (may be null)</param>
        </member>
<member name="M:topology.noding.SegmentString.getData">
<summary>Gets the user-defined data for this segment string.</summary>
<returns>the user-defined data</returns>
        </member>
<member name="M:topology.noding.SegmentString.setData(Object)">
<summary>Sets the user-defined data for this segment string.</summary>
<param name="data">an Object containing user-defined data</param>
        </member>
<member name="M:topology.noding.SegmentString.getSegmentOctant(System.Int32)">
<summary>Gets the octant of the segment starting at vertex <code>index</code>.</summary>
<param name="index">the index of the vertex starting the segment.  Must not be the last index in the vertex list</param>
<returns>the octant of the segment at the vertex</returns>
        </member>
<member name="M:topology.noding.SegmentString.addIntersections(LineIntersector,System.Int32,System.Int32)">
<summary>Adds EdgeIntersections for one or both intersections found for a segment of an edge to the edge intersection list.</summary>
        </member>
<member name="M:topology.noding.SegmentString.addIntersection(LineIntersector,System.Int32,System.Int32,System.Int32)">
<summary>Add an SegmentNode for intersection intIndex.</summary>
        </member>
<member name="T:topology.operation.polygonize.PolygonizeEdge">
<remarks>An edge of a polygonization graph.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.algorithm.SimplePointInRing">
<remarks>Tests whether a {@link Coordinate} lies inside a ring, using a linear-time algorithm.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.util.Assert">
<remarks>A utility for making programming assertions.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.util.Assert.isTrue(System.Boolean)">
<summary>Throws an <code>AssertionFailedException</code> if the given assertion is not true.</summary>
<param name="assertion">a condition that is supposed to be true</param>
        </member>
<member name="M:topology.util.Assert.isTrue(System.Boolean,String)">
<summary>Throws an <code>AssertionFailedException</code> with the given message if the given assertion is not true.</summary>
<param name="assertion">a condition that is supposed to be true</param>
<param name="message">a description of the assertion</param>
        </member>
<member name="M:topology.util.Assert.equals(Object,Object)">
<summary>Throws an <code>AssertionFailedException</code> if the given objects are not equal, according to the <code>equals</code> method.</summary>
<param name="expectedValue">the correct value</param>
<param name="actualValue">the value being checked</param>
        </member>
<member name="M:topology.util.Assert.equals(Object,Object,String)">
<summary>Throws an <code>AssertionFailedException</code> with the given message if the given objects are not equal, according to the <code>equals</code> method.</summary>
<param name="expectedValue">the correct value</param>
<param name="actualValue">the value being checked</param>
<param name="message">a description of the assertion</param>
        </member>
<member name="M:topology.util.Assert.shouldNeverReachHere">
<summary>Always throws an <code>AssertionFailedException</code>.</summary>
        </member>
<member name="M:topology.util.Assert.shouldNeverReachHere(String)">
<summary>Always throws an <code>AssertionFailedException</code> with the given message.</summary>
<param name="message">a description of the assertion</param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.noding.Octant -->
<member name="M:topology.noding.Octant.octant(System.Double,System.Double)">
<summary>Returns the octant of a directed line segment (specified as x and y displacements, which cannot both be 0).</summary>
        </member>
<member name="M:topology.noding.Octant.octant(Coordinate,Coordinate)">
<summary>Returns the octant of a directed line segment from p0 to p1.</summary>
        </member>
<member name="T:topology.operation.distance.GeometryLocation">
<remarks>Represents the location of a point on a Geometry. Maintains both the actual point location (which of course may not be exact) as well as information about the component and segment index where the point occurs. Locations inside area Geometrys will not have an associated segment index, so in this case the segment index will have the sentinel value of INSIDE_AREA.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.operation.distance.GeometryLocation.INSIDE_AREA">
<summary>Special value of segment-index for locations inside area geometries.</summary>
        </member>
<member name="M:topology.operation.distance.GeometryLocation.#ctor(Geometry,System.Int32,Coordinate)">
<summary>Constructs a GeometryLocation specifying a point on a geometry, as well as the segment that the point is on (or INSIDE_AREA if the point is not on a segment).</summary>
        </member>
<member name="M:topology.operation.distance.GeometryLocation.#ctor(Geometry,Coordinate)">
<summary>Constructs a GeometryLocation specifying a point inside an area geometry.</summary>
        </member>
<member name="M:topology.operation.distance.GeometryLocation.getGeometryComponent">
<summary>Returns the geometry associated with this location.</summary>
        </member>
<member name="M:topology.operation.distance.GeometryLocation.getSegmentIndex">
<summary>Returns the segment index for this location.</summary>
<returns>the segment index for the location, or INSIDE_AREA</returns>
        </member>
<member name="M:topology.operation.distance.GeometryLocation.getCoordinate">
<summary>Returns the location.</summary>
        </member>
<member name="M:topology.operation.distance.GeometryLocation.isInsideArea">
<summary>Returns whether this GeometryLocation represents a point inside an area geometry.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.index.strtree.AbstractSTRtree -->
<member name="T:topology.index.strtree.AbstractSTRtree.IntersectsOp">
<remarks>A test for intersection between two bounds, necessary because subclasses of AbstractSTRtree have different implementations of bounds.</remarks>
        </member>
<member name="M:topology.index.strtree.AbstractSTRtree.IntersectsOp.intersects(Object,Object)">
<summary>For STRtrees, the bounds will be Envelopes; for SIRtrees, Intervals; for other subclasses of AbstractSTRtree, some other class.</summary>
<param name="aBounds">the bounds of one spatial object</param>
<param name="bBounds">the bounds of another spatial object</param>
<returns>whether the two bounds intersect</returns>
        </member>
<member name="M:topology.index.strtree.AbstractSTRtree.#ctor(System.Int32)">
<summary>Constructs an AbstractSTRtree with the specified maximum number of child nodes that a node may have</summary>
        </member>
<member name="M:topology.index.strtree.AbstractSTRtree.build">
<summary>Creates parent nodes, grandparent nodes, and so forth up to the root node, for the data that has been inserted into the tree.</summary>
        </member>
<member name="M:topology.index.strtree.AbstractSTRtree.createParentBoundables(List,System.Int32)">
<summary>Sorts the childBoundables then divides them into groups of size M, where M is the node capacity.</summary>
        </member>
<member name="M:topology.index.strtree.AbstractSTRtree.createHigherLevels(List,System.Int32)">
<summary>Creates the levels higher than the given level</summary>
<param name="boundablesOfALevel">the level to build on</param>
<param name="level">the level of the Boundables, or -1 if the boundables are item boundables (that is, below level 0)</param>
<returns>the root, which may be a ParentNode or a LeafNode</returns>
        </member>
<member name="M:topology.index.strtree.AbstractSTRtree.getNodeCapacity">
<summary>Returns the maximum number of child nodes that a node may have</summary>
        </member>
<member name="M:topology.index.strtree.AbstractSTRtree.query(Object)">
<summary>Also builds the tree, if necessary.</summary>
        </member>
<member name="M:topology.index.strtree.AbstractSTRtree.query(Object,ItemVisitor)">
<summary>Also builds the tree, if necessary.</summary>
        </member>
<member name="M:topology.index.strtree.AbstractSTRtree.getIntersectsOp">
	<returns>a test for intersection between two bounds, necessary because subclasses of AbstractSTRtree have different implementations of bounds.</returns>
	<seealso cref="T:topology.index.strtree.AbstractSTRtree.IntersectsOp"/>
</member>
<member name="M:topology.index.strtree.AbstractSTRtree.remove(Object,Object)">
<summary>Removes an item from the tree.</summary>
        </member>
<member name="M:topology.index.strtree.AbstractSTRtree.boundablesAtLevel(System.Int32,AbstractNode,Collection)">
<param name="level">-1 to get items</param>
        </member>
<member name="T:topology.geom.DefaultCoordinateSequenceFactory">
<remarks>Creates CoordinateSequences represented as an array of {@link Coordinate}s.</remarks>
<version>1.7</version>
<obsolete>no longer used</obsolete>
        </member>
<member name="M:topology.geom.DefaultCoordinateSequenceFactory.instance">
<summary>Returns the singleton instance of DefaultCoordinateSequenceFactory</summary>
        </member>
<member name="M:topology.geom.DefaultCoordinateSequenceFactory.create(Coordinate[])">
<summary>Returns a DefaultCoordinateSequence based on the given array (the array is not copied).</summary>
<param name="coordinates">the coordinates, which may not be null nor contain null elements</param>
        </member>
<member name="M:topology.geom.DefaultCoordinateSequenceFactory.create(CoordinateSequence)">
	<seealso cref="M:topology.geom.CoordinateSequenceFactory.create(topology.geom.CoordinateSequence coordSeq)"/>
</member>
<member name="M:topology.geom.DefaultCoordinateSequenceFactory.create(System.Int32,System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequenceFactory.create(System.Int32 size,System.Int32 dimension)"/>
</member>
<member name="T:topology.noding.snapround.MCIndexPointSnapper">
<remarks>"Snaps" all {@link SegmentString}s in a {@link SpatialIndex} containing {@link MonotoneChain}s to a given {@link HotPixel}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.noding.snapround.MCIndexPointSnapper.snap(HotPixel,SegmentString,System.Int32)">
<summary>Snaps (nodes) all interacting segments to this hot pixel.</summary>
<param name="hotPixel">the hot pixel to snap to</param>
<param name="parentEdge">the edge containing the vertex, if applicable, or <code>null</code></param>
<param name="vertexIndex">the index of the vertex, if applicable, or -1</param>
<returns><code>true</code> if a node was added for this pixel</returns>
        </member>
<member name="T:topology.util.CoordinateCountFilter">
<remarks>A {@link CoordinateFilter} that counts the total number of coordinates in a <code>Geometry</code>.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.util.CoordinateCountFilter.getCount">
<summary>Returns the result of the filtering.</summary>
<returns>the number of points found by this <code>CoordinateCountFilter</code></returns>
        </member>
<member name="T:topology.geomgraph.NodeMap">
<remarks>A map of nodes, indexed by the coordinate of the node</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.NodeMap.addNode(Coordinate)">
<summary>This method expects that a node has a coordinate value.</summary>
        </member>
<member name="M:topology.geomgraph.NodeMap.add(EdgeEnd)">
<summary>Adds a node for the start point of this EdgeEnd (if one does not already exist in this map).</summary>
        </member>
<member name="M:topology.geomgraph.NodeMap.find(Coordinate)">
<returns>the node if found; null otherwise</returns>
        </member>
<member name="T:topology.geom.util.PointExtracter">
<remarks>Extracts all the 0-dimensional ({@link Point}) components from a {@link Geometry}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.util.PointExtracter.getPoints(Geometry)">
<summary>Returns the Point components from a single geometry.</summary>
        </member>
<member name="M:topology.geom.util.PointExtracter.#ctor(List)">
<summary>Constructs a PointExtracterFilter with a list in which to store Points found.</summary>
        </member>
<member name="T:topology.noding.ScaledNoder">
<remarks>Wraps a {@link Noder} and transforms its input into the integer domain. This is intended for use with Snap-Rounding noders, which typically are only intended to work in the integer domain. Offsets can be provided to increase the number of digits of available precision.</remarks>
<version>1.7</version>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.relate.RelateComputer -->
<member name="M:topology.operation.relate.RelateComputer.copyNodesAndLabels(System.Int32)">
<summary>Copy all nodes from an arg geometry into this graph.</summary>
        </member>
<member name="M:topology.operation.relate.RelateComputer.computeIntersectionNodes(System.Int32)">
<summary>Insert nodes for all intersections on the edges of a Geometry.</summary>
        </member>
<member name="M:topology.operation.relate.RelateComputer.labelIntersectionNodes(System.Int32)">
<summary>For all intersections on the edges of a Geometry, label the corresponding node IF it doesn't already have a label.</summary>
        </member>
<member name="M:topology.operation.relate.RelateComputer.computeDisjointIM(IntersectionMatrix)">
<summary>If the Geometries are disjoint, we need to enter their dimension and boundary dimension in the Ext rows in the IM</summary>
        </member>
<member name="M:topology.operation.relate.RelateComputer.updateIM(IntersectionMatrix)">
<summary>update the IM with the sum of the IMs for each component</summary>
        </member>
<member name="M:topology.operation.relate.RelateComputer.labelIsolatedEdges(System.Int32,System.Int32)">
<summary>Processes isolated edges by computing their labelling and adding them to the isolated edges list.</summary>
        </member>
<member name="M:topology.operation.relate.RelateComputer.labelIsolatedEdge(Edge,System.Int32,Geometry)">
<summary>Label an isolated edge of a graph with its relationship to the target geometry.</summary>
        </member>
<member name="M:topology.operation.relate.RelateComputer.labelIsolatedNodes">
<summary>Isolated nodes are nodes whose labels are incomplete (e.g.</summary>
        </member>
<member name="M:topology.operation.relate.RelateComputer.labelIsolatedNode(Node,System.Int32)">
<summary>Label an isolated node with its relationship to the target geometry.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.GeometryFactory -->
<member name="M:topology.geom.GeometryFactory.#ctor(PrecisionModel,System.Int32,CoordinateSequenceFactory)">
<summary>Constructs a GeometryFactory that generates Geometries having the given PrecisionModel, spatial-reference ID, and CoordinateSequence implementation.</summary>
        </member>
<member name="M:topology.geom.GeometryFactory.#ctor(CoordinateSequenceFactory)">
<summary>Constructs a GeometryFactory that generates Geometries having the given CoordinateSequence implementation, a double-precision floating PrecisionModel and a spatial-reference ID of 0.</summary>
        </member>
<member name="M:topology.geom.GeometryFactory.#ctor(PrecisionModel)">
<summary>Constructs a GeometryFactory that generates Geometries having the given {@link PrecisionModel} and the default CoordinateSequence implementation.</summary>
<param name="precisionModel">the PrecisionModel to use</param>
        </member>
<member name="M:topology.geom.GeometryFactory.#ctor(PrecisionModel,System.Int32)">
<summary>Constructs a GeometryFactory that generates Geometries having the given {@link PrecisionModel} and spatial-reference ID, and the default CoordinateSequence implementation.</summary>
<param name="precisionModel">the PrecisionModel to use</param>
<param name="SRID">the SRID to use</param>
        </member>
<member name="M:topology.geom.GeometryFactory.#ctor">
<summary>Constructs a GeometryFactory that generates Geometries having a floating PrecisionModel and a spatial-reference ID of 0.</summary>
        </member>
<member name="M:topology.geom.GeometryFactory.toPointArray(Collection)">
<summary>Converts the <code>List</code> to an array.</summary>
<param name="points">the <code>List</code> of Points to convert</param>
<returns>the <code>List</code> in array format</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.toGeometryArray(Collection)">
<summary>Converts the <code>List</code> to an array.</summary>
<param name="geometries">the list of <code>Geometry's</code> to convert</param>
<returns>the <code>List</code> in array format</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.toLinearRingArray(Collection)">
<summary>Converts the <code>List</code> to an array.</summary>
<param name="linearRings">the <code>List</code> of LinearRings to convert</param>
<returns>the <code>List</code> in array format</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.toLineStringArray(Collection)">
<summary>Converts the <code>List</code> to an array.</summary>
<param name="lineStrings">the <code>List</code> of LineStrings to convert</param>
<returns>the <code>List</code> in array format</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.toPolygonArray(Collection)">
<summary>Converts the <code>List</code> to an array.</summary>
<param name="polygons">the <code>List</code> of Polygons to convert</param>
<returns>the <code>List</code> in array format</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.toMultiPolygonArray(Collection)">
<summary>Converts the <code>List</code> to an array.</summary>
<param name="multiPolygons">the <code>List</code> of MultiPolygons to convert</param>
<returns>the <code>List</code> in array format</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.toMultiLineStringArray(Collection)">
<summary>Converts the <code>List</code> to an array.</summary>
<param name="multiLineStrings">the <code>List</code> of MultiLineStrings to convert</param>
<returns>the <code>List</code> in array format</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.toMultiPointArray(Collection)">
<summary>Converts the <code>List</code> to an array.</summary>
<param name="multiPoints">the <code>List</code> of MultiPoints to convert</param>
<returns>the <code>List</code> in array format</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.toGeometry(Envelope)">
<summary>If the <code>Envelope</code> is a null <code>Envelope</code>, returns an empty <code>Point</code>.</summary>
<param name="envelope">the <code>Envelope</code> to convert to a <code>Geometry</code></param>
<param name="precisionModel">the specification of the grid of allowable points for the new <code>Geometry</code></param>
<param name="SRID">the ID of the Spatial Reference System used by the <code>Envelope</code></param>
<returns>an empty <code>Point</code> (for null <code>Envelope</code> s), a <code>Point</code> (when min x = max x and min y = max y) or a <code>Polygon</code> (in all other cases)</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.getPrecisionModel">
<summary>Returns the PrecisionModel that Geometries created by this factory will be associated with.</summary>
        </member>
<member name="M:topology.geom.GeometryFactory.createPoint(Coordinate)">
<summary>Creates a Point using the given Coordinate; a null Coordinate will create an empty Geometry.</summary>
        </member>
<member name="M:topology.geom.GeometryFactory.createPoint(CoordinateSequence)">
<summary>Creates a Point using the given CoordinateSequence; a null or empty CoordinateSequence will create an empty Point.</summary>
        </member>
<member name="M:topology.geom.GeometryFactory.createMultiLineString(LineString[])">
<summary>Creates a MultiLineString using the given LineStrings; a null or empty array will create an empty MultiLineString.</summary>
<param name="lineStrings">LineStrings, each of which may be empty but not null</param>
        </member>
<member name="M:topology.geom.GeometryFactory.createGeometryCollection(Geometry[])">
<summary>Creates a GeometryCollection using the given Geometries; a null or empty array will create an empty GeometryCollection.</summary>
<param name="geometries">Geometries, each of which may be empty but not null</param>
        </member>
<member name="M:topology.geom.GeometryFactory.createMultiPolygon(Polygon[])">
<summary>Creates a MultiPolygon using the given Polygons; a null or empty array will create an empty Polygon.</summary>
<param name="polygons">Polygons, each of which may be empty but not null</param>
        </member>
<member name="M:topology.geom.GeometryFactory.createLinearRing(Coordinate[])">
<summary>Creates a LinearRing using the given Coordinates; a null or empty array will create an empty LinearRing.</summary>
<param name="coordinates">an array without null elements, or an empty array, or null</param>
        </member>
<member name="M:topology.geom.GeometryFactory.createLinearRing(CoordinateSequence)">
<summary>Creates a LinearRing using the given CoordinateSequence; a null or empty CoordinateSequence will create an empty LinearRing.</summary>
<param name="coordinates">a CoordinateSequence possibly empty, or null</param>
        </member>
<member name="M:topology.geom.GeometryFactory.createMultiPoint(Point[])">
<summary>Creates a MultiPoint using the given Points.</summary>
<param name="coordinates">an array (without null elements), or an empty array, or <code>null</code></param>
<returns>a MultiPoint object</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.createMultiPoint(Coordinate[])">
<summary>Creates a {@link MultiPoint} using the given {@link Coordinate}s.</summary>
<param name="coordinates">an array (without null elements), or an empty array, or <code>null</code></param>
<returns>a MultiPoint object</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.createMultiPoint(CoordinateSequence)">
<summary>Creates a MultiPoint using the given CoordinateSequence.</summary>
<param name="coordinates">a CoordinateSequence (possibly empty), or <code>null</code></param>
<returns>a MultiPoint object</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.createPolygon(LinearRing,LinearRing[])">
<summary>Constructs a <code>Polygon</code> with the given exterior boundary and interior boundaries.</summary>
<param name="shell">the outer boundary of the new <code>Polygon</code>, or <code>null</code> or an empty <code>LinearRing</code> if the empty geometry is to be created.</param>
<param name="holes">the inner boundaries of the new <code>Polygon</code>, or <code>null</code> or empty <code>LinearRing</code> s if the empty geometry is to be created.</param>
        </member>
<member name="M:topology.geom.GeometryFactory.buildGeometry(Collection)">
<summary>Build an appropriate <code>Geometry</code>, <code>MultiGeometry</code>, or <code>GeometryCollection</code> to contain the <code>Geometry</code>s in it.</summary>
<param name="geomList">the <code>Geometry</code>s to combine</param>
<returns>a <code>Geometry</code> of the "smallest", "most type-specific" class that can contain the elements of <code>geomList</code> .</returns>
        </member>
<member name="M:topology.geom.GeometryFactory.createLineString(Coordinate[])">
<summary>Creates a LineString using the given Coordinates; a null or empty array will create an empty LineString.</summary>
<param name="coordinates">an array without null elements, or an empty array, or null</param>
        </member>
<member name="M:topology.geom.GeometryFactory.createLineString(CoordinateSequence)">
<summary>Creates a LineString using the given CoordinateSequence; a null or empty CoordinateSequence will create an empty LineString.</summary>
<param name="coordinates">a CoordinateSequence possibly empty, or null</param>
        </member>
<member name="M:topology.geom.GeometryFactory.createGeometry(Geometry)">
<returns>a clone of g based on a CoordinateSequence created by this GeometryFactory's CoordinateSequenceFactory</returns>
        </member>
<member name="T:topology.operation.relate.EdgeEndBuilder">
<remarks>Computes the {@link EdgeEnd}s which arise from a noded {@link Edge}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.relate.EdgeEndBuilder.computeEdgeEnds(Edge,List)">
<summary>Creates stub edges for all the intersections in this Edge (if any) and inserts them into the graph.</summary>
        </member>
<member name="M:topology.operation.relate.EdgeEndBuilder.createEdgeEndForPrev(Edge,List,EdgeIntersection,EdgeIntersection)">
<summary>Create a EdgeStub for the edge before the intersection eiCurr.</summary>
        </member>
<member name="M:topology.operation.relate.EdgeEndBuilder.createEdgeEndForNext(Edge,List,EdgeIntersection,EdgeIntersection)">
<summary>Create a StubEdge for the edge after the intersection eiCurr.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.io.WKTReader -->
<member name="M:topology.io.WKTReader.#ctor">
<summary>Creates a reader that creates objects using the default {@link GeometryFactory}.</summary>
        </member>
<member name="M:topology.io.WKTReader.#ctor(GeometryFactory)">
<summary>Creates a reader that creates objects using the given {@link GeometryFactory}.</summary>
<param name="geometryFactory">the factory used to create <code>Geometry</code>s.</param>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.io.WKTReader.read(String) -->
<!-- Badly formed XML comment ignored for member M:topology.io.WKTReader.read(Reader) -->
<member name="M:topology.io.WKTReader.getCoordinates">
<summary>Returns the next array of <code>Coordinate</code>s in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next element returned by the stream should be L_PAREN (the beginning of "(x1 y1, x2 y2, ..., xn yn)") or EMPTY.</param>
<returns>the next array of <code>Coordinate</code>s in the stream, or an empty array if EMPTY is the next element returned by the stream.</returns>
        </member>
<member name="M:topology.io.WKTReader.getNextNumber">
<summary>Parses the next number in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next token must be a number.</param>
<returns>the next number in the stream</returns>
        </member>
<member name="M:topology.io.WKTReader.getNextEmptyOrOpener">
<summary>Returns the next EMPTY or L_PAREN in the stream as uppercase text.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next token must be EMPTY or L_PAREN.</param>
<returns>the next EMPTY or L_PAREN in the stream as uppercase text.</returns>
        </member>
<member name="M:topology.io.WKTReader.getNextCloserOrComma">
<summary>Returns the next R_PAREN or COMMA in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next token must be R_PAREN or COMMA.</param>
<returns>the next R_PAREN or COMMA in the stream</returns>
        </member>
<member name="M:topology.io.WKTReader.getNextCloser">
<summary>Returns the next R_PAREN in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next token must be R_PAREN.</param>
<returns>the next R_PAREN in the stream</returns>
        </member>
<member name="M:topology.io.WKTReader.getNextWord">
<summary>Returns the next word in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next token must be a word.</param>
<returns>the next word in the stream as uppercase text</returns>
        </member>
<member name="M:topology.io.WKTReader.parseError(String)">
<summary>Throws a formatted ParseException for the current token.</summary>
<param name="expected">a description of what was expected</param>
        </member>
<member name="M:topology.io.WKTReader.tokenString">
<summary>Gets a description of the current token</summary>
<returns>a description of the current token</returns>
        </member>
<member name="M:topology.io.WKTReader.readGeometryTaggedText">
<summary>Creates a <code>Geometry</code> using the next token in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next tokens must form a &lt;Geometry Tagged Text&gt;.</param>
<returns>a <code>Geometry</code> specified by the next token in the stream</returns>
        </member>
<member name="M:topology.io.WKTReader.readPointText">
<summary>Creates a <code>Point</code> using the next token in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next tokens must form a &lt;Point Text&gt;.</param>
<returns>a <code>Point</code> specified by the next token in the stream</returns>
        </member>
<member name="M:topology.io.WKTReader.readLineStringText">
<summary>Creates a <code>LineString</code> using the next token in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next tokens must form a &lt;LineString Text&gt;.</param>
<returns>a <code>LineString</code> specified by the next token in the stream</returns>
        </member>
<member name="M:topology.io.WKTReader.readLinearRingText">
<summary>Creates a <code>LinearRing</code> using the next token in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next tokens must form a &lt;LineString Text&gt;.</param>
<returns>a <code>LinearRing</code> specified by the next token in the stream</returns>
        </member>
<member name="M:topology.io.WKTReader.readMultiPointText">
<summary>Creates a <code>MultiPoint</code> using the next token in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next tokens must form a &lt;MultiPoint Text&gt;.</param>
<returns>a <code>MultiPoint</code> specified by the next token in the stream</returns>
        </member>
<member name="M:topology.io.WKTReader.toPoints(Coordinate[])">
<summary>Creates an array of <code>Point</code>s having the given <code>Coordinate</code> s.</summary>
<param name="coordinates">the <code>Coordinate</code>s with which to create the <code>Point</code>s</param>
<returns><code>Point</code>s created using this <code>WKTReader</code> s <code>GeometryFactory</code></returns>
        </member>
<member name="M:topology.io.WKTReader.readPolygonText">
<summary>Creates a <code>Polygon</code> using the next token in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next tokens must form a &lt;Polygon Text&gt;.</param>
<returns>a <code>Polygon</code> specified by the next token in the stream</returns>
        </member>
<member name="M:topology.io.WKTReader.readMultiLineStringText">
<summary>Creates a <code>MultiLineString</code> using the next token in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next tokens must form a &lt;MultiLineString Text&gt;.</param>
<returns>a <code>MultiLineString</code> specified by the next token in the stream</returns>
        </member>
<member name="M:topology.io.WKTReader.readMultiPolygonText">
<summary>Creates a <code>MultiPolygon</code> using the next token in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next tokens must form a &lt;MultiPolygon Text&gt;.</param>
<returns>a <code>MultiPolygon</code> specified by the next token in the stream, or if if the coordinates used to create the <code>Polygon</code> shells and holes do not form closed linestrings.</returns>
        </member>
<member name="M:topology.io.WKTReader.readGeometryCollectionText">
<summary>Creates a <code>GeometryCollection</code> using the next token in the stream.</summary>
<param name="tokenizer">tokenizer over a stream of text in Well-known Text format. The next tokens must form a &lt;GeometryCollection Text&gt;.</param>
<returns>a <code>GeometryCollection</code> specified by the next token in the stream</returns>
        </member>
<member name="T:topology.geom.LinearRing">
<remarks>Models an OGC SFS <code>LinearRing</code>. A LinearRing is a LineString which is both closed and simple. In other words, the first and last coordinate in the ring must be equal, and the interior of the ring must not self-intersect. Either orientation of the ring is allowed.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.LinearRing.#ctor(Coordinate,PrecisionModel,System.Int32)">
<summary>Constructs a <code>LinearRing</code> with the given points.</summary>
<param name="points">points forming a closed and simple linestring, or <code>null</code> or an empty array to create the empty geometry. This array must not contain <code>null</code> elements.</param>
<param name="precisionModel">the specification of the grid of allowable points for this <code>LinearRing</code></param>
<param name="SRID">the ID of the Spatial Reference System used by this <code>LinearRing</code></param>
<obsolete>Use GeometryFactory instead</obsolete>
        </member>
<member name="M:topology.geom.LinearRing.#ctor(Coordinate,GeometryFactory)">
<summary>This method is ONLY used to avoid deprecation warnings.</summary>
<param name="points"></param>
<param name="factory"></param>
        </member>
<member name="M:topology.geom.LinearRing.#ctor(CoordinateSequence,GeometryFactory)">
<summary>Constructs a <code>LinearRing</code> with the vertices specifed by the given {@link CoordinateSequence}.</summary>
<param name="points">a sequence points forming a closed and simple linestring, or <code>null</code> to create the empty geometry.</param>
        </member>
<member name="M:topology.geom.LinearRing.getBoundaryDimension">
<summary>Returns <code>Dimension.FALSE</code>, since by definition LinearRings do not have a boundary.</summary>
<returns>Dimension.FALSE</returns>
        </member>
<member name="M:topology.geom.LinearRing.isSimple">
	<summary>Returns <code>true</code>, since by definition LinearRings are always simple.</summary>
	<returns><code>true</code></returns>
	<seealso cref="M:topology.geom.Geometry.isSimple"/>
</member>
<member name="T:topology.operation.valid.SweeplineNestedRingTester">
<remarks>Tests whether any of a set of {@link LinearRing}s are nested inside another ring in the set, using a {@link SweepLineIndex} index to speed up the comparisons.</remarks>
<version>1.7</version>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.planargraph.Edge -->
<member name="F:topology.planargraph.Edge.dirEdge">
<summary>The two DirectedEdges associated with this Edge.</summary>
        </member>
<member name="M:topology.planargraph.Edge.#ctor">
<summary>Constructs an Edge whose DirectedEdges are not yet set.</summary>
        </member>
<member name="M:topology.planargraph.Edge.#ctor(DirectedEdge,DirectedEdge)">
<summary>Constructs an Edge initialized with the given DirectedEdges, and for each DirectedEdge: sets the Edge, sets the symmetric DirectedEdge, and adds this Edge to its from-Node.</summary>
        </member>
<member name="M:topology.planargraph.Edge.setDirectedEdges(DirectedEdge,DirectedEdge)">
<summary>Initializes this Edge's two DirectedEdges, and for each DirectedEdge: sets the Edge, sets the symmetric DirectedEdge, and adds this Edge to its from-Node.</summary>
        </member>
<member name="M:topology.planargraph.Edge.getDirEdge(System.Int32)">
<summary>Returns one of the DirectedEdges associated with this Edge.</summary>
<param name="i">0 or 1.  0 returns the forward directed edge, 1 returns the reverse</param>
        </member>
<member name="M:topology.planargraph.Edge.getDirEdge(Node)">
<summary>Returns the {@link DirectedEdge} that starts from the given node, or null if the node is not one of the two nodes associated with this Edge.</summary>
        </member>
<member name="M:topology.planargraph.Edge.getOppositeNode(Node)">
<summary>If <code>node</code> is one of the two nodes associated with this Edge, returns the other node; otherwise returns null.</summary>
        </member>
<member name="M:topology.planargraph.Edge.remove">
<summary>Removes this edge from its containing graph.</summary>
        </member>
<member name="M:topology.planargraph.Edge.isRemoved">
<summary>Tests whether this edge has been removed from its containing graph</summary>
<returns><code>true</code> if this edge is removed</returns>
        </member>
<member name="T:topology.index.strtree.SIRtree">
	<remarks>One-dimensional version of an STR-packed R-tree. SIR stands for "Sort-Interval-Recursive". STR-packed R-trees are described in: P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With Application To GIS. Morgan Kaufmann, San Francisco, 2002.</remarks>
	<seealso cref="T:topology.index.strtree.STRtree"/>
	<version>1.7</version>
</member>
<member name="M:topology.index.strtree.SIRtree.#ctor">
<summary>Constructs an SIRtree with the default node capacity.</summary>
        </member>
<member name="M:topology.index.strtree.SIRtree.#ctor(System.Int32)">
<summary>Constructs an SIRtree with the given maximum number of child nodes that a node may have</summary>
        </member>
<member name="M:topology.index.strtree.SIRtree.insert(System.Double,System.Double,Object)">
<summary>Inserts an item having the given bounds into the tree.</summary>
        </member>
<member name="M:topology.index.strtree.SIRtree.query(System.Double)">
<summary>Returns items whose bounds intersect the given value.</summary>
        </member>
<member name="M:topology.index.strtree.SIRtree.query(System.Double,System.Double)">
<summary>Returns items whose bounds intersect the given bounds.</summary>
<param name="x1">possibly equal to x2</param>
        </member>
<member name="T:topology.operation.linemerge.LineMergeEdge">
<remarks>An edge of a {@link LineMergeGraph}. The <code>marked</code> field indicates whether this Edge has been logically deleted from the graph.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.linemerge.LineMergeEdge.#ctor(LineString)">
<summary>Constructs a LineMergeEdge with vertices given by the specified LineString.</summary>
        </member>
<member name="M:topology.operation.linemerge.LineMergeEdge.getLine">
<summary>Returns the LineString specifying the vertices of this edge.</summary>
        </member>
<member name="T:topology.util.Debug">
<remarks>Provides routines to simplify and localize debugging output. Debugging is controlled via a Java system property value. If the system property with the name given in DEBUG_PROPERTY_NAME (currently "jts.debug") has the value "on" or "true" debugging is enabled. Otherwise, debugging is disabled. The system property can be set by adding an option '-Djts_debug=on' to the Java VM commandline.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.util.Debug.main(String[])">
<summary>Prints the status of debugging to <tt>System.out</tt></summary>
<param name="args">the cmd-line arguments (no arguments are required)</param>
        </member>
<member name="T:topology.noding.NodingValidator">
<remarks>Validates that a collection of {@link SegmentString}s is correctly noded. Throws an appropriate exception if an noding error is found.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.noding.NodingValidator.#ctor(Collection)">
<summary>Creates a new validator for the given collection of {@link SegmentString}s.</summary>
<param name="segStrings">a collection of SegmentStrings</param>
        </member>
<member name="M:topology.noding.NodingValidator.checkValid">
<summary>Checks whether the supplied segment strings are correctly noded.</summary>
        </member>
<member name="M:topology.noding.NodingValidator.checkCollapses">
<summary>Checks if a segment string contains a segment pattern a-b-a (which implies a self-intersection)</summary>
        </member>
<member name="M:topology.noding.NodingValidator.checkInteriorIntersections">
<summary>Checks all pairs of segments for intersections at an interior point of a segment</summary>
        </member>
<member name="M:topology.noding.NodingValidator.hasInteriorIntersection(LineIntersector,Coordinate,Coordinate)">
<returns>true if there is an intersection point which is not an endpoint of the segment p0-p1</returns>
        </member>
<member name="M:topology.noding.NodingValidator.checkEndPtVertexIntersections">
<summary>Checks for intersections between an endpoint of a segment string and an interior vertex of another segment string</summary>
        </member>
<member name="T:topology.operation.overlay.MinimalEdgeRing">
	<remarks>A ring of {@link Edge}s with the property that no node has degree greater than 2.  These are the form of rings required to represent polygons under the OGC SFS spatial data model.</remarks>
	<version>1.7</version>
	<seealso cref="T:topology.operation.overlay.MaximalEdgeRing"/>
</member>
<!-- Badly formed XML comment ignored for member T:topology.geomgraph.index.EdgeSetIntersector -->
<member name="M:topology.geomgraph.index.EdgeSetIntersector.computeIntersections(List,SegmentIntersector,System.Boolean)">
<summary>Computes all self-intersections between edges in a set of edges, allowing client to choose whether self-intersections are computed.</summary>
<param name="edges">a list of edges to test for intersections</param>
<param name="si">the SegmentIntersector to use</param>
<param name="testAllSegments">true if self-intersections are to be tested as well</param>
        </member>
<member name="M:topology.geomgraph.index.EdgeSetIntersector.computeIntersections(List,List,SegmentIntersector)">
<summary>Computes all mutual intersections between two sets of edges.</summary>
        </member>
<member name="T:topology.simplify.TaggedLineString">
<version>1.7</version>
        </member>
<member name="T:topology.io.InputStreamInStream">
<remarks>An adapter to allow an {@link InputStream} to be used as an {@link InStream}</remarks>
        </member>
<member name="T:topology.operation.polygonize.PolygonizeDirectedEdge">
<remarks>A {@link DirectedEdge} of a {@link PolygonizeGraph}, which represents an edge of a polygon formed by the graph. May be logically deleted from the graph by setting the <code>marked</code> flag.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeDirectedEdge.#ctor(Node,Node,Coordinate,System.Boolean)">
<summary>Constructs a directed edge connecting the <code>from</code> node to the <code>to</code> node.</summary>
<param name="directionPt">specifies this DirectedEdge's direction (given by an imaginary line from the <code>from</code> node to <code>directionPt</code>)</param>
<param name="edgeDirection">whether this DirectedEdge's direction is the same as or opposite to that of the parent Edge (if any)</param>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeDirectedEdge.getLabel">
<summary>Returns the identifier attached to this directed edge.</summary>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeDirectedEdge.setLabel(System.Int64)">
<summary>Attaches an identifier to this directed edge.</summary>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeDirectedEdge.getNext">
<summary>Returns the next directed edge in the EdgeRing that this directed edge is a member of.</summary>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeDirectedEdge.setNext(PolygonizeDirectedEdge)">
<summary>Sets the next directed edge in the EdgeRing that this directed edge is a member of.</summary>
        </member>
<member name="M:topology.operation.polygonize.PolygonizeDirectedEdge.isInRing">
	<summary>Returns the ring of directed edges that this directed edge is a member of, or null if the ring has not been set.</summary>
	<seealso cref="!:#setRing(EdgeRing)"/>
</member>
<member name="M:topology.operation.polygonize.PolygonizeDirectedEdge.setRing(EdgeRing)">
<summary>Sets the ring of directed edges that this directed edge is a member of.</summary>
        </member>
<member name="T:topology.geomgraph.index.SimpleEdgeSetIntersector">
<remarks>Finds all intersections in one or two sets of edges, using the straightforward method of comparing all segments. This algorithm is too slow for production use, but is useful for testing purposes.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.index.SimpleEdgeSetIntersector.computeIntersects(Edge,Edge,SegmentIntersector)">
<summary>Performs a brute-force comparison of every segment in each Edge.</summary>
        </member>
<member name="T:topology.algorithm.SimplePointInAreaLocator">
<remarks>Computes whether a point lies in the interior of an area {@link Geometry}. The algorithm used is only guaranteed to return correct results for points which are <b>not</b> on the boundary of the Geometry.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.algorithm.SimplePointInAreaLocator.locate(Coordinate,Geometry)">
<summary>locate is the main location function.</summary>
        </member>
<member name="T:topology.index.bintree.Root">
<remarks>The root node of a single {@link Bintree}. It is centred at the origin, and does not have a defined extent.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.bintree.Root.insert(Interval,Object)">
<summary>Insert an item into the tree this is the root of.</summary>
        </member>
<member name="M:topology.index.bintree.Root.insertContained(Node,Interval,Object)">
<summary>insert an item which is known to be contained in the tree rooted at the given Node.</summary>
        </member>
<member name="M:topology.index.bintree.Root.isSearchMatch(Interval)">
<summary>The root node matches all searches</summary>
        </member>
<member name="T:topology.geomgraph.EdgeIntersectionList">
<remarks>A list of edge intersections along an {@link Edge}. Implements splitting an edge with intersections into multiple resultant edges.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.EdgeIntersectionList.add(Coordinate,System.Int32,System.Double)">
<summary>Adds an intersection into the list, if it isn't already there.</summary>
<returns>the EdgeIntersection found or added</returns>
        </member>
<member name="M:topology.geomgraph.EdgeIntersectionList.iterator">
<summary>Returns an iterator of {@link EdgeIntersection}s</summary>
<returns>an Iterator of EdgeIntersections</returns>
        </member>
<member name="M:topology.geomgraph.EdgeIntersectionList.isIntersection(Coordinate)">
<summary>Tests if the given point is an edge intersection</summary>
<param name="pt">the point to test</param>
<returns>true if the point is an intersection</returns>
        </member>
<member name="M:topology.geomgraph.EdgeIntersectionList.addEndpoints">
<summary>Adds entries for the first and last points of the edge to the list</summary>
        </member>
<member name="M:topology.geomgraph.EdgeIntersectionList.addSplitEdges(List)">
<summary>Creates new edges for all the edges that the intersections in this list split the parent edge into.</summary>
<param name="edgeList">a list of EdgeIntersections</param>
        </member>
<member name="M:topology.geomgraph.EdgeIntersectionList.createSplitEdge(EdgeIntersection,EdgeIntersection)">
<summary>Create a new "split edge" with the section of points between (and including) the two intersections.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.noding.snapround.HotPixel -->
<member name="F:topology.noding.snapround.HotPixel.corner">
<summary>The corners of the hot pixel, in the order: 10 23</summary>
        </member>
<member name="M:topology.noding.snapround.HotPixel.getSafeEnvelope">
<summary>Returns a "safe" envelope that is guaranteed to contain the hot pixel</summary>
<returns></returns>
        </member>
<member name="M:topology.noding.snapround.HotPixel.intersectsToleranceSquare(Coordinate,Coordinate)">
<summary>Tests whether the segment p0-p1 intersects the hot pixel tolerance square.</summary>
<param name="p0"></param>
<param name="p1"></param>
<returns></returns>
        </member>
<member name="M:topology.noding.snapround.HotPixel.intersectsPixelClosure(Coordinate,Coordinate)">
<summary>Test whether the given segment intersects the closure of this hot pixel.</summary>
<param name="p0">the start point of a line segment</param>
<param name="p1">the end point of a line segment</param>
<returns><code>true</code> if the segment intersects the closure of the pixel's tolerance square</returns>
        </member>
<member name="T:topology.planargraph.Subgraph">
<remarks>A subgraph of a {@link PlanarGraph}. A subgraph may contain any subset of {@link Edge}s from the parent graph. It will also automatically contain all {@link DirectedEdge}s and {@link Node}s associated with those edges. No new objects are created when edges are added - all associated components must already exist in the parent graph.</remarks>
        </member>
<member name="M:topology.planargraph.Subgraph.#ctor(PlanarGraph)">
<summary>Creates a new subgraph of the given {@link PlanarGraph}</summary>
<param name="parentGraph">the parent graph</param>
        </member>
<member name="M:topology.planargraph.Subgraph.getParent">
<summary>Gets the {@link PlanarGraph} which this subgraph is part of.</summary>
<returns>the parent PlanarGraph</returns>
        </member>
<member name="M:topology.planargraph.Subgraph.add(Edge)">
<summary>Adds an {@link Edge} to the subgraph.</summary>
<param name="e">the edge to add</param>
        </member>
<member name="M:topology.planargraph.Subgraph.dirEdgeIterator">
	<summary>Returns an {@link Iterator} over the {@link DirectedEdge}s in this graph, in the order in which they were added.</summary>
	<returns>an iterator over the directed edges</returns>
	<seealso cref="!:#add(Edge)"/>
</member>
<member name="M:topology.planargraph.Subgraph.edgeIterator">
	<summary>Returns an {@link Iterator} over the {@link Edge}s in this graph, in the order in which they were added.</summary>
	<returns>an iterator over the edges</returns>
	<seealso cref="!:#add(Edge)"/>
</member>
<member name="M:topology.planargraph.Subgraph.nodeIterator">
<summary>Returns an {@link Iterator} over the {@link Node}s in this graph.</summary>
<returns>an iterator over the nodes</returns>
        </member>
<member name="M:topology.planargraph.Subgraph.contains(Edge)">
<summary>Tests whether an {@link Edge} is contained in this subgraph</summary>
<param name="e">the edge to test</param>
<returns><code>true</code> if the edge is contained in this subgraph</returns>
        </member>
<member name="T:topology.operation.overlay.LineBuilder">
<remarks>Forms JTS LineStrings out of a the graph of {@link DirectedEdge}s created by an {@link OverlayOp}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.overlay.LineBuilder.build(System.Int32)">
<returns>a list of the LineStrings in the result of the specified overlay operation</returns>
        </member>
<member name="M:topology.operation.overlay.LineBuilder.findCoveredLineEdges">
<summary>Find and mark L edges which are "covered" by the result area (if any).</summary>
        </member>
<member name="M:topology.operation.overlay.LineBuilder.collectLineEdge(DirectedEdge,System.Int32,List)">
<summary>Collect line edges which are in the result.</summary>
<param name="de">the directed edge to test</param>
<param name="opCode">the overlap operation</param>
<param name="edges">the list of included line edges</param>
        </member>
<member name="M:topology.operation.overlay.LineBuilder.collectBoundaryTouchEdge(DirectedEdge,System.Int32,List)">
<summary>Collect edges from Area inputs which should be in the result but which have not been included in a result area.</summary>
        </member>
<member name="M:topology.operation.overlay.LineBuilder.labelIsolatedLine(Edge,System.Int32)">
<summary>Label an isolated node with its relationship to the target geometry.</summary>
        </member>
<member name="T:topology.io.WKBConstants">
<remarks>Constant values used by the WKB format</remarks>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.algorithm.InteriorPointLine -->
<member name="M:topology.algorithm.InteriorPointLine.addInterior(Geometry)">
<summary>Tests the interior vertices (if any) defined by a linear Geometry for the best inside point.</summary>
<param name="geom">the geometry to add</param>
        </member>
<member name="M:topology.algorithm.InteriorPointLine.addEndpoints(Geometry)">
<summary>Tests the endpoint vertices defined by a linear Geometry for the best inside point.</summary>
<param name="geom">the geometry to add</param>
        </member>
<member name="T:topology.noding.MCIndexNoder">
<remarks>Nodes a set of {@link SegmentStrings} using a index based on {@link MonotoneChain}s and a {@link SpatialIndex}. The {@link SpatialIndex} used should be something that supports envelope (range) queries efficiently (such as a {@link Quadtree} or {@link STRtree}.</remarks>
<version>1.7</version>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.util.GeometricShapeFactory -->
<member name="M:topology.util.GeometricShapeFactory.#ctor">
<summary>Create a shape factory which will create shapes using the default {@link GeometryFactory}.</summary>
        </member>
<member name="M:topology.util.GeometricShapeFactory.#ctor(GeometryFactory)">
<summary>Create a shape factory which will create shapes using the given {@link GeometryFactory}.</summary>
<param name="geomFact">the factory to use</param>
        </member>
<member name="M:topology.util.GeometricShapeFactory.setBase(Coordinate)">
<summary>Sets the location of the shape by specifying the base coordinate (which in most cases is the lower left point of the envelope containing the shape).</summary>
<param name="base">the base coordinate of the shape</param>
        </member>
<member name="M:topology.util.GeometricShapeFactory.setCentre(Coordinate)">
<summary>Sets the location of the shape by specifying the centre of the shape's bounding box</summary>
<param name="centre">the centre coordinate of the shape</param>
        </member>
<member name="M:topology.util.GeometricShapeFactory.setNumPoints(System.Int32)">
<summary>Sets the total number of points in the created {@link Geometry}.</summary>
        </member>
<member name="M:topology.util.GeometricShapeFactory.setSize(System.Double)">
<summary>Sets the size of the extent of the shape in both x and y directions.</summary>
<param name="size">the size of the shape's extent</param>
        </member>
<member name="M:topology.util.GeometricShapeFactory.setWidth(System.Double)">
<summary>Sets the width of the shape.</summary>
<param name="width">the width of the shape</param>
        </member>
<member name="M:topology.util.GeometricShapeFactory.setHeight(System.Double)">
<summary>Sets the height of the shape.</summary>
<param name="height">the height of the shape</param>
        </member>
<member name="M:topology.util.GeometricShapeFactory.createRectangle">
<summary>Creates a rectangular {@link Polygon}.</summary>
<returns>a rectangular Polygon</returns>
        </member>
<member name="M:topology.util.GeometricShapeFactory.createCircle">
<summary>Creates a circular {@link Polygon}.</summary>
<returns>a circle</returns>
        </member>
<member name="M:topology.util.GeometricShapeFactory.createArc(System.Double,System.Double)">
<summary>Creates a elliptical arc, as a LineString.</summary>
<returns>an elliptical arc</returns>
        </member>
<member name="T:topology.operation.GeometryGraphOperation">
<remarks>The base class for operations that require {@link GeometryGraph}s.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.operation.GeometryGraphOperation.arg">
<summary>The operation args into an array so they can be accessed by index</summary>
        </member>
<member name="T:topology.geom.util.LinearComponentExtracter">
<remarks>Extracts all the 1-dimensional ({@link LineString}) components from a {@link Geometry}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.util.LinearComponentExtracter.getLines(Geometry)">
<summary>Extracts the linear components from a single geometry.</summary>
<param name="geom">the geometry from which to extract linear components</param>
<returns>the list of linear components</returns>
        </member>
<member name="M:topology.geom.util.LinearComponentExtracter.#ctor(List)">
<summary>Constructs a LineExtracterFilter with a list in which to store LineStrings found.</summary>
        </member>
<member name="T:topology.geomgraph.DirectedEdge">
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.DirectedEdge.depthFactor(System.Int32,System.Int32)">
<summary>Computes the factor for the change in depth when moving from one location to another.</summary>
        </member>
<member name="F:topology.geomgraph.DirectedEdge.depth">
<summary>The depth of each side (position) of this edge.</summary>
        </member>
<member name="M:topology.geomgraph.DirectedEdge.setVisitedEdge(System.Boolean)">
<summary>setVisitedEdge marks both DirectedEdges attached to a given Edge.</summary>
        </member>
<member name="M:topology.geomgraph.DirectedEdge.getSym">
<summary>Each Edge gives rise to a pair of symmetric DirectedEdges, in opposite directions.</summary>
<returns>the DirectedEdge for the same Edge but in the opposite direction</returns>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.geomgraph.DirectedEdge.isLineEdge -->
<!-- Badly formed XML comment ignored for member M:topology.geomgraph.DirectedEdge.isInteriorAreaEdge -->
<member name="M:topology.geomgraph.DirectedEdge.computeDirectedLabel">
<summary>Compute the label in the appropriate orientation for this DirEdge</summary>
        </member>
<member name="M:topology.geomgraph.DirectedEdge.setEdgeDepths(System.Int32,System.Int32)">
<summary>Set both edge depths.</summary>
        </member>
<member name="T:topology.geom.GeometryCollection">
<remarks>Basic implementation of <code>GeometryCollection</code>.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.geom.GeometryCollection.geometries">
<summary>Internal representation of this <code>GeometryCollection</code>.</summary>
        </member>
<member name="M:topology.geom.GeometryCollection.#ctor(Geometry[],PrecisionModel,System.Int32)">
<obsolete>Use GeometryFactory instead</obsolete>
        </member>
<member name="M:topology.geom.GeometryCollection.#ctor(Geometry[],GeometryFactory)">
<param name="geometries">the <code>Geometry</code>s for this <code>GeometryCollection</code>, or <code>null</code> or an empty array to create the empty geometry. Elements may be empty <code>Geometry</code>s, but not <code>null</code>s.</param>
        </member>
<member name="M:topology.geom.GeometryCollection.getCoordinates">
<summary>Collects all coordinates of all subgeometries into an Array.</summary>
<returns>the collected coordinates</returns>
        </member>
<member name="M:topology.geom.GeometryCollection.getArea">
<summary>Returns the area of this <code>GeometryCollection</code></summary>
<returns>the area of the polygon</returns>
        </member>
<member name="M:topology.geom.GeometryCollection.clone">
<summary>Creates and returns a full copy of this {@link GeometryCollection} object.</summary>
<returns>a clone of this instance</returns>
        </member>
<member name="T:topology.noding.SimpleNoder">
<remarks>Nodes a set of {@link SegmentString}s by performing a brute-force comparison of every segment to every other one. This has n^2 performance, so is too slow for use on large numbers of segments.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.noding.SegmentNode">
<remarks>Represents an intersection point between two {@link SegmentString}s.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.noding.SegmentNode.compareTo(Object)">
<returns>-1 this SegmentNode is located before the argument location</returns>
<returns>0 this SegmentNode is at the argument location</returns>
<returns>1 this SegmentNode is located after the argument location</returns>
        </member>
<member name="T:topology.util.Stopwatch">
<remarks>Implements a timer function which can compute elapsed time as well as split times.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.geom.CoordinateSequenceFactory">
<remarks>A factory to create concrete instances of {@link CoordinateSequence}s. Used to configure {@link GeometryFactory}s to provide specific kinds of CoordinateSequences.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.CoordinateSequenceFactory.create(Coordinate[])">
<summary>Returns a {@link CoordinateSequence} based on the given array.</summary>
<param name="coordinates">the coordinates</param>
        </member>
<member name="M:topology.geom.CoordinateSequenceFactory.create(CoordinateSequence)">
<summary>Creates a {@link CoordinateSequence} which is a copy of the given {@link CoordinateSequence}.</summary>
<param name="coordSeq">the coordinate sequence to copy</param>
        </member>
<member name="M:topology.geom.CoordinateSequenceFactory.create(System.Int32,System.Int32)">
<summary>Creates a {@link CoordinateSequence} of the specified size and dimension.</summary>
<param name="size">the number of coordinates in the sequence</param>
<param name="dimension">the dimension of the coordinates in the sequence (if user-specifiable, otherwise ignored)</param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.overlay.MaximalEdgeRing -->
<member name="M:topology.operation.overlay.MaximalEdgeRing.linkDirectedEdgesForMinimalEdgeRings">
<summary>For all nodes in this EdgeRing, link the DirectedEdges at the node to form minimalEdgeRings</summary>
        </member>
<member name="T:topology.geom.Location">
<remarks>Constants representing the location of a point relative to a geometry. They can also be thought of as the row or column index of a DE-9IM matrix. For a description of the DE-9IM, see the <A HREF="http://www.opengis.org/techno/specs.htm">OpenGIS Simple Features Specification for SQL</A> .</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.geom.Location.INTERIOR">
<summary>DE-9IM row index of the interior of the first geometry and column index of the interior of the second geometry.</summary>
        </member>
<member name="F:topology.geom.Location.BOUNDARY">
<summary>DE-9IM row index of the boundary of the first geometry and column index of the boundary of the second geometry.</summary>
        </member>
<member name="F:topology.geom.Location.EXTERIOR">
<summary>DE-9IM row index of the exterior of the first geometry and column index of the exterior of the second geometry.</summary>
        </member>
<member name="F:topology.geom.Location.NONE">
<summary>Used for uninitialized location values.</summary>
        </member>
<member name="M:topology.geom.Location.toLocationSymbol(System.Int32)">
<summary>Converts the location value to a location symbol, for example, <code>EXTERIOR => 'e'</code> .</summary>
<param name="locationValue">either EXTERIOR, BOUNDARY, INTERIOR or NONE</param>
<returns>either 'e', 'b', 'i' or '-'</returns>
        </member>
<member name="T:topology.precision.CommonBits">
<remarks>Determines the maximum number of common most-significant bits in the mantissa of one or numbers. Can be used to compute the double-precision number which is represented by the common bits. If there are no common bits, the number computed is 0.0.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.precision.CommonBits.signExpBits(System.Int64)">
<summary>Computes the bit pattern for the sign and exponent of a double-precision number.</summary>
<param name="num"></param>
<returns>the bit pattern for the sign and exponent</returns>
        </member>
<member name="M:topology.precision.CommonBits.numCommonMostSigMantissaBits(System.Int64,System.Int64)">
<summary>This computes the number of common most-significant bits in the mantissas of two double-precision numbers.</summary>
<param name="num1">the first number</param>
<param name="num2">the second number</param>
<returns>the number of common most-significant mantissa bits</returns>
        </member>
<member name="M:topology.precision.CommonBits.zeroLowerBits(System.Int64,System.Int32)">
<summary>Zeroes the lower n bits of a bitstring.</summary>
<param name="bits">the bitstring to alter</param>
<returns>the zeroed bitstring</returns>
        </member>
<member name="M:topology.precision.CommonBits.getBit(System.Int64,System.Int32)">
<summary>Extracts the i'th bit of a bitstring.</summary>
<param name="bits">the bitstring to extract from</param>
<param name="i">the bit to extract</param>
<returns>the value of the extracted bit</returns>
        </member>
<member name="M:topology.precision.CommonBits.toString(System.Int64)">
<summary>A representation of the Double bits formatted for easy readability</summary>
        </member>
<member name="T:topology.operation.overlay.snap.SnapOverlayOp">
<remarks>Performs an overlay operation using snapping and enhanced precision to improve the robustness of the result. This class <i>always</i> uses snapping. This is less performant than the standard JTS overlay code, and may even introduce errors which were not present in the original data. For this reason, this class should only be used if the standard overlay code fails to produce a correct result.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="T:topology.algorithm.PointInRing">
<remarks>An interface for classes which test whether a {@link Coordinate} lies inside a ring.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.geomgraph.index.SegmentIntersector">
<version>1.7</version>
        </member>
<member name="F:topology.geomgraph.index.SegmentIntersector.hasIntersection">
<summary>These variables keep track of what types of intersections were found during ALL edges that have been intersected.</summary>
        </member>
<member name="M:topology.geomgraph.index.SegmentIntersector.getProperIntersectionPoint">
<returns>the proper intersection point, or <code>null</code> if none was found</returns>
        </member>
<member name="M:topology.geomgraph.index.SegmentIntersector.hasProperIntersection">
<summary>A proper intersection is an intersection which is interior to at least two line segments.</summary>
        </member>
<member name="M:topology.geomgraph.index.SegmentIntersector.hasProperInteriorIntersection">
<summary>A proper interior intersection is a proper intersection which is <b>not</b> contained in the set of boundary nodes set for this SegmentIntersector.</summary>
        </member>
<member name="M:topology.geomgraph.index.SegmentIntersector.isTrivialIntersection(Edge,System.Int32,Edge,System.Int32)">
<summary>A trivial intersection is an apparent self-intersection which in fact is simply the point shared by adjacent line segments.</summary>
        </member>
<member name="M:topology.geomgraph.index.SegmentIntersector.addIntersections(Edge,System.Int32,Edge,System.Int32)">
<summary>This method is called by clients of the EdgeIntersector class to test for and add intersections for two segments of the edges being intersected.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geomgraph.EdgeIntersection -->
<member name="M:topology.geomgraph.EdgeIntersection.compare(System.Int32,System.Double)">
<returns>-1 this EdgeIntersection is located before the argument location</returns>
<returns>0 this EdgeIntersection is at the argument location</returns>
<returns>1 this EdgeIntersection is located after the argument location</returns>
        </member>
<member name="T:topology.operation.relate.RelateNodeFactory">
<remarks>Used by the {@link NodeMap} in a {@link RelateNodeGraph} to create {@link RelateNode}s.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.planargraph.DirectedEdge">
<remarks>Represents a directed edge in a {@link PlanarGraph}. A DirectedEdge may or may not have a reference to a parent {@link Edge} (some applications of planar graphs may not require explicit Edge objects to be created). Usually a client using a <code>PlanarGraph</code> will subclass <code>DirectedEdge</code> to add its own application-specific data and methods.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.planargraph.DirectedEdge.toEdges(Collection)">
<summary>Returns a List containing the parent Edge (possibly null) for each of the given DirectedEdges.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.#ctor(Node,Node,Coordinate,System.Boolean)">
<summary>Constructs a DirectedEdge connecting the <code>from</code> node to the <code>to</code> node.</summary>
<param name="directionPt">specifies this DirectedEdge's direction vector (determined by the vector from the <code>from</code> node to <code>directionPt</code>)</param>
<param name="edgeDirection">whether this DirectedEdge's direction is the same as or opposite to that of the parent Edge (if any)</param>
        </member>
<member name="M:topology.planargraph.DirectedEdge.getEdge">
<summary>Returns this DirectedEdge's parent Edge, or null if it has none.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.setEdge(Edge)">
<summary>Associates this DirectedEdge with an Edge (possibly null, indicating no associated Edge).</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.getQuadrant">
<summary>Returns 0, 1, 2, or 3, indicating the quadrant in which this DirectedEdge's orientation lies.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.getDirectionPt">
<summary>Returns a point to which an imaginary line is drawn from the from-node to specify this DirectedEdge's orientation.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.getEdgeDirection">
<summary>Returns whether the direction of the parent Edge (if any) is the same as that of this Directed Edge.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.getFromNode">
<summary>Returns the node from which this DirectedEdge leaves.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.getToNode">
<summary>Returns the node to which this DirectedEdge goes.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.getCoordinate">
<summary>Returns the coordinate of the from-node.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.getAngle">
<summary>Returns the angle that the start of this DirectedEdge makes with the positive x-axis, in radians.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.getSym">
<summary>Returns the symmetric DirectedEdge -- the other DirectedEdge associated with this DirectedEdge's parent Edge.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.setSym(DirectedEdge)">
<summary>Sets this DirectedEdge's symmetric DirectedEdge, which runs in the opposite direction.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.remove">
<summary>Removes this directed edge from its containing graph.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.isRemoved">
<summary>Tests whether this directed edge has been removed from its containing graph</summary>
<returns><code>true</code> if this directed edge is removed</returns>
        </member>
<member name="M:topology.planargraph.DirectedEdge.compareTo(Object)">
<summary>Returns 1 if this DirectedEdge has a greater angle with the positive x-axis than b", 0 if the DirectedEdges are collinear, and -1 otherwise.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.compareDirection(DirectedEdge)">
<summary>Returns 1 if this DirectedEdge has a greater angle with the positive x-axis than b", 0 if the DirectedEdges are collinear, and -1 otherwise.</summary>
        </member>
<member name="M:topology.planargraph.DirectedEdge.print(PrintStream)">
<summary>Prints a detailed string representation of this DirectedEdge to the given PrintStream.</summary>
        </member>
<member name="T:topology.noding.IntersectionFinderAdder">
<remarks>Finds proper and interior intersections in a set of SegmentStrings, and adds them as nodes.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.noding.IntersectionFinderAdder.#ctor(LineIntersector)">
<summary>Creates an intersection finder which finds all proper intersections</summary>
<param name="li">the LineIntersector to use</param>
        </member>
<member name="M:topology.noding.IntersectionFinderAdder.processIntersections(SegmentString,System.Int32,SegmentString,System.Int32)">
<summary>This method is called by clients of the {@link SegmentIntersector} class to process intersections for two segments of the {@link SegmentStrings} being intersected.</summary>
        </member>
<member name="M:topology.noding.IntersectionFinderAdder.isDone">
<summary>Always process all intersections</summary>
<returns>false always</returns>
        </member>
<member name="T:topology.index.chain.MonotoneChainOverlapAction">
<remarks>The action for the internal iterator for performing overlap queries on a MonotoneChain</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.chain.MonotoneChainOverlapAction.overlap(MonotoneChain,System.Int32,MonotoneChain,System.Int32)">
<summary>This function can be overridden if the original chains are needed</summary>
<param name="start1">the index of the start of the overlapping segment from mc1</param>
<param name="start2">the index of the start of the overlapping segment from mc2</param>
        </member>
<member name="M:topology.index.chain.MonotoneChainOverlapAction.overlap(LineSegment,LineSegment)">
<summary>This is a convenience function which can be overridden to obtain the actual line segments which overlap</summary>
<param name="seg1"></param>
<param name="seg2"></param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.io.WKBReader -->
<member name="M:topology.io.WKBReader.hexToBytes(String)">
<summary>Converts a hexadecimal string to a byte array.</summary>
<param name="hex">a string containing hex digits</param>
        </member>
<member name="M:topology.io.WKBReader.read(System.SByte[])">
<summary>Reads a single {@link Geometry} from a byte array.</summary>
<param name="bytes">the byte array to read from</param>
<returns>the geometry read</returns>
        </member>
<member name="M:topology.io.WKBReader.read(InStream)">
<summary>Reads a {@link Geometry} from an {@link InStream).</summary>
<param name="is">the stream to read from</param>
<returns>the Geometry read</returns>
        </member>
<member name="M:topology.io.WKBReader.setSRID(Geometry)">
<summary>Sets the SRID, if it was specified in the WKB</summary>
<param name="g">the geometry to update</param>
<returns>the geometry with an updated SRID value, if required</returns>
        </member>
<member name="M:topology.io.WKBReader.readCoordinate">
<summary>Reads a coordinate value with the specified dimensionality.</summary>
        </member>
<member name="T:topology.algorithm.CentroidPoint">
<remarks>Computes the centroid of a point geometry. <h2>Algorithm</h2> Compute the average of all points.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.algorithm.CentroidPoint.add(Geometry)">
<summary>Adds the point(s) defined by a Geometry to the centroid total.</summary>
<param name="geom">the geometry to add</param>
        </member>
<member name="M:topology.algorithm.CentroidPoint.add(Coordinate)">
<summary>Adds the length defined by an array of coordinates.</summary>
<param name="pts">an array of {@link Coordinate}s</param>
        </member>
<member name="T:topology.algorithm.SIRtreePointInRing">
<remarks>Implements {@link PointInRing} using a {@link SIRtree} index to increase performance.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.index.ItemVisitor">
<remarks>A visitor for items in an index.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.operation.overlay.PointBuilder">
<remarks>Constructs {@link Point}s from the nodes of an overlay graph.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.overlay.PointBuilder.build(System.Int32)">
<summary>Computes the Point geometries which will appear in the result, given the specified overlay operation.</summary>
<returns>a list of the Points objects in the result</returns>
        </member>
<member name="M:topology.operation.overlay.PointBuilder.extractNonCoveredResultNodes(System.Int32)">
<summary>Determines nodes which are in the result, and creates {@link Point}s for them.</summary>
<param name="opCode">the overlay operation</param>
        </member>
<member name="M:topology.operation.overlay.PointBuilder.filterCoveredNodeToPoint(Node)">
<summary>Converts non-covered nodes to Point objects and adds them to the result.</summary>
<param name="n">the node to test</param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.CoordinateSequenceFilter -->
<member name="M:topology.geom.CoordinateSequenceFilter.filter(CoordinateSequence,System.Int32)">
<summary>Performs an operation on a coordinate in a {@link CoordinateSequence}.</summary>
<param name="seq">the <code>CoordinateSequence</code> to which the filter is applied</param>
<param name="i">the index of the coordinate to apply the filter to</param>
        </member>
<member name="M:topology.geom.CoordinateSequenceFilter.isDone">
<summary>Reports whether the application of this filter can be terminated.</summary>
<returns>true if the application of this filter can be terminated.</returns>
        </member>
<member name="M:topology.geom.CoordinateSequenceFilter.isGeometryChanged">
<summary>Reports whether the execution of this filter has modified the coordinates of the geometry.</summary>
<returns>true if this filter has changed the coordinates of the geometry</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.index.quadtree.DoubleBits -->
<member name="M:topology.index.quadtree.DoubleBits.biasedExponent">
<summary>Determines the exponent for the number</summary>
        </member>
<member name="M:topology.index.quadtree.DoubleBits.getExponent">
<summary>Determines the exponent for the number</summary>
        </member>
<member name="M:topology.index.quadtree.DoubleBits.numCommonMantissaBits(DoubleBits)">
<summary>This computes the number of common most-significant bits in the mantissa.</summary>
<param name="db"></param>
<returns>the number of common most-significant mantissa bits</returns>
        </member>
<member name="M:topology.index.quadtree.DoubleBits.toString">
<summary>A representation of the Double bits formatted for easy readability</summary>
        </member>
<member name="T:topology.simplify.TaggedLineSegment">
<remarks>A {@link LineSegment} which is tagged with its location in a parent {@link Geometry}. Used to index the segments in a geometry and recover the segment locations from the index.</remarks>
        </member>
<member name="T:topology.geom.util.NoninvertibleTransformationException">
<remarks>Indicates that an {@link AffineTransformation} is non-invertible.</remarks>
<author>Martin Davis</author>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.CoordinateSequence -->
<member name="F:topology.geom.CoordinateSequence.X">
<summary>Standard ordinate index values</summary>
        </member>
<member name="M:topology.geom.CoordinateSequence.getDimension">
<summary>Returns the dimension (number of ordinates in each coordinate) for this sequence.</summary>
<returns>the dimension of the sequence.</returns>
        </member>
<member name="M:topology.geom.CoordinateSequence.getCoordinate(System.Int32)">
<summary>Returns (possibly a copy of) the i'th coordinate in this sequence.</summary>
<param name="i">the index of the coordinate to retrieve</param>
<returns>the i'th coordinate in the sequence</returns>
        </member>
<member name="M:topology.geom.CoordinateSequence.getCoordinateCopy(System.Int32)">
<summary>Returns a copy of the i'th coordinate in this sequence.</summary>
<param name="i">the index of the coordinate to retrieve</param>
<returns>a copy of the i'th coordinate in the sequence</returns>
        </member>
<member name="M:topology.geom.CoordinateSequence.getCoordinate(System.Int32,Coordinate)">
<summary>Copies the i'th coordinate in the sequence to the supplied {@link Coordinate}.</summary>
<param name="index">the index of the coordinate to copy</param>
<param name="coord">a {@link Coordinate} to receive the value</param>
        </member>
<member name="M:topology.geom.CoordinateSequence.getX(System.Int32)">
<summary>Returns ordinate X (0) of the specified coordinate.</summary>
<param name="index"></param>
<returns>the value of the X ordinate in the index'th coordinate</returns>
        </member>
<member name="M:topology.geom.CoordinateSequence.getY(System.Int32)">
<summary>Returns ordinate Y (1) of the specified coordinate.</summary>
<param name="index"></param>
<returns>the value of the Y ordinate in the index'th coordinate</returns>
        </member>
<member name="M:topology.geom.CoordinateSequence.getOrdinate(System.Int32,System.Int32)">
<summary>Returns the ordinate of a coordinate in this sequence.</summary>
<param name="index">the coordinate index in the sequence</param>
<param name="ordinateIndex">the ordinate index in the coordinate (in range [0, dimension-1])</param>
        </member>
<member name="M:topology.geom.CoordinateSequence.size">
<summary>Returns the number of coordinates in this sequence.</summary>
<returns>the size of the sequence</returns>
        </member>
<member name="M:topology.geom.CoordinateSequence.setOrdinate(System.Int32,System.Int32,System.Double)">
<summary>Sets the value for a given ordinate of a coordinate in this sequence.</summary>
<param name="index">the coordinate index in the sequence</param>
<param name="ordinateIndex">the ordinate index in the coordinate (in range [0, dimension-1])</param>
<param name="value">the new ordinate value</param>
        </member>
<member name="M:topology.geom.CoordinateSequence.toCoordinateArray">
<summary>Returns (possibly copies of) the Coordinates in this collection.</summary>
<returns>a array of coordinates containing the point values in this sequence</returns>
        </member>
<member name="M:topology.geom.CoordinateSequence.expandEnvelope(Envelope)">
<summary>Expands the given {@link Envelope} to include the coordinates in the sequence.</summary>
<param name="env">the envelope to expand</param>
<returns>a ref to the expanded envelope</returns>
        </member>
<member name="M:topology.geom.CoordinateSequence.clone">
<summary>Returns a deep copy of this collection.</summary>
<returns>a copy of the coordinate sequence containing copies of all points</returns>
        </member>
<member name="T:topology.geom.impl.CoordinateArraySequence">
<remarks>The {@link CoordinateSequence} implementation that {@link Geometry}s use by default. In this implementation, Coordinates returned by #toArray and #getCoordinate are live -- modifications to them are actually changing the CoordinateSequence's underlying data.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.impl.CoordinateArraySequence.#ctor(Coordinate[])">
<summary>Constructs a sequence based on the given array (the array is not copied).</summary>
<param name="coordinates">the coordinate array that will be referenced.</param>
        </member>
<member name="M:topology.geom.impl.CoordinateArraySequence.#ctor(System.Int32)">
<summary>Constructs a sequence of a given size, populated with new {@link Coordinate}s.</summary>
<param name="size">the size of the sequence to create</param>
        </member>
<member name="M:topology.geom.impl.CoordinateArraySequence.#ctor(CoordinateSequence)">
<summary>Constructs a sequence based on the given array (the array is not copied).</summary>
<param name="coordinates">the coordinate array that will be referenced.</param>
        </member>
<member name="M:topology.geom.impl.CoordinateArraySequence.getDimension">
	<seealso cref="M:topology.geom.CoordinateSequence.getDimension"/>
</member>
<member name="M:topology.geom.impl.CoordinateArraySequence.getCoordinate(System.Int32)">
<summary>Get the Coordinate with index i.</summary>
<param name="i">the index of the coordinate</param>
<returns>the requested Coordinate instance</returns>
        </member>
<member name="M:topology.geom.impl.CoordinateArraySequence.getCoordinateCopy(System.Int32)">
<summary>Get a copy of the Coordinate with index i.</summary>
<param name="i">the index of the coordinate</param>
<returns>a copy of the requested Coordinate</returns>
        </member>
<member name="M:topology.geom.impl.CoordinateArraySequence.getCoordinate(System.Int32,Coordinate)">
	<seealso cref="M:topology.geom.CoordinateSequence.getX(System.Int32 index)"/>
</member>
<member name="M:topology.geom.impl.CoordinateArraySequence.getX(System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getX(System.Int32 index)"/>
</member>
<member name="M:topology.geom.impl.CoordinateArraySequence.getY(System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getY(System.Int32 index)"/>
</member>
<member name="M:topology.geom.impl.CoordinateArraySequence.getOrdinate(System.Int32,System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequence.getOrdinate(System.Int32 index,System.Int32 ordinateIndex)"/>
</member>
<member name="M:topology.geom.impl.CoordinateArraySequence.clone">
<summary>Creates a deep copy of the Object</summary>
<returns>The deep copy</returns>
        </member>
<member name="M:topology.geom.impl.CoordinateArraySequence.size">
<summary>Returns the size of the coordinate sequence</summary>
<returns>the number of coordinates</returns>
        </member>
<member name="M:topology.geom.impl.CoordinateArraySequence.setOrdinate(System.Int32,System.Int32,System.Double)">
	<seealso cref="M:topology.geom.CoordinateSequence.setOrdinate(System.Int32 index,System.Int32 ordinateIndex,System.Double value)"/>
</member>
<member name="M:topology.geom.impl.CoordinateArraySequence.toCoordinateArray">
<summary>This method exposes the internal Array of Coordinate Objects</summary>
<returns>the Coordinate[] array.</returns>
        </member>
<member name="M:topology.geom.impl.CoordinateArraySequence.toString">
<summary>Returns the string Representation of the coordinate array</summary>
<returns>The string</returns>
        </member>
<member name="T:topology.util.CollectionUtil">
<remarks>Executes a transformation function on each element of a collection and returns the results in a new List.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.util.CollectionUtil.transform(Collection,Function)">
<summary>Executes a function on each item in a {@link Collection} and returns the results in a new {@link List}</summary>
<param name="coll">the collection to process</param>
<param name="func">the Function to execute</param>
        </member>
<member name="M:topology.util.CollectionUtil.apply(Collection,Function)">
<summary>Executes a function on each item in a Collection but does not accumulate the result</summary>
<param name="coll">the collection to process</param>
<param name="func">the Function to execute</param>
        </member>
<member name="M:topology.util.CollectionUtil.select(Collection,Function)">
<summary>Executes a function on each item in a Collection and collects all the entries for which the result of the function is equal to {@link Boolean}.TRUE.</summary>
<param name="collection">the collection to process</param>
<param name="func">the Function to execute</param>
        </member>
<member name="T:topology.operation.linemerge.LineMergeGraph">
<remarks>A planar graph of edges that is analyzed to sew the edges together. The <code>marked</code> flag on @{link com.vividsolutions.planargraph.Edge}s and @{link com.vividsolutions.planargraph.Node}s indicates whether they have been logically deleted from the graph.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.linemerge.LineMergeGraph.addEdge(LineString)">
<summary>Adds an Edge, DirectedEdges, and Nodes for the given LineString representation of an edge.</summary>
        </member>
<member name="T:topology.geom.Dimension">
<remarks>Constants representing the dimensions of a point, a curve and a surface. Also, constants representing the dimensions of the empty geometry and non-empty geometries, and a wildcard dimension meaning "any dimension".</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.geom.Dimension.P">
<summary>Dimension value of a point (0).</summary>
        </member>
<member name="F:topology.geom.Dimension.L">
<summary>Dimension value of a curve (1).</summary>
        </member>
<member name="F:topology.geom.Dimension.A">
<summary>Dimension value of a surface (2).</summary>
        </member>
<member name="F:topology.geom.Dimension.FALSE">
<summary>Dimension value of the empty geometry (-1).</summary>
        </member>
<member name="F:topology.geom.Dimension.TRUE">
<summary>Dimension value of non-empty geometries (= {P, L, A}).</summary>
        </member>
<member name="F:topology.geom.Dimension.DONTCARE">
<summary>Dimension value for any dimension (= {FALSE, TRUE}).</summary>
        </member>
<member name="M:topology.geom.Dimension.toDimensionSymbol(System.Int32)">
<summary>Converts the dimension value to a dimension symbol, for example, <code>TRUE => 'T'</code> .</summary>
<param name="dimensionValue">a number that can be stored in the <code>IntersectionMatrix</code> . Possible values are <code>{TRUE, FALSE, DONTCARE, 0, 1, 2}</code>.</param>
<returns>a character for use in the string representation of an <code>IntersectionMatrix</code>. Possible values are <code>{T, F, * , 0, 1, 2}</code> .</returns>
        </member>
<member name="M:topology.geom.Dimension.toDimensionValue(System.Char)">
<summary>Converts the dimension symbol to a dimension value, for example, <code>'*' => DONTCARE</code> .</summary>
<param name="dimensionSymbol">a character for use in the string representation of an <code>IntersectionMatrix</code>. Possible values are <code>{T, F, * , 0, 1, 2}</code> .</param>
<returns>a number that can be stored in the <code>IntersectionMatrix</code> . Possible values are <code>{TRUE, FALSE, DONTCARE, 0, 1, 2}</code>.</returns>
        </member>
<member name="T:topology.geomgraph.Depth">
<remarks>A Depth object records the topological depth of the sides of an Edge for up to two Geometries.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.Depth.isNull">
<summary>A Depth object is null (has never been initialized) if all depths are null.</summary>
        </member>
<member name="M:topology.geomgraph.Depth.normalize">
<summary>Normalize the depths for each geometry, if they are non-null.</summary>
        </member>
<member name="T:topology.operation.polygonize.EdgeRing">
<remarks>Represents a ring of {@link PolygonizeDirectedEdge}s which form a ring of a polygon.  The ring may be either an outer shell or a hole.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.polygonize.EdgeRing.findEdgeRingContaining(EdgeRing,List)">
<summary>Find the innermost enclosing shell EdgeRing containing the argument EdgeRing, if any.</summary>
<returns>containing EdgeRing, if there is one</returns>
<returns>null if no containing EdgeRing is found</returns>
        </member>
<member name="M:topology.operation.polygonize.EdgeRing.ptNotInList(Coordinate[],Coordinate[])">
<summary>Finds a point in a list of points which is not contained in another list of points</summary>
<param name="testPts">the {@link Coordinate}s to test</param>
<param name="pts">an array of {@link Coordinate}s to test the input points against</param>
<returns>a {@link Coordinate} from <code>testPts</code> which is not in <code>pts</code>,</returns>
<returns>null if there is no coordinate not in the list</returns>
        </member>
<member name="M:topology.operation.polygonize.EdgeRing.isInList(Coordinate,Coordinate[])">
<summary>Tests whether a given point is in an array of points.</summary>
<param name="pt">a {@link Coordinate} for the test point</param>
<param name="pts">an array of {@link Coordinate}s to test</param>
<returns><code>true</code> if the point is in the array</returns>
        </member>
<member name="M:topology.operation.polygonize.EdgeRing.add(DirectedEdge)">
<summary>Adds a {@link DirectedEdge} which is known to form part of this ring.</summary>
<param name="de">the {@link DirectedEdge} to add.</param>
        </member>
<member name="M:topology.operation.polygonize.EdgeRing.isHole">
<summary>Tests whether this ring is a hole.</summary>
<returns><code>true</code> if this ring is a hole</returns>
        </member>
<member name="M:topology.operation.polygonize.EdgeRing.addHole(LinearRing)">
<summary>Adds a hole to the polygon formed by this ring.</summary>
<param name="hole">the {@link LinearRing} forming the hole.</param>
        </member>
<member name="M:topology.operation.polygonize.EdgeRing.getPolygon">
<summary>Computes the {@link Polygon} formed by this ring and any contained holes.</summary>
<returns>the {@link Polygon} formed by this ring and its holes.</returns>
        </member>
<member name="M:topology.operation.polygonize.EdgeRing.isValid">
<summary>Tests if the {@link LinearRing} ring formed by this edge ring is topologically valid.</summary>
<returns></returns>
        </member>
<member name="M:topology.operation.polygonize.EdgeRing.getCoordinates">
<summary>Computes the list of coordinates which are contained in this ring.</summary>
<returns>an array of the {@link Coordinate}s in this ring</returns>
        </member>
<member name="M:topology.operation.polygonize.EdgeRing.getLineString">
<summary>Gets the coordinates for this ring as a {@link LineString}.</summary>
<returns>a {@link LineString} containing the coordinates in this ring</returns>
        </member>
<member name="M:topology.operation.polygonize.EdgeRing.getRing">
<summary>Returns this ring as a {@link LinearRing}, or null if an Exception occurs while creating it (such as a topology problem).</summary>
        </member>
<member name="T:topology.geomgraph.EdgeNodingValidator">
<remarks>Validates that a collection of {@link Edge}s is correctly noded. Throws an appropriate exception if an noding error is found.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.EdgeNodingValidator.#ctor(Collection)">
<summary>Creates a new validator for the given collection of {@link Edge}s.</summary>
<param name="edges">a collection of Edges.</param>
        </member>
<member name="M:topology.geomgraph.EdgeNodingValidator.checkValid">
<summary>Checks whether the supplied edges are correctly noded.</summary>
        </member>
<member name="T:topology.geomgraph.Position">
<remarks>A Position indicates the position of a Location relative to a graph component (Node, Edge, or Area).</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.geomgraph.Position.ON">
<summary>An indicator that a Location is <i>on</i> a GraphComponent</summary>
        </member>
<member name="F:topology.geomgraph.Position.LEFT">
<summary>An indicator that a Location is to the <i>left</i> of a GraphComponent</summary>
        </member>
<member name="F:topology.geomgraph.Position.RIGHT">
<summary>An indicator that a Location is to the <i>right</i> of a GraphComponent</summary>
        </member>
<member name="M:topology.geomgraph.Position.opposite(System.Int32)">
<summary>Returns LEFT if the position is RIGHT, RIGHT if the position is LEFT, or the position otherwise.</summary>
        </member>
<member name="T:topology.geomgraph.index.SimpleSweepLineIntersector">
<remarks>Finds all intersections in one or two sets of edges, using a simple x-axis sweepline algorithm. While still O(n^2) in the worst case, this algorithm drastically improves the average-case time.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.index.SimpleSweepLineIntersector.prepareEvents">
<summary>Because Delete Events have a link to their corresponding Insert event, it is possible to compute exactly the range of events which must be compared to a given Insert event object.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.algorithm.RobustDeterminant -->
<member name="T:topology.operation.BoundaryOp">
<remarks>Computes the boundary of a {@link Geometry}. Allows specifying the {@link BoundaryNodeRule} to be used. This operation will always return a {@link Geometry} of the appropriate dimension for the boundary (even if the input geometry is empty). The boundary of zero-dimensional geometries (Points) is always the empty {@link GeometryCollection}.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="T:topology.operation.Counter">
<remarks>Stores an integer count, for use as a Map entry.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="F:topology.operation.Counter.count">
<summary>The value of the count</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.relate.RelateOp -->
<member name="M:topology.operation.relate.RelateOp.relate(Geometry,Geometry)">
<summary>Computes the {@link IntersectionMatrix} for the spatial relationship between two {@link Geometry}s, using the default (OGC SFS) Boundary Node Rule</summary>
<param name="a">a Geometry to test</param>
<param name="b">a Geometry to test</param>
<returns>the IntersectonMatrix for the spatial relationship between the geometries</returns>
        </member>
<member name="M:topology.operation.relate.RelateOp.relate(Geometry,Geometry,BoundaryNodeRule)">
<summary>Computes the {@link IntersectionMatrix} for the spatial relationship between two {@link Geometry}s using a specified Boundary Node Rule.</summary>
<param name="a">a Geometry to test</param>
<param name="b">a Geometry to test</param>
<param name="boundaryNodeRule">the Boundary Node Rule to use</param>
<returns>the IntersectonMatrix for the spatial relationship between the input geometries</returns>
        </member>
<member name="M:topology.operation.relate.RelateOp.#ctor(Geometry,Geometry)">
<summary>Creates a new Relate operation, using the default (OGC SFS) Boundary Node Rule.</summary>
<param name="g0">a Geometry to relate</param>
<param name="g1">another Geometry to relate</param>
        </member>
<member name="M:topology.operation.relate.RelateOp.#ctor(Geometry,Geometry,BoundaryNodeRule)">
<summary>Creates a new Relate operation with a specified Boundary Node Rule.</summary>
<param name="g0">a Geometry to relate</param>
<param name="g1">another Geometry to relate</param>
<param name="boundaryNodeRule">the Boundary Node Rule to use</param>
        </member>
<member name="M:topology.operation.relate.RelateOp.getIntersectionMatrix">
<summary>Gets the IntersectionMatrix for the spatial relationship between the input geometries.</summary>
<returns>the IntersectonMatrix for the spatial relationship between the input geometries</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.IntersectionMatrix -->
<member name="F:topology.geom.IntersectionMatrix.matrix">
<summary>Internal representation of this <code>IntersectionMatrix</code>.</summary>
        </member>
<member name="M:topology.geom.IntersectionMatrix.#ctor">
<summary>Creates an <code>IntersectionMatrix</code> with <code>FALSE</code> dimension values.</summary>
        </member>
<member name="M:topology.geom.IntersectionMatrix.#ctor(String)">
<summary>Creates an <code>IntersectionMatrix</code> with the given dimension symbols.</summary>
<param name="elements">a String of nine dimension symbols in row major order</param>
        </member>
<member name="M:topology.geom.IntersectionMatrix.#ctor(IntersectionMatrix)">
<summary>Creates an <code>IntersectionMatrix</code> with the same elements as <code>other</code>.</summary>
<param name="other">an <code>IntersectionMatrix</code> to copy</param>
        </member>
<member name="M:topology.geom.IntersectionMatrix.add(IntersectionMatrix)">
<summary>Adds one matrix to another.</summary>
<param name="im">the matrix to add</param>
        </member>
<member name="M:topology.geom.IntersectionMatrix.matches(System.Int32,System.Char)">
<summary>Returns true if the dimension value satisfies the dimension symbol.</summary>
<param name="actualDimensionValue">a number that can be stored in the <code>IntersectionMatrix</code> . Possible values are <code>{TRUE, FALSE, DONTCARE, 0, 1, 2}</code>.</param>
<param name="requiredDimensionSymbol">a character used in the string representation of an <code>IntersectionMatrix</code>. Possible values are <code>{T, F, * , 0, 1, 2}</code>.</param>
<returns>true if the dimension symbol encompasses the dimension value</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.matches(String,String)">
<summary>Returns true if each of the actual dimension symbols satisfies the corresponding required dimension symbol.</summary>
<param name="actualDimensionSymbols">nine dimension symbols to validate. Possible values are <code>{T, F, * , 0, 1, 2}</code>.</param>
<param name="requiredDimensionSymbols">nine dimension symbols to validate against. Possible values are <code>{T, F, * , 0, 1, 2}</code>.</param>
<returns>true if each of the required dimension symbols encompass the corresponding actual dimension symbol</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.set(System.Int32,System.Int32,System.Int32)">
<summary>Changes the value of one of this <code>IntersectionMatrix</code>s elements.</summary>
<param name="row">the row of this <code>IntersectionMatrix</code>, indicating the interior, boundary or exterior of the first <code>Geometry</code></param>
<param name="column">the column of this <code>IntersectionMatrix</code>, indicating the interior, boundary or exterior of the second <code>Geometry</code></param>
<param name="dimensionValue">the new value of the element</param>
        </member>
<member name="M:topology.geom.IntersectionMatrix.set(String)">
<summary>Changes the elements of this <code>IntersectionMatrix</code> to the dimension symbols in <code>dimensionSymbols</code>.</summary>
<param name="dimensionSymbols">nine dimension symbols to which to set this <code>IntersectionMatrix</code> s elements. Possible values are <code>{T, F, * , 0, 1, 2}</code></param>
        </member>
<member name="M:topology.geom.IntersectionMatrix.setAtLeast(System.Int32,System.Int32,System.Int32)">
<summary>Changes the specified element to <code>minimumDimensionValue</code> if the element is less.</summary>
<param name="row">the row of this <code>IntersectionMatrix</code> , indicating the interior, boundary or exterior of the first <code>Geometry</code></param>
<param name="column">the column of this <code>IntersectionMatrix</code> , indicating the interior, boundary or exterior of the second <code>Geometry</code></param>
<param name="minimumDimensionValue">the dimension value with which to compare the element. The order of dimension values from least to greatest is <code>{DONTCARE, TRUE, FALSE, 0, 1, 2}</code>.</param>
        </member>
<member name="M:topology.geom.IntersectionMatrix.setAtLeastIfValid(System.Int32,System.Int32,System.Int32)">
<summary>If row >= 0 and column >= 0, changes the specified element to <code>minimumDimensionValue</code> if the element is less.</summary>
<param name="row">the row of this <code>IntersectionMatrix</code> , indicating the interior, boundary or exterior of the first <code>Geometry</code></param>
<param name="column">the column of this <code>IntersectionMatrix</code> , indicating the interior, boundary or exterior of the second <code>Geometry</code></param>
<param name="minimumDimensionValue">the dimension value with which to compare the element. The order of dimension values from least to greatest is <code>{DONTCARE, TRUE, FALSE, 0, 1, 2}</code>.</param>
        </member>
<member name="M:topology.geom.IntersectionMatrix.setAtLeast(String)">
<summary>For each element in this <code>IntersectionMatrix</code>, changes the element to the corresponding minimum dimension symbol if the element is less.</summary>
<param name="minimumDimensionSymbols">nine dimension symbols with which to compare the elements of this <code>IntersectionMatrix</code>. The order of dimension values from least to greatest is <code>{DONTCARE, TRUE, FALSE, 0, 1, 2}</code> .</param>
        </member>
<member name="M:topology.geom.IntersectionMatrix.setAll(System.Int32)">
<summary>Changes the elements of this <code>IntersectionMatrix</code> to <code>dimensionValue</code> .</summary>
<param name="dimensionValue">the dimension value to which to set this <code>IntersectionMatrix</code> s elements. Possible values <code>{TRUE, FALSE, DONTCARE, 0, 1, 2}</code> .</param>
        </member>
<member name="M:topology.geom.IntersectionMatrix.get(System.Int32,System.Int32)">
<summary>Returns the value of one of this <code>IntersectionMatrix</code>s elements.</summary>
<param name="row">the row of this <code>IntersectionMatrix</code>, indicating the interior, boundary or exterior of the first <code>Geometry</code></param>
<param name="column">the column of this <code>IntersectionMatrix</code>, indicating the interior, boundary or exterior of the second <code>Geometry</code></param>
<returns>the dimension value at the given matrix position.</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.isDisjoint">
<summary>Returns <code>true</code> if this <code>IntersectionMatrix</code> is FF*FF****.</summary>
<returns><code>true</code> if the two <code>Geometry</code>s related by this <code>IntersectionMatrix</code> are disjoint</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.isIntersects">
<summary>Returns <code>true</code> if <code>isDisjoint</code> returns false.</summary>
<returns><code>true</code> if the two <code>Geometry</code>s related by this <code>IntersectionMatrix</code> intersect</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.isTouches(System.Int32,System.Int32)">
<summary>Returns <code>true</code> if this <code>IntersectionMatrix</code> is FT*******, F**T***** or F***T****.</summary>
<param name="dimensionOfGeometryA">the dimension of the first <code>Geometry</code></param>
<param name="dimensionOfGeometryB">the dimension of the second <code>Geometry</code></param>
<returns><code>true</code> if the two <code>Geometry</code> s related by this <code>IntersectionMatrix</code> touch; Returns false if both <code>Geometry</code>s are points.</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.isCrosses(System.Int32,System.Int32)">
<summary>Returns <code>true</code> if this geometry crosses the specified geometry.</summary>
<param name="dimensionOfGeometryA">the dimension of the first <code>Geometry</code></param>
<param name="dimensionOfGeometryB">the dimension of the second <code>Geometry</code></param>
<returns><code>true</code> if the two <code>Geometry</code>s related by this <code>IntersectionMatrix</code> cross.</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.isWithin">
<summary>Returns <code>true</code> if this <code>IntersectionMatrix</code> is T*F**F***.</summary>
<returns><code>true</code> if the first <code>Geometry</code> is within the second</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.isContains">
<summary>Returns <code>true</code> if this <code>IntersectionMatrix</code> is T*****FF*.</summary>
<returns><code>true</code> if the first <code>Geometry</code> contains the second</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.isCovers">
<summary>Returns <code>true</code> if this <code>IntersectionMatrix</code> is <code>T*****FF*</code> or <code>*T****FF*</code> or <code>***T**FF*</code> or <code>****T*FF*</code></summary>
<returns><code>true</code> if the first <code>Geometry</code> covers the second</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.isCoveredBy">
<summary>Returns <code>true</code> if this <code>IntersectionMatrix</code> is <code>T*F**F***</code> or <code>*TF**F***</code> or <code>**FT*F***</code> or <code>**F*TF***</code></summary>
<returns><code>true</code> if the first <code>Geometry</code> is covered by the second</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.isEquals(System.Int32,System.Int32)">
<summary>Returns <code>true</code> if this <code>IntersectionMatrix</code> is T*F**FFF*.</summary>
<param name="dimensionOfGeometryA">the dimension of the first <code>Geometry</code></param>
<param name="dimensionOfGeometryB">the dimension of the second <code>Geometry</code></param>
<returns><code>true</code> if the two <code>Geometry</code> s related by this <code>IntersectionMatrix</code> are equal; the <code>Geometry</code>s must have the same dimension for this function to return <code>true</code></returns>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.geom.IntersectionMatrix.isOverlaps(System.Int32,System.Int32) -->
<member name="M:topology.geom.IntersectionMatrix.matches(String)">
<summary>Returns whether the elements of this <code>IntersectionMatrix</code> satisfies the required dimension symbols.</summary>
<param name="requiredDimensionSymbols">nine dimension symbols with which to compare the elements of this <code>IntersectionMatrix</code>. Possible values are <code>{T, F, * , 0, 1, 2}</code>.</param>
<returns><code>true</code> if this <code>IntersectionMatrix</code> matches the required dimension symbols</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.transpose">
<summary>Transposes this IntersectionMatrix.</summary>
<returns>this <code>IntersectionMatrix</code> as a convenience</returns>
        </member>
<member name="M:topology.geom.IntersectionMatrix.toString">
<summary>Returns a nine-character <code>String</code> representation of this <code>IntersectionMatrix</code> .</summary>
<returns>the nine dimension symbols of this <code>IntersectionMatrix</code> in row-major order.</returns>
        </member>
<member name="T:topology.operation.valid.IsValidOp">
<remarks>Implements the algorithsm required to compute the <code>isValid()</code> method for {@link Geometry}s. See the documentation for the various geometry types for a specification of validity.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.valid.IsValidOp.isValid(Coordinate)">
<summary>Checks whether a coordinate is valid for processing.</summary>
<param name="coord">the coordinate to validate</param>
<returns><code>true</code> if the coordinate is valid</returns>
        </member>
<member name="M:topology.operation.valid.IsValidOp.findPtNotNode(Coordinate[],LinearRing,GeometryGraph)">
<summary>Find a point from the list of testCoords that is NOT a node in the edge for the list of searchCoords</summary>
<returns>the point found, or <code>null</code> if none found</returns>
        </member>
<member name="F:topology.operation.valid.IsValidOp.isSelfTouchingRingFormingHoleValid">
<summary>If the following condition is TRUE JTS will validate inverted shells and exverted holes (the ESRI SDE model)</summary>
        </member>
<member name="M:topology.operation.valid.IsValidOp.setSelfTouchingRingFormingHoleValid(System.Boolean)">
<summary>Sets whether polygons using <b>Self-Touching Rings</b> to form holes are reported as valid.</summary>
<param name="isValid">states whether geometry with this condition is valid</param>
        </member>
<member name="M:topology.operation.valid.IsValidOp.checkValid(Point)">
<summary>Checks validity of a Point.</summary>
        </member>
<member name="M:topology.operation.valid.IsValidOp.checkValid(MultiPoint)">
<summary>Checks validity of a MultiPoint.</summary>
        </member>
<member name="M:topology.operation.valid.IsValidOp.checkValid(LineString)">
<summary>Checks validity of a LineString.</summary>
        </member>
<member name="M:topology.operation.valid.IsValidOp.checkValid(LinearRing)">
<summary>Checks validity of a LinearRing.</summary>
        </member>
<member name="M:topology.operation.valid.IsValidOp.checkValid(Polygon)">
<summary>Checks the validity of a polygon.</summary>
        </member>
<member name="M:topology.operation.valid.IsValidOp.checkConsistentArea(GeometryGraph)">
	<summary>Checks that the arrangement of edges in a polygonal geometry graph forms a consistent area.</summary>
	<param name="graph"></param>
	<seealso cref="T:topology.operation.valid.ConsistentAreaTester"/>
</member>
<member name="M:topology.operation.valid.IsValidOp.checkNoSelfIntersectingRings(GeometryGraph)">
<summary>Check that there is no ring which self-intersects (except of course at its endpoints).</summary>
<param name="graph">the topology graph of the geometry</param>
        </member>
<member name="M:topology.operation.valid.IsValidOp.checkNoSelfIntersectingRing(EdgeIntersectionList)">
<summary>Check that a ring does not self-intersect, except at its endpoints.</summary>
        </member>
<member name="M:topology.operation.valid.IsValidOp.checkHolesInShell(Polygon,GeometryGraph)">
<summary>Tests that each hole is inside the polygon shell.</summary>
<param name="p">the polygon to be tested for hole inclusion</param>
<param name="graph">a GeometryGraph incorporating the polygon</param>
        </member>
<member name="M:topology.operation.valid.IsValidOp.checkHolesNotNested(Polygon,GeometryGraph)">
<summary>Tests that no hole is nested inside another hole.</summary>
        </member>
<member name="M:topology.operation.valid.IsValidOp.checkShellsNotNested(MultiPolygon,GeometryGraph)">
<summary>Tests that no element polygon is wholly in the interior of another element polygon.</summary>
        </member>
<member name="M:topology.operation.valid.IsValidOp.checkShellNotNested(LinearRing,Polygon,GeometryGraph)">
<summary>Check if a shell is incorrectly nested within a polygon.</summary>
        </member>
<member name="M:topology.operation.valid.IsValidOp.checkShellInsideHole(LinearRing,LinearRing,GeometryGraph)">
<summary>This routine checks to see if a shell is properly contained in a hole.</summary>
<returns><code>null</code> if the shell is properly contained, or a Coordinate which is not inside the hole if it is not</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.algorithm.InteriorPointArea -->
<member name="M:topology.algorithm.InteriorPointArea.add(Geometry)">
<summary>Tests the interior vertices (if any) defined by a linear Geometry for the best inside point.</summary>
<param name="geom">the geometry to add</param>
        </member>
<member name="M:topology.algorithm.InteriorPointArea.addPolygon(Geometry)">
<summary>Finds a reasonable point at which to label a Geometry.</summary>
<param name="geometry">the geometry to analyze</param>
<returns>the midpoint of the largest intersection between the geometry and a line halfway down its envelope</returns>
        </member>
<member name="M:topology.algorithm.InteriorPointArea.centre(Envelope)">
<summary>Returns the centre point of the envelope.</summary>
<param name="envelope">the envelope to analyze</param>
<returns>the centre of the envelope</returns>
        </member>
<member name="T:topology.geom.GeometryFilter">
<remarks><code>GeometryCollection</code> classes support the concept of applying a <code>GeometryFilter</code> to the <code>Geometry</code>. The filter is applied to every element <code>Geometry</code>. A <code>GeometryFilter</code> can either record information about the <code>Geometry</code> or change the <code>Geometry</code> in some way. <code>GeometryFilter</code> is an example of the Gang-of-Four Visitor pattern.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.GeometryFilter.filter(Geometry)">
<summary>Performs an operation with or on <code>geom</code>.</summary>
<param name="geom">a <code>Geometry</code> to which the filter is applied.</param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.distance.DistanceOp -->
<member name="M:topology.operation.distance.DistanceOp.distance(Geometry,Geometry)">
<summary>Compute the distance between the closest points of two geometries.</summary>
<param name="g0">a {@link Geometry}</param>
<param name="g1">another {@link Geometry}</param>
<returns>the distance between the geometries</returns>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.operation.distance.DistanceOp.isWithinDistance(Geometry,Geometry,System.Double) -->
<member name="M:topology.operation.distance.DistanceOp.closestPoints(Geometry,Geometry)">
<summary>Compute the the closest points of two geometries.</summary>
<param name="g0">a {@link Geometry}</param>
<param name="g1">another {@link Geometry}</param>
<returns>the closest points in the geometries</returns>
        </member>
<member name="M:topology.operation.distance.DistanceOp.#ctor(Geometry,Geometry)">
<summary>Constructs a DistanceOp that computes the distance and closest points between the two specified geometries.</summary>
<param name="g0">a Geometry</param>
<param name="g1">a Geometry</param>
        </member>
<member name="M:topology.operation.distance.DistanceOp.#ctor(Geometry,Geometry,System.Double)">
<summary>Constructs a DistanceOp that computes the distance and closest points between the two specified geometries.</summary>
<param name="g0">a Geometry</param>
<param name="g1">a Geometry</param>
<param name="terminateDistance">the distance on which to terminate the search</param>
        </member>
<member name="M:topology.operation.distance.DistanceOp.distance">
<summary>Report the distance between the closest points on the input geometries.</summary>
<returns>the distance between the geometries</returns>
        </member>
<member name="M:topology.operation.distance.DistanceOp.closestPoints">
<summary>Report the coordinates of the closest points in the input geometries.</summary>
<returns>a pair of {@link Coordinate}s of the closest points</returns>
        </member>
<member name="M:topology.operation.distance.DistanceOp.closestLocations">
<summary>Report the locations of the closest points in the input geometries.</summary>
<returns>a pair of {@link GeometryLocation}s for the closest points</returns>
        </member>
<member name="T:topology.index.sweepline.SweepLineIndex">
<remarks>A sweepline implements a sorted index on a set of intervals. It is used to compute all overlaps between the interval in the index.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.sweepline.SweepLineIndex.buildIndex">
<summary>Because Delete Events have a link to their corresponding Insert event, it is possible to compute exactly the range of events which must be compared to a given Insert event object.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.util.AffineTransformationBuilder -->
<member name="M:topology.geom.util.AffineTransformationBuilder.#ctor(Coordinate,Coordinate,Coordinate,Coordinate,Coordinate,Coordinate)">
<summary>Constructs a new builder for the transformation defined by the given set of control point mappings.</summary>
<param name="src0">a control point</param>
<param name="src1">a control point</param>
<param name="src2">a control point</param>
<param name="dest0">the image of control point 0 under the required transformation</param>
<param name="dest1">the image of control point 1 under the required transformation</param>
<param name="dest2">the image of control point 2 under the required transformation</param>
        </member>
<member name="M:topology.geom.util.AffineTransformationBuilder.getTransformation">
<summary>Computes the {@link AffineTransformation} determined by the control point mappings, or <code>null</code> if the control points do not determine a unique transformation.</summary>
<returns>an affine transformation</returns>
<returns>null if the control points do not determine a unique transformation</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformationBuilder.compute">
<summary>Computes the transformation matrix by solving the two systems of linear equations defined by the control point mappings, if this is possible.</summary>
<returns>true if the transformation matrix is solvable</returns>
        </member>
<member name="M:topology.geom.util.AffineTransformationBuilder.solve(System.Double[])">
<summary>Solves the transformation matrix system of linear equations for the given right-hand side vector.</summary>
<param name="b">the vector for the right-hand side of the system</param>
<returns>the solution vector</returns>
<returns>null if no solution could be determined</returns>
        </member>
<member name="T:topology.linearref.LengthIndexOfPoint">
<remarks>Computes the length index of the point on a linear {@link Geometry} nearest a given {@link Coordinate}. The nearest point is not necessarily unique; this class always computes the nearest point closest to the start of the geometry.</remarks>
        </member>
<member name="M:topology.linearref.LengthIndexOfPoint.indexOf(Coordinate)">
<summary>Find the nearest location along a linear {@link Geometry} to a given point.</summary>
<param name="inputPt">the coordinate to locate</param>
<returns>the location of the nearest point</returns>
        </member>
<member name="M:topology.linearref.LengthIndexOfPoint.indexOfAfter(Coordinate,System.Double)">
<summary>Finds the nearest index along the linear {@link Geometry} to a given {@link Coordinate} after the specified minimum index.</summary>
<param name="inputPt">the coordinate to locate</param>
<param name="minLocation">the minimum location for the point location</param>
<returns>the location of the nearest point</returns>
        </member>
<member name="T:topology.simplify.TaggedLinesSimplifier">
<remarks>Simplifies a collection of {@link TaggedLineString}s, preserving topology (in the sense that no new intersections are introduced). This class is essentially just a container for the common indexes used by {@link TaggedLineStringSimplifier}.</remarks>
        </member>
<member name="M:topology.simplify.TaggedLinesSimplifier.setDistanceTolerance(System.Double)">
<summary>Sets the distance tolerance for the simplification.</summary>
<param name="distanceTolerance">the approximation tolerance to use</param>
        </member>
<member name="M:topology.simplify.TaggedLinesSimplifier.simplify(Collection)">
<summary>Simplify a collection of {@link TaggedLineString}s</summary>
<param name="taggedLines">the collection of lines to simplify</param>
        </member>
<member name="T:topology.operation.overlay.OverlayOp">
<remarks>Computes the overlay of two {@link Geometry}s.  The overlay can be used to determine any boolean combination of the geometries.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.operation.overlay.OverlayOp.INTERSECTION">
<summary>The spatial functions supported by this class.</summary>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.isResultOfOp(System.Int32,System.Int32,System.Int32)">
<summary>This method will handle arguments of Location.NONE correctly</summary>
<returns>true if the locations correspond to the opCode</returns>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.insertUniqueEdge(Edge)">
<summary>Insert an edge from one of the noded input graphs.</summary>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.computeLabelsFromDepths">
<summary>Update the labels for edges according to their depths.</summary>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.replaceCollapsedEdges">
<summary>If edges which have undergone dimensional collapse are found, replace them with a new edge which is a L edge</summary>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.copyPoints(System.Int32)">
<summary>Copy all nodes from an arg geometry into this graph.</summary>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.computeLabelling">
<summary>Compute initial labelling for all DirectedEdges at each node.</summary>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.mergeSymLabels">
<summary>For nodes which have edges from only one Geometry incident on them, the previous step will have left their dirEdges with no labelling for the other Geometry.</summary>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.labelIncompleteNodes">
<summary>Incomplete nodes are nodes whose labels are incomplete.</summary>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.labelIncompleteNode(Node,System.Int32)">
<summary>Label an isolated node with its relationship to the target geometry.</summary>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.findResultAreaEdges(System.Int32)">
<summary>Find all edges whose label indicates that they are in the result area(s), according to the operation being performed.</summary>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.cancelDuplicateResultEdges">
<summary>If both a dirEdge and its sym are marked as being in the result, cancel them out.</summary>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.isCoveredByLA(Coordinate)">
<summary>This method is used to decide if a point node should be included in the result or not.</summary>
<returns>true if the coord point is covered by a result Line or Area geometry</returns>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.isCoveredByA(Coordinate)">
<summary>This method is used to decide if an L edge should be included in the result or not.</summary>
<returns>true if the coord point is covered by a result Area geometry</returns>
        </member>
<member name="M:topology.operation.overlay.OverlayOp.isCovered(Coordinate,List)">
<returns>true if the coord is located in the interior or boundary of a geometry in the list.</returns>
        </member>
<member name="T:topology.io.OutputStreamOutStream">
<remarks>An adapter to allow an {@link OutputStream} to be used as an {@link OutStream}</remarks>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.precision.SimpleGeometryPrecisionReducer -->
<member name="M:topology.precision.SimpleGeometryPrecisionReducer.setRemoveCollapsedComponents(System.Boolean)">
<summary>Sets whether the reduction will result in collapsed components being removed completely, or simply being collapsed to an (invalid) Geometry of the same type.</summary>
<param name="removeCollapsed">if <code>true</code> collapsed components will be removed</param>
        </member>
<member name="M:topology.precision.SimpleGeometryPrecisionReducer.setChangePrecisionModel(System.Boolean)">
<summary>Sets whether the {@link PrecisionModel} of the new reduced Geometry will be changed to be the {@link PrecisionModel} supplied to specify the reduction.</summary>
<param name="changePrecisionModel">if <code>true</code> the precision model of the created Geometry will be the the precisionModel supplied in the constructor.</param>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.precision.CommonBitsOp -->
<member name="M:topology.precision.CommonBitsOp.#ctor">
<summary>Creates a new instance of class, which reshifts result {@link Geometry}s.</summary>
        </member>
<member name="M:topology.precision.CommonBitsOp.#ctor(System.Boolean)">
<summary>Creates a new instance of class, specifying whether the result {@link Geometry}s should be reshifted.</summary>
<param name="returnToOriginalPrecision"></param>
        </member>
<member name="M:topology.precision.CommonBitsOp.intersection(Geometry,Geometry)">
<summary>Computes the set-theoretic intersection of two {@link Geometry}s, using enhanced precision.</summary>
<param name="geom0">the first Geometry</param>
<param name="geom1">the second Geometry</param>
<returns>the Geometry representing the set-theoretic intersection of the input Geometries.</returns>
        </member>
<member name="M:topology.precision.CommonBitsOp.union(Geometry,Geometry)">
<summary>Computes the set-theoretic union of two {@link Geometry}s, using enhanced precision.</summary>
<param name="geom0">the first Geometry</param>
<param name="geom1">the second Geometry</param>
<returns>the Geometry representing the set-theoretic union of the input Geometries.</returns>
        </member>
<member name="M:topology.precision.CommonBitsOp.difference(Geometry,Geometry)">
<summary>Computes the set-theoretic difference of two {@link Geometry}s, using enhanced precision.</summary>
<param name="geom0">the first Geometry</param>
<param name="geom1">the second Geometry, to be subtracted from the first</param>
<returns>the Geometry representing the set-theoretic difference of the input Geometries.</returns>
        </member>
<member name="M:topology.precision.CommonBitsOp.symDifference(Geometry,Geometry)">
<summary>Computes the set-theoretic symmetric difference of two geometries, using enhanced precision.</summary>
<param name="geom0">the first Geometry</param>
<param name="geom1">the second Geometry</param>
<returns>the Geometry representing the set-theoretic symmetric difference of the input Geometries.</returns>
        </member>
<member name="M:topology.precision.CommonBitsOp.buffer(Geometry,System.Double)">
<summary>Computes the buffer a geometry, using enhanced precision.</summary>
<param name="geom0">the Geometry to buffer</param>
<param name="distance">the buffer distance</param>
<returns>the Geometry representing the buffer of the input Geometry.</returns>
        </member>
<member name="M:topology.precision.CommonBitsOp.computeResultPrecision(Geometry)">
<summary>If required, returning the result to the orginal precision if required.</summary>
<param name="result">the result Geometry to modify</param>
<returns>the result Geometry with the required precision</returns>
        </member>
<member name="M:topology.precision.CommonBitsOp.removeCommonBits(Geometry)">
<summary>Computes a copy of the input {@link Geometry} with the calculated common bits removed from each coordinate.</summary>
<param name="geom0">the Geometry to remove common bits from</param>
<returns>a copy of the input Geometry with common bits removed</returns>
        </member>
<member name="M:topology.precision.CommonBitsOp.removeCommonBits(Geometry,Geometry)">
<summary>Computes a copy of each input {@link Geometry}s with the calculated common bits removed from each coordinate.</summary>
<param name="geom0">a Geometry to remove common bits from</param>
<param name="geom1">a Geometry to remove common bits from</param>
<returns>an array containing copies of the input Geometry's with common bits removed</returns>
        </member>
<member name="T:topology.geomgraph.index.SweepLineEvent">
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.index.SweepLineEvent.compareTo(Object)">
<summary>ProjectionEvents are ordered first by their x-value, and then by their eventType.</summary>
        </member>
<member name="T:topology.geom.LineString">
<remarks>Basic implementation of <code>LineString</code>.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.geom.LineString.points">
<summary>The points of this <code>LineString</code>.</summary>
        </member>
<member name="M:topology.geom.LineString.#ctor(Coordinate,PrecisionModel,System.Int32)">
<obsolete>Use GeometryFactory instead</obsolete>
<summary>Constructs a <code>LineString</code> with the given points.</summary>
<param name="points">the points of the linestring, or <code>null</code> to create the empty geometry. This array must not contain <code>null</code> elements. Consecutive points may not be equal.</param>
<param name="precisionModel">the specification of the grid of allowable points for this <code>LineString</code></param>
<param name="SRID">the ID of the Spatial Reference System used by this <code>LineString</code></param>
        </member>
<member name="M:topology.geom.LineString.#ctor(CoordinateSequence,GeometryFactory)">
<param name="points">the points of the linestring, or <code>null</code> to create the empty geometry. Consecutive points may not be equal.</param>
        </member>
<member name="M:topology.geom.LineString.getLength">
<summary>Returns the length of this <code>LineString</code></summary>
<returns>the area of the polygon</returns>
        </member>
<member name="M:topology.geom.LineString.getBoundary">
	<summary>Gets the boundary of this geometry.</summary>
	<returns>the boundary geometry</returns>
	<seealso cref="M:topology.geom.Geometry.getBoundary"/>
</member>
<member name="M:topology.geom.LineString.reverse">
<summary>Creates a {@link LineString} whose coordinates are in the reverse order of this objects</summary>
<returns>a {@link LineString} with coordinates in the reverse order</returns>
        </member>
<member name="M:topology.geom.LineString.isCoordinate(Coordinate)">
<summary>Returns true if the given point is a vertex of this <code>LineString</code>.</summary>
<param name="pt">the <code>Coordinate</code> to check</param>
<returns><code>true</code> if <code>pt</code> is one of this <code>LineString</code> 's vertices</returns>
        </member>
<member name="M:topology.geom.LineString.clone">
<summary>Creates and returns a full copy of this {@link LineString} object.</summary>
<returns>a clone of this instance</returns>
        </member>
<member name="M:topology.geom.LineString.normalize">
<summary>Normalizes a LineString.</summary>
        </member>
<member name="T:topology.algorithm.MCPointInRing">
<remarks>Implements {@link PointInRing} using {@link MonotoneChain}s and a {@link BinTree} index to increase performance.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.index.quadtree.NodeBase">
<remarks>The base class for nodes in a {@link Quadtree}.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.quadtree.NodeBase.getSubnodeIndex(Envelope,Coordinate)">
<summary>Returns the index of the subquad that wholly contains the given envelope.</summary>
        </member>
<member name="F:topology.index.quadtree.NodeBase.subnode">
<summary>subquads are numbered as follows: <pre> 2 | 3 --+-- 0 | 1 </pre></summary>
        </member>
<member name="M:topology.index.quadtree.NodeBase.remove(Envelope,Object)">
<summary>Removes a single item from this subtree.</summary>
<param name="searchEnv">the envelope containing the item</param>
<param name="item">the item to remove</param>
<returns><code>true</code> if the item was found and removed</returns>
        </member>
<member name="T:topology.io.ByteArrayInStream">
<remarks>Allows an array of bytes to be used as an {@link InStream}. To optimize memory usage, instances can be reused with different byte arrays.</remarks>
        </member>
<member name="T:topology.linearref.LengthIndexedLine">
<remarks>Supports linear referencing along a linear {@link Geometry} using the length along the line as the index. Negative length values are taken as measured in the reverse direction from the end of the geometry. Out-of-range index values are handled by clamping them to the valid range of values. Non-simple lines (i.e. which loop back to cross or touch themselves) are supported.</remarks>
        </member>
<member name="M:topology.linearref.LengthIndexedLine.#ctor(Geometry)">
<summary>Constructs an object which allows a linear {@link Geometry} to be linearly referenced using length as an index.</summary>
<param name="linearGeom">the linear geometry to reference along</param>
        </member>
<member name="M:topology.linearref.LengthIndexedLine.extractPoint(System.Double)">
<summary>Computes the {@link Coordinate} for the point on the line at the given index.</summary>
<param name="index">the index of the desired point</param>
<returns>the Coordinate at the given index</returns>
        </member>
<member name="M:topology.linearref.LengthIndexedLine.extractLine(System.Double,System.Double)">
<summary>Computes the {@link LineString} for the interval on the line between the given indices.</summary>
<param name="startIndex">the index of the start of the interval</param>
<param name="endIndex">the index of the end of the interval</param>
<returns>the linear interval between the indices</returns>
        </member>
<member name="M:topology.linearref.LengthIndexedLine.indexOf(Coordinate)">
	<summary>Computes the minimum index for a point on the line.</summary>
	<param name="pt">a point on the line</param>
	<returns>the minimum index of the point</returns>
	<seealso cref="M:topology.linearref.LengthIndexedLine.project(topology.geom.Coordinate pt)"/>
</member>
<member name="M:topology.linearref.LengthIndexedLine.indexOfAfter(Coordinate,System.Double)">
	<summary>Finds the index for a point on the line which is greater than the given index.</summary>
	<param name="pt">a point on the line</param>
	<param name="minIndex">the value the returned index must be greater than</param>
	<returns>the index of the point greater than the given minimum index</returns>
	<seealso cref="M:topology.linearref.LengthIndexedLine.project(topology.geom.Coordinate pt)"/>
</member>
<member name="M:topology.linearref.LengthIndexedLine.indicesOf(Geometry)">
<summary>Computes the indices for a subline of the line.</summary>
<param name="subLine">a subLine of the line</param>
<returns>a pair of indices for the start and end of the subline.</returns>
        </member>
<member name="M:topology.linearref.LengthIndexedLine.project(Coordinate)">
<summary>Computes the index for the closest point on the line to the given point.</summary>
<param name="pt">a point on the line</param>
<returns>the index of the point</returns>
        </member>
<member name="M:topology.linearref.LengthIndexedLine.getStartIndex">
<summary>Returns the index of the start of the line</summary>
<returns>the start index</returns>
        </member>
<member name="M:topology.linearref.LengthIndexedLine.getEndIndex">
<summary>Returns the index of the end of the line</summary>
<returns>the end index</returns>
        </member>
<member name="M:topology.linearref.LengthIndexedLine.isValidIndex(System.Double)">
<summary>Tests whether an index is in the valid index range for the line.</summary>
<param name="length">the index to test</param>
<returns><code>true</code> if the index is in the valid range</returns>
        </member>
<member name="M:topology.linearref.LengthIndexedLine.clampIndex(System.Double)">
<summary>Computes a valid index for this line by clamping the given index to the valid range of index values</summary>
<returns>a valid index value</returns>
        </member>
<member name="T:topology.operation.overlay.snap.LineStringSnapper">
<remarks>Snaps the vertices and segments of a LineString to a set of target snap vertices. A snapping distance tolerance is used to control where snapping is performed.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="M:topology.operation.overlay.snap.LineStringSnapper.#ctor(LineString,System.Double)">
<summary>Creates a new snapper using the points in the given {@link LineString} as target snap points.</summary>
<param name="line">a LineString</param>
<param name="snapTolerance">the snap tolerance to use</param>
        </member>
<member name="M:topology.operation.overlay.snap.LineStringSnapper.#ctor(Coordinate[],System.Double)">
<summary>Creates a new snapper using the given points as target snap points.</summary>
<param name="srcPts">the points to snap to</param>
<param name="snapTolerance">the snap tolerance to use</param>
        </member>
<member name="M:topology.operation.overlay.snap.LineStringSnapper.snapTo(Coordinate[])">
<summary>Snaps the vertices and segments of the source LineString to the given set of target snap points.</summary>
<param name="snapPts">the vertices to snap to</param>
<returns>a new snapped LineString</returns>
        </member>
<member name="M:topology.operation.overlay.snap.LineStringSnapper.snapVertices(CoordinateList,Coordinate[])">
<summary>Snap source vertices to vertices in the target.</summary>
<param name="srcCoords"></param>
<param name="snapPts"></param>
        </member>
<member name="M:topology.operation.overlay.snap.LineStringSnapper.snapSegments(CoordinateList,Coordinate[])">
<summary>Snap segments of the source to nearby snap vertices.</summary>
<param name="srcCoords"></param>
<param name="snapPts"></param>
        </member>
<member name="M:topology.operation.overlay.snap.LineStringSnapper.findSegmentIndexToSnap(Coordinate,CoordinateList)">
<summary>Finds a src segment which snaps to (is close to) the given snap point Only one segment is determined - this is to prevent snapping to multiple segments, which would almost certainly cause invalid geometry to be created.</summary>
<param name="snapPt">the point to snap to</param>
<param name="srcCoords">the source segment coordinates</param>
<returns>the index of the snapped segment</returns>
<returns>-1 if no segment snaps</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.io.WKTWriter -->
<member name="M:topology.io.WKTWriter.toPoint(Coordinate)">
<summary>Generates the WKT for a <code>Point</code>.</summary>
<param name="p0">the point coordinate</param>
<returns>the WKT</returns>
        </member>
<member name="M:topology.io.WKTWriter.toLineString(CoordinateSequence)">
<summary>Generates the WKT for a N-point <code>LineString</code>.</summary>
<param name="seq">the sequence to outpout</param>
<returns>the WKT</returns>
        </member>
<member name="M:topology.io.WKTWriter.toLineString(Coordinate,Coordinate)">
<summary>Generates the WKT for a 2-point <code>LineString</code>.</summary>
<param name="p0">the first coordinate</param>
<param name="p1">the second coordinate</param>
<returns>the WKT</returns>
        </member>
<member name="M:topology.io.WKTWriter.createFormatter(PrecisionModel)">
<summary>Creates the <code>DecimalFormat</code> used to write <code>double</code>s with a sufficient number of decimal places.</summary>
<param name="precisionModel">the <code>PrecisionModel</code> used to determine the number of decimal places to write.</param>
<returns>a <code>DecimalFormat</code> that write <code>double</code> s without scientific notation.</returns>
        </member>
<member name="M:topology.io.WKTWriter.stringOfChar(System.Char,System.Int32)">
<summary>Returns a <code>String</code> of repeated characters.</summary>
<param name="ch">the character to repeat</param>
<param name="count">the number of times to repeat the character</param>
<returns>a <code>String</code> of characters</returns>
        </member>
<member name="M:topology.io.WKTWriter.#ctor">
<summary>Creates a new WKTWriter with default settings</summary>
        </member>
<member name="M:topology.io.WKTWriter.#ctor(System.Int32)">
<summary>Creates a writer that writes {@link Geometry}s with the given output dimension (2 or 3).</summary>
<param name="outputDimension">the coordinate dimension to output (2 or 3)</param>
        </member>
<member name="M:topology.io.WKTWriter.setFormatted(System.Boolean)">
<summary>Sets whether the output will be formatted.</summary>
<param name="isFormatted">true if the output is to be formatted</param>
        </member>
<member name="M:topology.io.WKTWriter.setMaxCoordinatesPerLine(System.Int32)">
<summary>Sets the maximum number of coordinates per line written in formatted output.</summary>
<param name="coordsPerLine">the number of coordinates per line to output.</param>
        </member>
<member name="M:topology.io.WKTWriter.setTab(System.Int32)">
<summary>Sets the tab size to use for indenting.</summary>
<param name="size">the number of spaces to use as the tab string</param>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.io.WKTWriter.write(Geometry) -->
<!-- Badly formed XML comment ignored for member M:topology.io.WKTWriter.write(Geometry,Writer) -->
<!-- Badly formed XML comment ignored for member M:topology.io.WKTWriter.writeFormatted(Geometry) -->
<!-- Badly formed XML comment ignored for member M:topology.io.WKTWriter.writeFormatted(Geometry,Writer) -->
<!-- Badly formed XML comment ignored for member M:topology.io.WKTWriter.writeFormatted(Geometry,System.Boolean,Writer) -->
<member name="M:topology.io.WKTWriter.appendGeometryTaggedText(Geometry,System.Int32,Writer)">
<summary>Converts a <code>Geometry</code> to &lt;Geometry Tagged Text&gt; format, then appends it to the writer.</summary>
<param name="geometry">the <code>Geometry</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendPointTaggedText(Coordinate,System.Int32,Writer,PrecisionModel)">
<summary>Converts a <code>Coordinate</code> to &lt;Point Tagged Text&gt; format, then appends it to the writer.</summary>
<param name="coordinate">the <code>Coordinate</code> to process</param>
<param name="writer">the output writer to append to</param>
<param name="precisionModel">the <code>PrecisionModel</code> to use to convert from a precise coordinate to an external coordinate</param>
        </member>
<member name="M:topology.io.WKTWriter.appendLineStringTaggedText(LineString,System.Int32,Writer)">
<summary>Converts a <code>LineString</code> to &lt;LineString Tagged Text&gt; format, then appends it to the writer.</summary>
<param name="lineString">the <code>LineString</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendLinearRingTaggedText(LinearRing,System.Int32,Writer)">
<summary>Converts a <code>LinearRing</code> to &lt;LinearRing Tagged Text&gt; format, then appends it to the writer.</summary>
<param name="linearRing">the <code>LinearRing</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendPolygonTaggedText(Polygon,System.Int32,Writer)">
<summary>Converts a <code>Polygon</code> to &lt;Polygon Tagged Text&gt; format, then appends it to the writer.</summary>
<param name="polygon">the <code>Polygon</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendMultiPointTaggedText(MultiPoint,System.Int32,Writer)">
<summary>Converts a <code>MultiPoint</code> to &lt;MultiPoint Tagged Text&gt; format, then appends it to the writer.</summary>
<param name="multipoint">the <code>MultiPoint</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendMultiLineStringTaggedText(MultiLineString,System.Int32,Writer)">
<summary>Converts a <code>MultiLineString</code> to &lt;MultiLineString Tagged Text&gt; format, then appends it to the writer.</summary>
<param name="multiLineString">the <code>MultiLineString</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendMultiPolygonTaggedText(MultiPolygon,System.Int32,Writer)">
<summary>Converts a <code>MultiPolygon</code> to &lt;MultiPolygon Tagged Text&gt; format, then appends it to the writer.</summary>
<param name="multiPolygon">the <code>MultiPolygon</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendGeometryCollectionTaggedText(GeometryCollection,System.Int32,Writer)">
<summary>Converts a <code>GeometryCollection</code> to &lt;GeometryCollection Tagged Text&gt; format, then appends it to the writer.</summary>
<param name="geometryCollection">the <code>GeometryCollection</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendPointText(Coordinate,System.Int32,Writer,PrecisionModel)">
<summary>Converts a <code>Coordinate</code> to &lt;Point Text&gt; format, then appends it to the writer.</summary>
<param name="coordinate">the <code>Coordinate</code> to process</param>
<param name="writer">the output writer to append to</param>
<param name="precisionModel">the <code>PrecisionModel</code> to use to convert from a precise coordinate to an external coordinate</param>
        </member>
<member name="M:topology.io.WKTWriter.appendCoordinate(CoordinateSequence,System.Int32,Writer)">
<summary>Appends the i'th coordinate from the sequence to the writer</summary>
<param name="seq">the <code>CoordinateSequence</code> to process</param>
<param name="i">the index of the coordinate to write</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendCoordinate(Coordinate,Writer)">
<summary>Converts a <code>Coordinate</code> to <code>&lt;Point&gt;</code> format, then appends it to the writer.</summary>
<param name="coordinate">the <code>Coordinate</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.writeNumber(System.Double)">
<summary>Converts a <code>double</code> to a <code>String</code>, not in scientific notation.</summary>
<param name="d">the <code>double</code> to convert</param>
<returns>the <code>double</code> as a <code>String</code>, not in scientific notation</returns>
        </member>
<member name="M:topology.io.WKTWriter.appendSequenceText(CoordinateSequence,System.Int32,System.Boolean,Writer)">
<summary>Converts a <code>LineString</code> to &lt;LineString Text&gt; format, then appends it to the writer.</summary>
<param name="lineString">the <code>LineString</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendLineStringText(LineString,System.Int32,System.Boolean,Writer)">
<summary>Converts a <code>LineString</code> to &lt;LineString Text&gt; format, then appends it to the writer.</summary>
<param name="lineString">the <code>LineString</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendPolygonText(Polygon,System.Int32,System.Boolean,Writer)">
<summary>Converts a <code>Polygon</code> to &lt;Polygon Text&gt; format, then appends it to the writer.</summary>
<param name="polygon">the <code>Polygon</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendMultiPointText(MultiPoint,System.Int32,Writer)">
<summary>Converts a <code>MultiPoint</code> to &lt;MultiPoint Text&gt; format, then appends it to the writer.</summary>
<param name="multiPoint">the <code>MultiPoint</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendMultiLineStringText(MultiLineString,System.Int32,System.Boolean,Writer)">
<summary>Converts a <code>MultiLineString</code> to &lt;MultiLineString Text&gt; format, then appends it to the writer.</summary>
<param name="multiLineString">the <code>MultiLineString</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendMultiPolygonText(MultiPolygon,System.Int32,Writer)">
<summary>Converts a <code>MultiPolygon</code> to &lt;MultiPolygon Text&gt; format, then appends it to the writer.</summary>
<param name="multiPolygon">the <code>MultiPolygon</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="M:topology.io.WKTWriter.appendGeometryCollectionText(GeometryCollection,System.Int32,Writer)">
<summary>Converts a <code>GeometryCollection</code> to &lt;GeometryCollectionText&gt; format, then appends it to the writer.</summary>
<param name="geometryCollection">the <code>GeometryCollection</code> to process</param>
<param name="writer">the output writer to append to</param>
        </member>
<member name="T:topology.algorithm.RobustLineIntersector">
	<remarks>A robust version of {@LineIntersector}.</remarks>
	<version>1.7</version>
	<seealso cref="T:topology.algorithm.RobustDeterminant"/>
</member>
<member name="M:topology.algorithm.RobustLineIntersector.intersection(Coordinate,Coordinate,Coordinate,Coordinate)">
<summary>This method computes the actual value of the intersection point.</summary>
        </member>
<member name="M:topology.algorithm.RobustLineIntersector.safeHCoordinateIntersection(Coordinate,Coordinate,Coordinate,Coordinate)">
<summary>Computes a segment intersection using homogeneous coordinates.</summary>
<param name="p1">a segment endpoint</param>
<param name="p2">a segment endpoint</param>
<param name="q1">a segment endpoint</param>
<param name="q2">a segment endpoint</param>
<returns>the computed intersection point</returns>
        </member>
<member name="M:topology.algorithm.RobustLineIntersector.normalizeToMinimum(Coordinate,Coordinate,Coordinate,Coordinate,Coordinate)">
<summary>Normalize the supplied coordinates so that their minimum ordinate values lie at the origin.</summary>
<param name="n1"></param>
<param name="n2"></param>
<param name="n3"></param>
<param name="n4"></param>
<param name="normPt"></param>
        </member>
<member name="M:topology.algorithm.RobustLineIntersector.normalizeToEnvCentre(Coordinate,Coordinate,Coordinate,Coordinate,Coordinate)">
<summary>Normalize the supplied coordinates to so that the midpoint of their intersection envelope lies at the origin.</summary>
<param name="n00"></param>
<param name="n01"></param>
<param name="n10"></param>
<param name="n11"></param>
<param name="normPt"></param>
        </member>
<member name="M:topology.algorithm.RobustLineIntersector.isInSegmentEnvelopes(Coordinate)">
<summary>Test whether a point lies in the envelopes of both input segments.</summary>
<returns><code>true</code> if the input point lies within both input segment envelopes</returns>
        </member>
<member name="T:topology.index.strtree.AbstractNode">
<remarks>A node of the STR tree. The children of this node are either more nodes (AbstractNodes) or real data (ItemBoundables). If this node contains real data (rather than nodes), then we say that this node is a "leaf node".</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.index.strtree.AbstractNode.#ctor(System.Int32)">
<summary>Constructs an AbstractNode at the given level in the tree</summary>
<param name="level">0 if this node is a leaf, 1 if a parent of a leaf, and so on; the root node will have the highest level</param>
        </member>
<member name="M:topology.index.strtree.AbstractNode.getChildBoundables">
<summary>Returns either child AbstractNodes, or if this is a leaf node, real data (wrapped in ItemBoundables).</summary>
        </member>
<member name="M:topology.index.strtree.AbstractNode.computeBounds">
	<summary>Returns a representation of space that encloses this Boundable, preferably not much bigger than this Boundable's boundary yet fast to test for intersection with the bounds of other Boundables.</summary>
	<returns>an Envelope (for STRtrees), an Interval (for SIRtrees), or other object (for other subclasses of AbstractSTRtree)</returns>
	<seealso cref="T:topology.index.strtree.AbstractSTRtree.IntersectsOp"/>
</member>
<member name="M:topology.index.strtree.AbstractNode.getLevel">
<summary>Returns 0 if this node is a leaf, 1 if a parent of a leaf, and so on; the root node will have the highest level</summary>
        </member>
<member name="M:topology.index.strtree.AbstractNode.addChildBoundable(Boundable)">
<summary>Adds either an AbstractNode, or if this is a leaf node, a data object (wrapped in an ItemBoundable)</summary>
        </member>
<member name="T:topology.index.strtree.ItemBoundable">
<remarks>Boundable wrapper for a non-Boundable spatial object. Used internally by AbstractSTRtree.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.operation.relate.EdgeEndBundleStar">
<remarks>An ordered list of {@link EdgeEndBundle}s around a {@link RelateNode}. They are maintained in CCW order (starting with the positive x-axis) around the node for efficient lookup and topology building.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.relate.EdgeEndBundleStar.#ctor">
<summary>Creates a new empty EdgeEndBundleStar</summary>
        </member>
<member name="M:topology.operation.relate.EdgeEndBundleStar.insert(EdgeEnd)">
<summary>Insert a EdgeEnd in order in the list.</summary>
        </member>
<member name="M:topology.operation.relate.EdgeEndBundleStar.updateIM(IntersectionMatrix)">
<summary>Update the IM with the contribution for the EdgeStubs around the node.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.predicate.RectangleContains -->
<member name="M:topology.operation.predicate.RectangleContains.#ctor(Polygon)">
<summary>Create a new contains computer for two geometries.</summary>
<param name="rectangle">a rectangular geometry</param>
        </member>
<member name="T:topology.algorithm.RobustCGAlgorithms">
<remarks>Stub version of RobustCGAlgorithms for backwards compatibility. Will be deprecated in next release - use CGAlgorithms instead.</remarks>
<version>1.7</version>
        </member>
<member name="T:topology.index.sweepline.SweepLineEvent">
<version>1.7</version>
        </member>
<member name="M:topology.index.sweepline.SweepLineEvent.compareTo(Object)">
<summary>ProjectionEvents are ordered first by their x-value, and then by their eventType.</summary>
        </member>
<member name="T:topology.geom.Triangle">
<remarks>Represents a planar triangle, and provides methods for calculating various properties of triangles.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.Triangle.isAcute(Coordinate,Coordinate,Coordinate)">
<summary>Tests whether the triangle is acute.</summary>
<param name="a">a vertex of the triangle</param>
<param name="b">a vertex of the triangle</param>
<param name="c">a vertex of the triangle</param>
<returns>true if the triangle is acute</returns>
        </member>
<member name="M:topology.geom.Triangle.perpendicularBisector(Coordinate,Coordinate)">
<summary>Computes the line which is the perpendicular bisector of the line segment a-b.</summary>
<param name="a">a point</param>
<param name="b">another point</param>
<returns>the perpendicular bisector, as an HCoordinate</returns>
        </member>
<member name="M:topology.geom.Triangle.circumcentre(Coordinate,Coordinate,Coordinate)">
<summary>Computes the circumcentre of a triangle.</summary>
<param name="a">a vertx of the triangle</param>
<param name="b">a vertx of the triangle</param>
<param name="c">a vertx of the triangle</param>
<returns>the circumcentre of the triangle</returns>
        </member>
<member name="M:topology.geom.Triangle.inCentre(Coordinate,Coordinate,Coordinate)">
<summary>Computes the incentre of a triangle.</summary>
<param name="a">a vertx of the triangle</param>
<param name="b">a vertx of the triangle</param>
<param name="c">a vertx of the triangle</param>
<returns>the point which is the incentre of the triangle</returns>
        </member>
<member name="M:topology.geom.Triangle.centroid(Coordinate,Coordinate,Coordinate)">
<summary>Computes the centroid (centre of mass) of a triangle.</summary>
<param name="a">a vertex of the triangle</param>
<param name="b">a vertex of the triangle</param>
<param name="c">a vertex of the triangle</param>
<returns>the centroid of the triangle</returns>
        </member>
<member name="M:topology.geom.Triangle.longestSideLength(Coordinate,Coordinate,Coordinate)">
<summary>Computes the length of the longest side of a triangle</summary>
<param name="a">a vertex of the triangle</param>
<param name="b">a vertex of the triangle</param>
<param name="c">a vertex of the triangle</param>
<returns>the length of the longest side of the triangle</returns>
        </member>
<member name="M:topology.geom.Triangle.angleBisector(Coordinate,Coordinate,Coordinate)">
<summary>Computes the point at which the bisector of the angle ABC cuts the segment AC.</summary>
<param name="a">a vertex of the triangle</param>
<param name="b">a vertex of the triangle</param>
<param name="c">a vertex of the triangle</param>
<returns>the angle bisector cut point</returns>
        </member>
<member name="M:topology.geom.Triangle.area(Coordinate,Coordinate,Coordinate)">
<summary>Computes the area of a triangle.</summary>
<param name="a">a vertex of the triangle</param>
<param name="b">a vertex of the triangle</param>
<param name="c">a vertex of the triangle</param>
<returns>the area of the triangle</returns>
        </member>
<member name="M:topology.geom.Triangle.inCentre">
<summary>Computes the incentre of a triangle.</summary>
<returns>the point which is the inCentre of the triangle</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.predicate.RectangleIntersects -->
<member name="F:topology.operation.predicate.RectangleIntersects.MAXIMUM_SCAN_SEGMENT_COUNT">
<summary>Crossover size at which brute-force intersection scanning is slower than indexed intersection detection.</summary>
        </member>
<member name="M:topology.operation.predicate.RectangleIntersects.#ctor(Polygon)">
<summary>Create a new intersects computer for a rectangle.</summary>
<param name="rectangle">a rectangular geometry</param>
        </member>
<member name="T:topology.operation.predicate.EnvelopeIntersectsVisitor">
<remarks>Tests whether it can be concluded that a rectangle intersects a geometry, based on the locations of the envelope(s) of the geometry.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="M:topology.operation.predicate.EnvelopeIntersectsVisitor.intersects">
<summary>Reports whether it can be concluded that an intersection occurs, or whether further testing is required.</summary>
<returns><code>true</code> if an intersection must occur <code>false</code> if no conclusion can be made</returns>
        </member>
<member name="T:topology.operation.predicate.ContainsPointVisitor">
<remarks>Tests whether it can be concluded that a geometry contains a corner point of a rectangle.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="M:topology.operation.predicate.ContainsPointVisitor.containsPoint">
<summary>Reports whether it can be concluded that a corner point of the rectangle is contained in the geometry, or whether further testing is required.</summary>
<returns><code>true</code> if a corner point is contained <code>false</code> if no conclusion can be made</returns>
        </member>
<member name="T:topology.operation.predicate.LineIntersectsVisitor">
<remarks>Tests whether any line segment of a geometry intersects a given rectangle. Optimizes the algorithm used based on the number of line segments in the test geometry.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="M:topology.operation.predicate.LineIntersectsVisitor.intersects">
<summary>Reports whether any segment intersection exists.</summary>
<returns><code>true</code> if a segment intersection exists <code>false</code> if no segment intersection exists</returns>
        </member>
<member name="T:topology.linearref.LocationIndexOfPoint">
<remarks>Computes the {@link LinearLocation} of the point on a linear {@link Geometry} nearest a given {@link Coordinate}. The nearest point is not necessarily unique; this class always computes the nearest point closest to the start of the geometry.</remarks>
        </member>
<member name="M:topology.linearref.LocationIndexOfPoint.indexOf(Coordinate)">
<summary>Find the nearest location along a linear {@link Geometry} to a given point.</summary>
<param name="inputPt">the coordinate to locate</param>
<returns>the location of the nearest point</returns>
        </member>
<member name="M:topology.linearref.LocationIndexOfPoint.indexOfAfter(Coordinate,LinearLocation)">
<summary>Find the nearest {@link LinearLocation} along the linear {@link Geometry} to a given {@link Coordinate} after the specified minimum {@link LinearLocation}.</summary>
<param name="inputPt">the coordinate to locate</param>
<param name="minLocation">the minimum location for the point location</param>
<returns>the location of the nearest point</returns>
        </member>
<member name="T:topology.linearref.LinearGeometryBuilder">
<remarks>Builds a linear geometry ({@link LineString} or {@link MultiLineString}) incrementally (point-by-point).</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.linearref.LinearGeometryBuilder.setIgnoreInvalidLines(System.Boolean)">
<summary>Allows invalid lines to be ignored rather than causing Exceptions.</summary>
<param name="ignoreShortLines"><code>true</code> if short lines are to be ignored</param>
        </member>
<member name="M:topology.linearref.LinearGeometryBuilder.setFixInvalidLines(System.Boolean)">
<summary>Allows invalid lines to be ignored rather than causing Exceptions.</summary>
<param name="ignoreShortLines"><code>true</code> if short lines are to be ignored</param>
        </member>
<member name="M:topology.linearref.LinearGeometryBuilder.add(Coordinate)">
<summary>Adds a point to the current line.</summary>
<param name="pt">the Coordinate to add</param>
        </member>
<member name="M:topology.linearref.LinearGeometryBuilder.add(Coordinate,System.Boolean)">
<summary>Adds a point to the current line.</summary>
<param name="pt">the Coordinate to add</param>
        </member>
<member name="M:topology.linearref.LinearGeometryBuilder.endLine">
<summary>Terminate the current LineString.</summary>
        </member>
<member name="T:topology.operation.buffer.OffsetCurveSetBuilder">
<remarks>Creates all the raw offset curves for a buffer of a {@link Geometry}. Raw curves need to be noded together and polygonized to form the final buffer area.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveSetBuilder.getCurves">
<summary>Computes the set of raw offset curves for the buffer.</summary>
<returns>a Collection of SegmentStrings representing the raw buffer curves</returns>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveSetBuilder.addCurve(Coordinate[],System.Int32,System.Int32)">
<summary>Creates a {@link SegmentString} for a coordinate list which is a raw offset curve, and adds it to the list of buffer curves.</summary>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveSetBuilder.addPoint(Point)">
<summary>Add a Point to the graph.</summary>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveSetBuilder.addPolygonRing(Coordinate[],System.Double,System.Int32,System.Int32,System.Int32)">
<summary>Add an offset curve for a ring.</summary>
<param name="coord">the coordinates of the ring (must not contain repeated points)</param>
<param name="offsetDistance">the distance at which to create the buffer</param>
<param name="side">the side of the ring on which to construct the buffer line</param>
<param name="cwLeftLoc">the location on the L side of the ring (if it is CW)</param>
<param name="cwRightLoc">the location on the R side of the ring (if it is CW)</param>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveSetBuilder.isErodedCompletely(LinearRing,System.Double)">
<summary>The ringCoord is assumed to contain no repeated points.</summary>
<param name="ringCoord"></param>
<param name="offsetDistance"></param>
<returns></returns>
        </member>
<member name="M:topology.operation.buffer.OffsetCurveSetBuilder.isTriangleErodedCompletely(Coordinate[],System.Double)">
<summary>Tests whether a triangular ring would be eroded completely by the given buffer distance.</summary>
<param name="triangleCoord"></param>
<param name="bufferDistance"></param>
<returns></returns>
        </member>
<member name="T:topology.linearref.LinearIterator">
<remarks>An iterator over the components and coordinates of a linear geometry ({@link LineString}s and {@link MultiLineString}s. The standard usage pattern for a {@link LinearIterator} is: <pre> for (LinearIterator it = new LinearIterator(...); it.hasNext(); it.next()) { ... int ci = it.getComponentIndex();   // for example int vi = it.getVertexIndex();      // for example ... } </pre></remarks>
<version>1.7</version>
        </member>
<!-- Badly formed XML comment ignored for member F:topology.linearref.LinearIterator.currentLine -->
<member name="M:topology.linearref.LinearIterator.#ctor(Geometry)">
<summary>Creates an iterator initialized to the start of a linear {@link Geometry}</summary>
<param name="linear">the linear geometry to iterate over</param>
        </member>
<member name="M:topology.linearref.LinearIterator.#ctor(Geometry,LinearLocation)">
<summary>Creates an iterator starting at a {@link LinearLocation} on a linear {@link Geometry}</summary>
<param name="linear">the linear geometry to iterate over</param>
<param name="start">the location to start at</param>
        </member>
<member name="M:topology.linearref.LinearIterator.#ctor(Geometry,System.Int32,System.Int32)">
<summary>Creates an iterator starting at a component and vertex in a linear {@link Geometry}</summary>
<param name="linear">the linear geometry to iterate over</param>
<param name="componentIndex">the component to start at</param>
<param name="vertexIndex">the vertex to start at</param>
        </member>
<member name="M:topology.linearref.LinearIterator.hasNext">
<summary>Tests whether there are any vertices left to iterator over.</summary>
<returns><code>true</code> if there are more vertices to scan</returns>
        </member>
<member name="M:topology.linearref.LinearIterator.next">
<summary>Moves the iterator ahead to the next vertex and (possibly) linear component.</summary>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.linearref.LinearIterator.isEndOfLine -->
<member name="M:topology.linearref.LinearIterator.getComponentIndex">
<summary>The component index of the vertex the iterator is currently at.</summary>
<returns>the current component index</returns>
        </member>
<member name="M:topology.linearref.LinearIterator.getVertexIndex">
<summary>The vertex index of the vertex the iterator is currently at.</summary>
<returns>the current vertex index</returns>
        </member>
<member name="M:topology.linearref.LinearIterator.getLine">
<summary>Gets the {@link LineString} component the iterator is current at.</summary>
<returns>a linestring</returns>
        </member>
<member name="M:topology.linearref.LinearIterator.getSegmentStart">
<summary>Gets the first {@link Coordinate} of the current segment.</summary>
<returns>a {@link Coordinate}</returns>
        </member>
<member name="M:topology.linearref.LinearIterator.getSegmentEnd">
<summary>Gets the second {@link Coordinate} of the current segment.</summary>
<returns>a {@link Coordinate} or <code>null</code></returns>
        </member>
<member name="T:topology.geom.MultiLineString">
<remarks>Basic implementation of <code>MultiLineString</code>.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.MultiLineString.#ctor(LineString[],PrecisionModel,System.Int32)">
<summary>Constructs a <code>MultiLineString</code>.</summary>
<param name="lineStrings">the <code>LineString</code>s for this <code>MultiLineString</code> , or <code>null</code> or an empty array to create the empty geometry. Elements may be empty <code>LineString</code>s, but not <code>null</code> s.</param>
<param name="precisionModel">the specification of the grid of allowable points for this <code>MultiLineString</code></param>
<param name="SRID">the ID of the Spatial Reference System used by this <code>MultiLineString</code></param>
<obsolete>Use GeometryFactory instead</obsolete>
        </member>
<member name="M:topology.geom.MultiLineString.#ctor(LineString[],GeometryFactory)">
<param name="lineStrings">the <code>LineString</code>s for this <code>MultiLineString</code>, or <code>null</code> or an empty array to create the empty geometry. Elements may be empty <code>LineString</code>s, but not <code>null</code>s.</param>
        </member>
<member name="M:topology.geom.MultiLineString.getBoundary">
	<summary>Gets the boundary of this geometry.</summary>
	<returns>the boundary geometry</returns>
	<seealso cref="M:topology.geom.Geometry.getBoundary"/>
</member>
<member name="M:topology.geom.MultiLineString.reverse">
<summary>Creates a {@link MultiLineString} in the reverse order to this object.</summary>
<returns>a {@link MultiLineString} in the reverse order</returns>
        </member>
<member name="T:topology.operation.overlay.validate.FuzzyPointLocator">
<remarks>Finds the most likely {@link Location} of a point relative to the polygonal components of a geometry, using a tolerance value. If a point is not clearly in the Interior or Exterior, it is considered to be on the Boundary. In other words, if the point is within the tolerance of the Boundary, it is considered to be on the Boundary; otherwise, whether it is Interior or Exterior is determined directly.</remarks>
<author>Martin Davis</author>
<version>1.7</version>
        </member>
<member name="M:topology.operation.overlay.validate.FuzzyPointLocator.extractLinework(Geometry)">
<summary>Extracts linework for polygonal components.</summary>
<param name="g">the geometry from which to extract</param>
<returns>a lineal geometry containing the extracted linework</returns>
        </member>
<member name="T:topology.operation.overlay.validate.PolygonalLineworkExtracter">
<remarks>Extracts the LineStrings in the boundaries of all the polygonal elements in the target {@link Geometry}.</remarks>
<author>Martin Davis</author>
        </member>
<member name="M:topology.operation.overlay.validate.PolygonalLineworkExtracter.filter(Geometry)">
<summary>Filters out all linework for polygonal elements</summary>
        </member>
<member name="M:topology.operation.overlay.validate.PolygonalLineworkExtracter.getLinework">
<summary>Gets the list of polygonal linework.</summary>
<returns>a List of LineStrings</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.polygonize.Polygonizer -->
<member name="T:topology.operation.polygonize.Polygonizer.LineStringAdder">
<remarks>Add every linear element in a geometry into the polygonizer graph.</remarks>
        </member>
<member name="M:topology.operation.polygonize.Polygonizer.#ctor">
<summary>Create a polygonizer with the same {@link GeometryFactory} as the input {@link Geometry}s</summary>
        </member>
<member name="M:topology.operation.polygonize.Polygonizer.add(Collection)">
<summary>Add a collection of geometries to be polygonized.</summary>
<param name="geomList">a list of {@link Geometry}s with linework to be polygonized</param>
        </member>
<member name="M:topology.operation.polygonize.Polygonizer.add(Geometry)">
<summary>Add a geometry to the linework to be polygonized.</summary>
<param name="g">a {@link Geometry} with linework to be polygonized</param>
        </member>
<member name="M:topology.operation.polygonize.Polygonizer.add(LineString)">
<summary>Add a linestring to the graph of polygon edges.</summary>
<param name="line">the {@link LineString} to add</param>
        </member>
<member name="M:topology.operation.polygonize.Polygonizer.getPolygons">
<summary>Gets the list of polygons formed by the polygonization.</summary>
<returns>a collection of {@link Polygon}s</returns>
        </member>
<member name="M:topology.operation.polygonize.Polygonizer.getDangles">
<summary>Get the list of dangling lines found during polygonization.</summary>
<returns>a collection of the input {@link LineString}s which are dangles</returns>
        </member>
<member name="M:topology.operation.polygonize.Polygonizer.getCutEdges">
<summary>Get the list of cut edges found during polygonization.</summary>
<returns>a collection of the input {@link LineString}s which are cut edges</returns>
        </member>
<member name="M:topology.operation.polygonize.Polygonizer.getInvalidRingLines">
<summary>Get the list of lines forming invalid rings found during polygonization.</summary>
<returns>a collection of the input {@link LineString}s which form invalid rings</returns>
        </member>
<member name="M:topology.operation.polygonize.Polygonizer.polygonize">
<summary>Perform the polygonization, if it has not already been carried out.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.Coordinate -->
<member name="F:topology.geom.Coordinate.x">
<summary>The x-coordinate.</summary>
        </member>
<member name="F:topology.geom.Coordinate.y">
<summary>The y-coordinate.</summary>
        </member>
<member name="F:topology.geom.Coordinate.z">
<summary>The z-coordinate.</summary>
        </member>
<member name="M:topology.geom.Coordinate.#ctor(System.Double,System.Double,System.Double)">
<summary>Constructs a <code>Coordinate</code> at (x,y,z).</summary>
<param name="x">the x-value</param>
<param name="y">the y-value</param>
<param name="z">the z-value</param>
        </member>
<member name="M:topology.geom.Coordinate.#ctor">
<summary>Constructs a <code>Coordinate</code> at (0,0,NaN).</summary>
        </member>
<member name="M:topology.geom.Coordinate.#ctor(Coordinate)">
<summary>Constructs a <code>Coordinate</code> having the same (x,y,z) values as <code>other</code>.</summary>
<param name="c">the <code>Coordinate</code> to copy.</param>
        </member>
<member name="M:topology.geom.Coordinate.#ctor(System.Double,System.Double)">
<summary>Constructs a <code>Coordinate</code> at (x,y,NaN).</summary>
<param name="x">the x-value</param>
<param name="y">the y-value</param>
        </member>
<member name="M:topology.geom.Coordinate.setCoordinate(Coordinate)">
<summary>Sets this <code>Coordinate</code>s (x,y,z) values to that of <code>other</code> .</summary>
<param name="other">the <code>Coordinate</code> to copy</param>
        </member>
<member name="M:topology.geom.Coordinate.equals2D(Coordinate)">
<summary>Returns whether the planar projections of the two <code>Coordinate</code>s are equal.</summary>
<param name="other">a <code>Coordinate</code> with which to do the 2D comparison.</param>
<returns><code>true</code> if the x- and y-coordinates are equal; the z-coordinates do not have to be equal.</returns>
        </member>
<member name="M:topology.geom.Coordinate.equals(Object)">
<summary>Returns <code>true</code> if <code>other</code> has the same values for the x and y ordinates.</summary>
<param name="other">a <code>Coordinate</code> with which to do the comparison.</param>
<returns><code>true</code> if <code>other</code> is a <code>Coordinate</code> with the same values for the x and y ordinates.</returns>
        </member>
<member name="M:topology.geom.Coordinate.compareTo(Object)">
<summary>Compares this {@link Coordinate} with the specified {@link Coordinate} for order.</summary>
<param name="o">the <code>Coordinate</code> with which this <code>Coordinate</code> is being compared</param>
<returns>-1, zero, or 1 as this <code>Coordinate</code> is less than, equal to, or greater than the specified <code>Coordinate</code></returns>
        </member>
<member name="M:topology.geom.Coordinate.equals3D(Coordinate)">
<summary>Returns <code>true</code> if <code>other</code> has the same values for x, y and z.</summary>
<param name="other">a <code>Coordinate</code> with which to do the 3D comparison.</param>
<returns><code>true</code> if <code>other</code> is a <code>Coordinate</code> with the same values for x, y and z.</returns>
        </member>
<member name="M:topology.geom.Coordinate.toString">
<summary>Returns a <code>String</code> of the form <I>(x,y,z)</I> .</summary>
<returns>a <code>String</code> of the form <I>(x,y,z)</I></returns>
        </member>
<member name="M:topology.geom.Coordinate.hashCode(System.Double)">
<summary>Returns a hash code for a double value, using the algorithm from Joshua Bloch's book <i>Effective Java"</i></summary>
        </member>
<member name="T:topology.geom.Coordinate.DimensionalComparator">
<remarks>Compares two {@link Coordinate}s, allowing for either a 2-dimensional or 3-dimensional comparison, and handling NaN values correctly.</remarks>
        </member>
<member name="M:topology.geom.Coordinate.DimensionalComparator.compare(System.Double,System.Double)">
<summary>Compare two <code>double</code>s, allowing for NaN values.</summary>
<param name="a">a <code>double</code></param>
<param name="b">a <code>double</code></param>
<returns>-1, 0, or 1 depending on whether a is less than, equal to or greater than b</returns>
        </member>
<member name="M:topology.geom.Coordinate.DimensionalComparator.#ctor">
<summary>Creates a comparator for 2 dimensional coordinates.</summary>
        </member>
<member name="M:topology.geom.Coordinate.DimensionalComparator.#ctor(System.Int32)">
<summary>Creates a comparator for 2 or 3 dimensional coordinates, depending on the value provided.</summary>
<param name="dimensionLimit">the number of dimensions to test</param>
        </member>
<member name="M:topology.geom.Coordinate.DimensionalComparator.compare(Object,Object)">
<summary>Compares two {@link Coordinate}s along to the number of dimensions specified.</summary>
<param name="o1">a {@link Coordinate}</param>
<param name="o2">a {link Coordinate}</param>
<returns>-1, 0, or 1 depending on whether o1 is less than, equal to, or greater than 02</returns>
        </member>
<member name="T:topology.geomgraph.GeometryGraph">
<remarks>A GeometryGraph is a graph that models a given Geometry</remarks>
<version>1.7</version>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.geomgraph.GeometryGraph.determineBoundary(BoundaryNodeRule,System.Int32) -->
<member name="F:topology.geomgraph.GeometryGraph.lineEdgeMap">
<summary>The lineEdgeMap is a map of the linestring components of the parentGeometry to the edges which are derived from them.</summary>
        </member>
<member name="F:topology.geomgraph.GeometryGraph.useBoundaryDeterminationRule">
<summary>If this flag is true, the Boundary Determination Rule will used when deciding whether nodes are in the boundary or not</summary>
        </member>
<member name="M:topology.geomgraph.GeometryGraph.hasTooFewPoints">
<summary>This constructor is used by clients that wish to add Edges explicitly, rather than adding a Geometry.</summary>
        </member>
<member name="M:topology.geomgraph.GeometryGraph.addPoint(Point)">
<summary>Add a Point to the graph.</summary>
        </member>
<member name="M:topology.geomgraph.GeometryGraph.addPolygonRing(LinearRing,System.Int32,System.Int32)">
<summary>The left and right topological location arguments assume that the ring is oriented CW.</summary>
        </member>
<member name="M:topology.geomgraph.GeometryGraph.addEdge(Edge)">
<summary>Add an Edge computed externally.</summary>
        </member>
<member name="M:topology.geomgraph.GeometryGraph.addPoint(Coordinate)">
<summary>Add a point computed externally.</summary>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.geomgraph.GeometryGraph.computeSelfNodes(LineIntersector,System.Boolean) -->
<member name="M:topology.geomgraph.GeometryGraph.insertBoundaryPoint(System.Int32,Coordinate)">
<summary>Adds candidate boundary points using the current {@link BoundaryNodeRule}.</summary>
        </member>
<member name="M:topology.geomgraph.GeometryGraph.addSelfIntersectionNode(System.Int32,Coordinate,System.Int32)">
<summary>Add a node for a self-intersection.</summary>
        </member>
<member name="T:topology.geom.CoordinateFilter">
<remarks><code>Geometry</code> classes support the concept of applying a coordinate filter to every coordinate in the <code>Geometry</code>. A coordinate filter can either record information about each coordinate or change the coordinate in some way. Coordinate filters implement the interface <code>CoordinateFilter</code>. (<code>CoordinateFilter</code> is an example of the Gang-of-Four Visitor pattern). Coordinate filters can be used to implement such things as coordinate transformations, centroid and envelope computation, and many other functions.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.CoordinateFilter.filter(Coordinate)">
<summary>Performs an operation with or on <code>coord</code>.</summary>
<param name="coord">a <code>Coordinate</code> to which the filter is applied.</param>
        </member>
<member name="T:topology.geom.util.Matrix">
<remarks>Implements some 2D matrix operations (in particular, solving systems of linear equations).</remarks>
<author>Martin Davis</author>
        </member>
<member name="M:topology.geom.util.Matrix.solve(System.Double[][],System.Double[])">
<summary>Solves a system of equations using Gaussian Elimination.</summary>
<param name="A">an nxn matrix in row/column order )modified by this method)</param>
<param name="b">a vector of length n</param>
<returns>a vector containing the solution (if any)</returns>
<returns>null if the system has no or no unique solution</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.buffer.BufferSubgraph -->
<member name="M:topology.operation.buffer.BufferSubgraph.getEnvelope">
<summary>Computes the envelope of the edges in the subgraph.</summary>
<returns>the envelope of the graph.</returns>
        </member>
<member name="M:topology.operation.buffer.BufferSubgraph.getRightmostCoordinate">
<summary>Gets the rightmost coordinate in the edges of the subgraph</summary>
        </member>
<member name="M:topology.operation.buffer.BufferSubgraph.create(Node)">
<summary>Creates the subgraph consisting of all edges reachable from this node.</summary>
<param name="node">a node to start the graph traversal from</param>
        </member>
<member name="M:topology.operation.buffer.BufferSubgraph.addReachable(Node)">
<summary>Adds all nodes and edges reachable from this node to the subgraph.</summary>
<param name="node">a node known to be in the subgraph</param>
        </member>
<member name="M:topology.operation.buffer.BufferSubgraph.add(Node,Stack)">
<summary>Adds the argument node and all its out edges to the subgraph</summary>
<param name="node">the node to add</param>
<param name="nodeStack">the current set of nodes being traversed</param>
        </member>
<member name="M:topology.operation.buffer.BufferSubgraph.computeDepths(DirectedEdge)">
<summary>Compute depths for all dirEdges via breadth-first traversal of nodes in graph</summary>
<param name="startEdge">edge to start processing with</param>
        </member>
<member name="M:topology.operation.buffer.BufferSubgraph.findResultEdges">
<summary>Find all edges whose depths indicates that they are in the result area(s).</summary>
        </member>
<member name="M:topology.operation.buffer.BufferSubgraph.compareTo(Object)">
<summary>BufferSubgraphs are compared on the x-value of their rightmost Coordinate.</summary>
        </member>
<member name="T:topology.geomgraph.EdgeEnd">
<remarks>Models the end of an edge incident on a node. EdgeEnds have a direction determined by the direction of the ray from the initial point to the next point. EdgeEnds are comparable under the ordering "a has a greater angle with the x-axis than b". This ordering is used to sort EdgeEnds around a node.</remarks>
<version>1.7</version>
        </member>
<!-- Badly formed XML comment ignored for member M:topology.geomgraph.EdgeEnd.compareDirection(EdgeEnd) -->
<!-- Badly formed XML comment ignored for member T:topology.noding.snapround.SimpleSnapRounder -->
<member name="M:topology.noding.snapround.SimpleSnapRounder.findInteriorIntersections(Collection,LineIntersector)">
<summary>Computes all interior intersections in the collection of {@link SegmentString}s, and returns their @link Coordinate}s.</summary>
<returns>a list of Coordinates for the intersections</returns>
        </member>
<member name="M:topology.noding.snapround.SimpleSnapRounder.computeSnaps(Collection,Collection)">
<summary>Computes nodes introduced as a result of snapping segments to snap points (hot pixels)</summary>
<param name="li"></param>
        </member>
<member name="M:topology.noding.snapround.SimpleSnapRounder.computeVertexSnaps(Collection)">
<summary>Computes nodes introduced as a result of snapping segments to vertices of other segments</summary>
<param name="segStrings">the list of segment strings to snap together</param>
        </member>
<member name="M:topology.noding.snapround.SimpleSnapRounder.computeVertexSnaps(SegmentString,SegmentString)">
<summary>Performs a brute-force comparison of every segment in each {@link SegmentString}.</summary>
        </member>
<member name="M:topology.noding.snapround.SimpleSnapRounder.addSnappedNode(HotPixel,SegmentString,System.Int32)">
<summary>Adds a new node (equal to the snap pt) to the segment if the segment passes through the hot pixel</summary>
<param name="hotPix"></param>
<param name="segStr"></param>
<param name="segIndex"></param>
<returns><code>true</code> if a node was added</returns>
        </member>
<member name="T:topology.noding.SinglePassNoder">
<remarks>Base class for {@link Noder}s which make a single pass to find intersections. This allows using a custom {@link SegmentIntersector} (which for instance may simply identify intersections, rather than insert them).</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.noding.SinglePassNoder.setSegmentIntersector(SegmentIntersector)">
<summary>Sets the SegmentIntersector to use with this noder.</summary>
<param name="segInt"></param>
        </member>
<member name="M:topology.noding.SinglePassNoder.computeNodes(Collection)">
<summary>Computes the noding for a collection of {@link SegmentString}s.</summary>
<param name="segStrings">a collection of {@link SegmentString}s to node</param>
        </member>
<member name="M:topology.noding.SinglePassNoder.getNodedSubstrings">
<summary>Returns a {@link Collection} of fully noded {@link SegmentStrings}.</summary>
<returns>a Collection of SegmentStrings</returns>
        </member>
<member name="T:topology.planargraph.Node">
<remarks>A node in a {@link PlanarGraph}is a location where 0 or more {@link Edge}s meet. A node is connected to each of its incident Edges via an outgoing DirectedEdge. Some clients using a <code>PlanarGraph</code> may want to subclass <code>Node</code> to add their own application-specific data and methods.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.planargraph.Node.getEdgesBetween(Node,Node)">
<summary>Returns all Edges that connect the two nodes (which are assumed to be different).</summary>
        </member>
<member name="F:topology.planargraph.Node.pt">
<summary>The location of this Node</summary>
        </member>
<member name="F:topology.planargraph.Node.deStar">
<summary>The collection of DirectedEdges that leave this Node</summary>
        </member>
<member name="M:topology.planargraph.Node.#ctor(Coordinate)">
<summary>Constructs a Node with the given location.</summary>
        </member>
<member name="M:topology.planargraph.Node.#ctor(Coordinate,DirectedEdgeStar)">
<summary>Constructs a Node with the given location and collection of outgoing DirectedEdges.</summary>
        </member>
<member name="M:topology.planargraph.Node.getCoordinate">
<summary>Returns the location of this Node.</summary>
        </member>
<member name="M:topology.planargraph.Node.addOutEdge(DirectedEdge)">
<summary>Adds an outgoing DirectedEdge to this Node.</summary>
        </member>
<member name="M:topology.planargraph.Node.getOutEdges">
<summary>Returns the collection of DirectedEdges that leave this Node.</summary>
        </member>
<member name="M:topology.planargraph.Node.getDegree">
<summary>Returns the number of edges around this Node.</summary>
        </member>
<member name="M:topology.planargraph.Node.getIndex(Edge)">
<summary>Returns the zero-based index of the given Edge, after sorting in ascending order by angle with the positive x-axis.</summary>
        </member>
<member name="M:topology.planargraph.Node.remove">
<summary>Removes this node from its containing graph.</summary>
        </member>
<member name="M:topology.planargraph.Node.isRemoved">
<summary>Tests whether this node has been removed from its containing graph</summary>
<returns><code>true</code> if this node is removed</returns>
        </member>
<member name="T:topology.geom.impl.CoordinateArraySequenceFactory">
<remarks>Creates {@link CoordinateSequence}s represented as an array of {@link Coordinate}s.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.geom.impl.CoordinateArraySequenceFactory.instance">
<summary>Returns the singleton instance of {@link CoordinateArraySequenceFactory}</summary>
        </member>
<member name="M:topology.geom.impl.CoordinateArraySequenceFactory.create(Coordinate[])">
<summary>Returns a {@link CoordinateArraySequence} based on the given array (the array is not copied).</summary>
<param name="coordinates">the coordinates, which may not be null nor contain null elements</param>
        </member>
<member name="M:topology.geom.impl.CoordinateArraySequenceFactory.create(CoordinateSequence)">
	<seealso cref="M:topology.geom.CoordinateSequenceFactory.create(topology.geom.CoordinateSequence coordSeq)"/>
</member>
<member name="M:topology.geom.impl.CoordinateArraySequenceFactory.create(System.Int32,System.Int32)">
	<seealso cref="M:topology.geom.CoordinateSequenceFactory.create(System.Int32 size,System.Int32 dimension)"/>
</member>
<!-- Badly formed XML comment ignored for member T:topology.geom.Polygon -->
<member name="F:topology.geom.Polygon.shell">
<summary>The exterior boundary, or <code>null</code> if this <code>Polygon</code> is empty.</summary>
        </member>
<member name="F:topology.geom.Polygon.holes">
<summary>The interior boundaries, if any.</summary>
        </member>
<member name="M:topology.geom.Polygon.#ctor(LinearRing,PrecisionModel,System.Int32)">
<summary>Constructs a <code>Polygon</code> with the given exterior boundary.</summary>
<param name="shell">the outer boundary of the new <code>Polygon</code>, or <code>null</code> or an empty <code>LinearRing</code> if the empty geometry is to be created.</param>
<param name="precisionModel">the specification of the grid of allowable points for this <code>Polygon</code></param>
<param name="SRID">the ID of the Spatial Reference System used by this <code>Polygon</code></param>
<obsolete>Use GeometryFactory instead</obsolete>
        </member>
<member name="M:topology.geom.Polygon.#ctor(LinearRing,LinearRing[],PrecisionModel,System.Int32)">
<summary>Constructs a <code>Polygon</code> with the given exterior boundary and interior boundaries.</summary>
<param name="shell">the outer boundary of the new <code>Polygon</code>, or <code>null</code> or an empty <code>LinearRing</code> if the empty geometry is to be created.</param>
<param name="holes">the inner boundaries of the new <code>Polygon</code> , or <code>null</code> or empty <code>LinearRing</code>s if the empty geometry is to be created.</param>
<param name="precisionModel">the specification of the grid of allowable points for this <code>Polygon</code></param>
<param name="SRID">the ID of the Spatial Reference System used by this <code>Polygon</code></param>
<obsolete>Use GeometryFactory instead</obsolete>
        </member>
<member name="M:topology.geom.Polygon.#ctor(LinearRing,LinearRing[],GeometryFactory)">
<summary>Constructs a <code>Polygon</code> with the given exterior boundary and interior boundaries.</summary>
<param name="shell">the outer boundary of the new <code>Polygon</code>, or <code>null</code> or an empty <code>LinearRing</code> if the empty geometry is to be created.</param>
<param name="holes">the inner boundaries of the new <code>Polygon</code> , or <code>null</code> or empty <code>LinearRing</code>s if the empty geometry is to be created.</param>
        </member>
<member name="M:topology.geom.Polygon.isSimple">
<summary>Tests if a valid polygon is simple.</summary>
<returns><code>true</code></returns>
        </member>
<member name="M:topology.geom.Polygon.getArea">
<summary>Returns the area of this <code>Polygon</code></summary>
<returns>the area of the polygon</returns>
        </member>
<member name="M:topology.geom.Polygon.getLength">
<summary>Returns the perimeter of this <code>Polygon</code></summary>
<returns>the perimeter of the polygon</returns>
        </member>
<member name="M:topology.geom.Polygon.getBoundary">
	<summary>Computes the boundary of this geometry</summary>
	<returns>a lineal geometry (which may be empty)</returns>
	<seealso cref="M:topology.geom.Geometry.getBoundary"/>
</member>
<member name="M:topology.geom.Polygon.clone">
<summary>Creates and returns a full copy of this {@link Polygon} object.</summary>
<returns>a clone of this instance</returns>
        </member>
<member name="T:topology.algorithm.NonRobustCGAlgorithms">
<remarks>Non-robust versions of various fundamental Computational Geometric algorithms, <b>FOR TESTING PURPOSES ONLY!</b>. The non-robustness is due to rounding error in floating point computation.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.algorithm.NonRobustCGAlgorithms.isPointInRing(Coordinate,Coordinate[])">
<summary>Computes whether a ring defined by an array of {@link Coordinate} is oriented counter-clockwise.</summary>
<param name="ring">an array of coordinates forming a ring</param>
<returns><code>true</code> if the ring is oriented counter-clockwise.</returns>
        </member>
<member name="M:topology.algorithm.NonRobustCGAlgorithms.isCCW(Coordinate[])">
<summary>Computes whether a ring defined by an array of {@link Coordinate} is oriented counter-clockwise.</summary>
<param name="ring">an array of coordinates forming a ring</param>
<returns><code>true</code> if the ring is oriented counter-clockwise.</returns>
        </member>
<member name="T:topology.precision.EnhancedPrecisionOp">
<remarks>Provides versions of Geometry spatial functions which use enhanced precision techniques to reduce the likelihood of robustness problems.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.precision.EnhancedPrecisionOp.intersection(Geometry,Geometry)">
<summary>Computes the set-theoretic intersection of two {@link Geometry}s, using enhanced precision.</summary>
<param name="geom0">the first Geometry</param>
<param name="geom1">the second Geometry</param>
<returns>the Geometry representing the set-theoretic intersection of the input Geometries.</returns>
        </member>
<member name="M:topology.precision.EnhancedPrecisionOp.union(Geometry,Geometry)">
<summary>Computes the set-theoretic union of two {@link Geometry}s, using enhanced precision.</summary>
<param name="geom0">the first Geometry</param>
<param name="geom1">the second Geometry</param>
<returns>the Geometry representing the set-theoretic union of the input Geometries.</returns>
        </member>
<member name="M:topology.precision.EnhancedPrecisionOp.difference(Geometry,Geometry)">
<summary>Computes the set-theoretic difference of two {@link Geometry}s, using enhanced precision.</summary>
<param name="geom0">the first Geometry</param>
<param name="geom1">the second Geometry</param>
<returns>the Geometry representing the set-theoretic difference of the input Geometries.</returns>
        </member>
<member name="M:topology.precision.EnhancedPrecisionOp.symDifference(Geometry,Geometry)">
<summary>Computes the set-theoretic symmetric difference of two {@link Geometry}s, using enhanced precision.</summary>
<param name="geom0">the first Geometry</param>
<param name="geom1">the second Geometry</param>
<returns>the Geometry representing the set-theoretic symmetric difference of the input Geometries.</returns>
        </member>
<member name="M:topology.precision.EnhancedPrecisionOp.buffer(Geometry,System.Double)">
<summary>Computes the buffer of a {@link Geometry}, using enhanced precision.</summary>
<param name="geom">the first Geometry</param>
<param name="distance">the buffer distance</param>
<returns>the Geometry representing the buffer of the input Geometry.</returns>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.operation.overlay.PolygonBuilder -->
<member name="M:topology.operation.overlay.PolygonBuilder.add(PlanarGraph)">
<summary>Add a complete graph.</summary>
        </member>
<member name="M:topology.operation.overlay.PolygonBuilder.add(Collection,Collection)">
<summary>Add a set of edges and nodes, which form a graph.</summary>
        </member>
<member name="M:topology.operation.overlay.PolygonBuilder.buildMaximalEdgeRings(Collection)">
<summary>for all DirectedEdges in result, form them into MaximalEdgeRings</summary>
        </member>
<member name="M:topology.operation.overlay.PolygonBuilder.findShell(List)">
<summary>This method takes a list of MinimalEdgeRings derived from a MaximalEdgeRing, and tests whether they form a Polygon.</summary>
<returns>the shell EdgeRing, if there is one</returns>
<returns>null, if all the rings are holes</returns>
        </member>
<member name="M:topology.operation.overlay.PolygonBuilder.placePolygonHoles(EdgeRing,List)">
<summary>This method assigns the holes for a Polygon (formed from a list of MinimalEdgeRings) to its shell.</summary>
        </member>
<member name="M:topology.operation.overlay.PolygonBuilder.sortShellsAndHoles(List,List,List)">
<summary>For all rings in the input list, determine whether the ring is a shell or a hole and add it to the appropriate list.</summary>
        </member>
<member name="M:topology.operation.overlay.PolygonBuilder.placeFreeHoles(List,List)">
<summary>This method determines finds a containing shell for all holes which have not yet been assigned to a shell.</summary>
        </member>
<member name="M:topology.operation.overlay.PolygonBuilder.findEdgeRingContaining(EdgeRing,List)">
<summary>Find the innermost enclosing shell EdgeRing containing the argument EdgeRing, if any.</summary>
<returns>containing EdgeRing, if there is one</returns>
<returns>null if no containing EdgeRing is found</returns>
        </member>
<member name="M:topology.operation.overlay.PolygonBuilder.containsPoint(Coordinate)">
<summary>Checks the current set of shells (with their associated holes) to see if any of them contain the point.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.io.ByteOrderValues -->
<member name="T:topology.operation.linemerge.EdgeString">
<remarks>A sequence of {@link LineMergeDirectedEdge}s forming one of the lines that will be output by the line-merging process.</remarks>
<version>1.7</version>
        </member>
<member name="M:topology.operation.linemerge.EdgeString.#ctor(GeometryFactory)">
<summary>Constructs an EdgeString with the given factory used to convert this EdgeString to a LineString</summary>
        </member>
<member name="M:topology.operation.linemerge.EdgeString.add(LineMergeDirectedEdge)">
<summary>Adds a directed edge which is known to form part of this line.</summary>
        </member>
<member name="M:topology.operation.linemerge.EdgeString.toLineString">
<summary>Converts this EdgeString into a LineString.</summary>
        </member>
<!-- Badly formed XML comment ignored for member T:topology.geom.Envelope -->
<member name="M:topology.geom.Envelope.intersects(Coordinate,Coordinate,Coordinate)">
<summary>Test the point q to see whether it intersects the Envelope defined by p1-p2</summary>
<param name="p1">one extremal point of the envelope</param>
<param name="p2">another extremal point of the envelope</param>
<param name="q">the point to test for intersection</param>
<returns><code>true</code> if q intersects the envelope p1-p2</returns>
        </member>
<member name="M:topology.geom.Envelope.intersects(Coordinate,Coordinate,Coordinate,Coordinate)">
<summary>Test the envelope defined by p1-p2 for intersection with the envelope defined by q1-q2</summary>
<param name="p1">one extremal point of the envelope P</param>
<param name="p2">another extremal point of the envelope P</param>
<param name="q1">one extremal point of the envelope Q</param>
<param name="q2">another extremal point of the envelope Q</param>
<returns><code>true</code> if Q intersects P</returns>
        </member>
<member name="F:topology.geom.Envelope.minx">
<summary>the minimum x-coordinate</summary>
        </member>
<member name="F:topology.geom.Envelope.maxx">
<summary>the maximum x-coordinate</summary>
        </member>
<member name="F:topology.geom.Envelope.miny">
<summary>the minimum y-coordinate</summary>
        </member>
<member name="F:topology.geom.Envelope.maxy">
<summary>the maximum y-coordinate</summary>
        </member>
<member name="M:topology.geom.Envelope.#ctor">
<summary>Creates a null <code>Envelope</code>.</summary>
        </member>
<member name="M:topology.geom.Envelope.#ctor(System.Double,System.Double,System.Double,System.Double)">
<summary>Creates an <code>Envelope</code> for a region defined by maximum and minimum values.</summary>
<param name="x1">the first x-value</param>
<param name="x2">the second x-value</param>
<param name="y1">the first y-value</param>
<param name="y2">the second y-value</param>
        </member>
<member name="M:topology.geom.Envelope.#ctor(Coordinate,Coordinate)">
<summary>Creates an <code>Envelope</code> for a region defined by two Coordinates.</summary>
<param name="p1">the first Coordinate</param>
<param name="p2">the second Coordinate</param>
        </member>
<member name="M:topology.geom.Envelope.#ctor(Coordinate)">
<summary>Creates an <code>Envelope</code> for a region defined by a single Coordinate.</summary>
<param name="p1">the Coordinate</param>
        </member>
<member name="M:topology.geom.Envelope.#ctor(Envelope)">
<summary>Create an <code>Envelope</code> from an existing Envelope.</summary>
<param name="env">the Envelope to initialize from</param>
        </member>
<member name="M:topology.geom.Envelope.init">
<summary>Initialize to a null <code>Envelope</code>.</summary>
        </member>
<member name="M:topology.geom.Envelope.init(System.Double,System.Double,System.Double,System.Double)">
<summary>Initialize an <code>Envelope</code> for a region defined by maximum and minimum values.</summary>
<param name="x1">the first x-value</param>
<param name="x2">the second x-value</param>
<param name="y1">the first y-value</param>
<param name="y2">the second y-value</param>
        </member>
<member name="M:topology.geom.Envelope.init(Coordinate,Coordinate)">
<summary>Initialize an <code>Envelope</code> to a region defined by two Coordinates.</summary>
<param name="p1">the first Coordinate</param>
<param name="p2">the second Coordinate</param>
        </member>
<member name="M:topology.geom.Envelope.init(Coordinate)">
<summary>Initialize an <code>Envelope</code> to a region defined by a single Coordinate.</summary>
<param name="p1">the first Coordinate</param>
<param name="p2">the second Coordinate</param>
        </member>
<member name="M:topology.geom.Envelope.init(Envelope)">
<summary>Initialize an <code>Envelope</code> from an existing Envelope.</summary>
<param name="env">the Envelope to initialize from</param>
        </member>
<member name="M:topology.geom.Envelope.setToNull">
<summary>Makes this <code>Envelope</code> a "null" envelope, that is, the envelope of the empty geometry.</summary>
        </member>
<member name="M:topology.geom.Envelope.isNull">
<summary>Returns <code>true</code> if this <code>Envelope</code> is a "null" envelope.</summary>
<returns><code>true</code> if this <code>Envelope</code> is uninitialized or is the envelope of the empty geometry.</returns>
        </member>
<member name="M:topology.geom.Envelope.getWidth">
<summary>Returns the difference between the maximum and minimum x values.</summary>
<returns>max x - min x, or 0 if this is a null <code>Envelope</code></returns>
        </member>
<member name="M:topology.geom.Envelope.getHeight">
<summary>Returns the difference between the maximum and minimum y values.</summary>
<returns>max y - min y, or 0 if this is a null <code>Envelope</code></returns>
        </member>
<member name="M:topology.geom.Envelope.getMinX">
<summary>Returns the <code>Envelope</code>s minimum x-value.</summary>
<returns>the minimum x-coordinate</returns>
        </member>
<member name="M:topology.geom.Envelope.getMaxX">
<summary>Returns the <code>Envelope</code>s maximum x-value.</summary>
<returns>the maximum x-coordinate</returns>
        </member>
<member name="M:topology.geom.Envelope.getMinY">
<summary>Returns the <code>Envelope</code>s minimum y-value.</summary>
<returns>the minimum y-coordinate</returns>
        </member>
<member name="M:topology.geom.Envelope.getMaxY">
<summary>Returns the <code>Envelope</code>s maximum y-value.</summary>
<returns>the maximum y-coordinate</returns>
        </member>
<member name="M:topology.geom.Envelope.expandToInclude(Coordinate)">
<summary>Enlarges the boundary of the <code>Envelope</code> so that it contains (x,y).</summary>
<param name="x">the value to lower the minimum x to or to raise the maximum x to</param>
<param name="y">the value to lower the minimum y to or to raise the maximum y to</param>
        </member>
<member name="M:topology.geom.Envelope.expandBy(System.Double)">
<summary>Expands this envelope by a given distance in all directions.</summary>
<param name="distance">the distance to expand the envelope</param>
<returns>this envelope</returns>
        </member>
<member name="M:topology.geom.Envelope.expandBy(System.Double,System.Double)">
<summary>Expands this envelope by a given distance in all directions.</summary>
<param name="deltaX">the distance to expand the envelope along the the X axis</param>
<param name="deltaY">the distance to expand the envelope along the the Y axis</param>
        </member>
<member name="M:topology.geom.Envelope.expandToInclude(System.Double,System.Double)">
<summary>Enlarges the boundary of the <code>Envelope</code> so that it contains (x,y).</summary>
<param name="x">the value to lower the minimum x to or to raise the maximum x to</param>
<param name="y">the value to lower the minimum y to or to raise the maximum y to</param>
        </member>
<member name="M:topology.geom.Envelope.expandToInclude(Envelope)">
<summary>Enlarges the boundary of the <code>Envelope</code> so that it contains <code>other</code>.</summary>
<param name="other">the <code>Envelope</code> to merge with</param>
        </member>
<member name="M:topology.geom.Envelope.translate(System.Double,System.Double)">
<summary>Translates this envelope by given amounts in the X and Y direction.</summary>
<param name="transX">the amount to translate along the X axis</param>
<param name="transY">the amount to translate along the Y axis</param>
        </member>
<member name="M:topology.geom.Envelope.centre">
<summary>Computes the coordinate of the centre of this envelope (as long as it is non-null</summary>
<returns>the centre coordinate of this envelope <code>null</code> if the envelope is null</returns>
        </member>
<member name="M:topology.geom.Envelope.intersection(Envelope)">
<summary>Computes the intersection of two {@link Envelopes}</summary>
<param name="env">the envelope to intersect with</param>
<returns>a new Envelope representing the intersection of the envelopes (this will be the null envelope if either argument is null, or they do not intersect</returns>
        </member>
<member name="M:topology.geom.Envelope.contains(Coordinate)">
<summary>Returns <code>true</code> if the given point lies in or on the envelope.</summary>
<param name="p">the point which this <code>Envelope</code> is being checked for containing</param>
<returns><code>true</code> if the point lies in the interior or on the boundary of this <code>Envelope</code>.</returns>
        </member>
<member name="M:topology.geom.Envelope.contains(System.Double,System.Double)">
<summary>Returns <code>true</code> if the given point lies in or on the envelope.</summary>
<param name="x">the x-coordinate of the point which this <code>Envelope</code> is being checked for containing</param>
<param name="y">the y-coordinate of the point which this <code>Envelope</code> is being checked for containing</param>
<returns><code>true</code> if <code>(x, y)</code> lies in the interior or on the boundary of this <code>Envelope</code>.</returns>
        </member>
<member name="M:topology.geom.Envelope.intersects(Envelope)">
<summary>Check if the region defined by <code>other</code> overlaps (intersects) the region of this <code>Envelope</code>.</summary>
<param name="other">the <code>Envelope</code> which this <code>Envelope</code> is being checked for overlapping</param>
<returns><code>true</code> if the <code>Envelope</code>s overlap</returns>
        </member>
<member name="M:topology.geom.Envelope.overlaps(Envelope)">
<obsolete>Use #intersects instead. In the future, #overlaps may be changed to be a true overlap check; that is, whether the intersection is two-dimensional.</obsolete>
        </member>
<member name="M:topology.geom.Envelope.intersects(Coordinate)">
<summary>Check if the point <code>p</code> overlaps (lies inside) the region of this <code>Envelope</code>.</summary>
<param name="other">the <code>Coordinate</code> to be tested</param>
<returns><code>true</code> if the point overlaps this <code>Envelope</code></returns>
        </member>
<member name="M:topology.geom.Envelope.overlaps(Coordinate)">
<obsolete>Use #intersects instead.</obsolete>
        </member>
<member name="M:topology.geom.Envelope.intersects(System.Double,System.Double)">
<summary>Check if the point <code>(x, y)</code> overlaps (lies inside) the region of this <code>Envelope</code>.</summary>
<param name="x">the x-ordinate of the point</param>
<param name="y">the y-ordinate of the point</param>
<returns><code>true</code> if the point overlaps this <code>Envelope</code></returns>
        </member>
<member name="M:topology.geom.Envelope.overlaps(System.Double,System.Double)">
<obsolete>Use #intersects instead.</obsolete>
        </member>
<member name="M:topology.geom.Envelope.contains(Envelope)">
<summary>Returns <code>true</code> if the <code>Envelope other</code> lies wholely inside this <code>Envelope</code> (inclusive of the boundary).</summary>
<param name="other">the <code>Envelope</code> which this <code>Envelope</code> is being checked for containing</param>
<returns><code>true</code> if <code>other</code> is contained in this <code>Envelope</code></returns>
        </member>
<member name="M:topology.geom.Envelope.distance(Envelope)">
<summary>Computes the distance between this and another <code>Envelope</code>.</summary>
        </member>
<member name="T:topology.geom.Point">
<remarks>Basic implementation of <code>Point</code>.</remarks>
<version>1.7</version>
        </member>
<member name="F:topology.geom.Point.coordinates">
<summary>The <code>Coordinate</code> wrapped by this <code>Point</code>.</summary>
        </member>
<member name="M:topology.geom.Point.#ctor(Coordinate,PrecisionModel,System.Int32)">
<summary>Constructs a <code>Point</code> with the given coordinate.</summary>
<param name="coordinate">the coordinate on which to base this <code>Point</code> , or <code>null</code> to create the empty geometry.</param>
<param name="precisionModel">the specification of the grid of allowable points for this <code>Point</code></param>
<param name="SRID">the ID of the Spatial Reference System used by this <code>Point</code></param>
<obsolete>Use GeometryFactory instead</obsolete>
        </member>
<member name="M:topology.geom.Point.#ctor(CoordinateSequence,GeometryFactory)">
<param name="coordinates">contains the single coordinate on which to base this <code>Point</code> , or <code>null</code> to create the empty geometry.</param>
        </member>
<member name="M:topology.geom.Point.getBoundary">
	<summary>Gets the boundary of this geometry.</summary>
	<returns>an empty GeometryCollection</returns>
	<seealso cref="M:topology.geom.Geometry.getBoundary"/>
</member>
<member name="M:topology.geom.Point.clone">
<summary>Creates and returns a full copy of this {@link Point} object.</summary>
<returns>a clone of this instance</returns>
        </member>
<member name="T:topology.geomgraph.Node">
<version>1.7</version>
        </member>
<member name="M:topology.geomgraph.Node.isIncidentEdgeInResult">
<summary>Tests whether any incident edge is flagged as being in the result.</summary>
<returns><code>true</code> if any indicident edge in the in the result</returns>
        </member>
<member name="M:topology.geomgraph.Node.computeIM(IntersectionMatrix)">
<summary>Basic nodes do not compute IMs</summary>
        </member>
<member name="M:topology.geomgraph.Node.add(EdgeEnd)">
<summary>Add the edge to the list of edges at this node</summary>
        </member>
<member name="M:topology.geomgraph.Node.mergeLabel(Label)">
<summary>To merge labels for two nodes, the merged location for each LabelElement is computed.</summary>
        </member>
<member name="M:topology.geomgraph.Node.setLabelBoundary(System.Int32)">
<summary>Updates the label of a node to BOUNDARY, obeying the mod-2 boundaryDetermination rule.</summary>
        </member>
<member name="M:topology.geomgraph.Node.computeMergedLocation(Label,System.Int32)">
<summary>The location for a given eltIndex for a node will be one of { null, INTERIOR, BOUNDARY }.</summary>
        </member>
    </members>
</doc>
